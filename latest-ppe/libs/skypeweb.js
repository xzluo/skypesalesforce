var Skype; !function $(Skype, tttrace) { /// <reference path="../pm/missing.d.ts" />
var Skype;
(function (Skype) {
    'use strict';
    /** A reference to the original window object.
        TTT exports a `window` variable for the SDK. */
    Skype.$window = window;
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Rec;
        (function (Rec) {
            'use strict';
            // it's better to use a const enum here and list these names in
            // the trace file; this approach is used in source map files
            Rec.eFireEvent = 'window.onmessage';
            Rec.eFireTimer = 'timeout';
            Rec.eSetTimer = 'timer';
            Rec.eClearTimer = 'clear';
            Rec.eGetRandom = 'random';
            Rec.eGetDate = 'date';
            Rec.eCreateElemenet = 'document.createElement';
            Rec.eAppendChild = 'document.body.appendChild';
            Rec.eRemoveChild = 'document.body.removeChild';
            Rec.eAddEventListener = 'window.addEventListener';
            Rec.eFetch = '.get';
            Rec.eSet = '.set';
            Rec.eSubscribe = '.subscribe';
            Rec.eDispose = '.dispose';
            Rec.eInvoke = '.call';
            Rec.eAddItem = '.add';
            Rec.eRemoveItem = '.remove';
            Rec.eLoadFrame = 'iframe.onload';
            Rec.eCreateRoot = 'new';
            Rec.eSetSSItem = 'sessionStorage.setItem';
            Rec.eGetSSItem = 'sessionStorage.getItem';
            Rec.eRemoveSSItem = 'sessionStorage.removeItem';
            Rec.eXhrSend = 'XHR.send';
            Rec.eXhrRecv = 'XHR.recv';
            Rec.eXhrStop = 'XHR.stop';
            Rec.sId = Symbol('id');
            Rec.sModel = Symbol('model');
            Rec.sWrapper = Symbol('wrapper');
            Rec.sStack = Symbol('stack');
            function Symbol(name) {
                return name + ':' + Skype.$window.Math.random().toString(16).slice(2);
            }
            function assert(condition) {
                if (!condition) {
                    // bad luck - the trace must be broken or there is a bug in ttt;
                    // either way it'll be very hard to figure out how to fix that;
                    // while ttt makes debugging of the client very easy, debugging
                    // of the ttt itself is nearly impossible; there are a few common
                    // causes of this assertion:
                    //
                    //  1.  A direct call from UI to the model. UI is supposed to call
                    //      the runtime-created wrapper which records a log and invokes
                    //      the model, so if UI manages to invoke model directly, no log
                    //      can be written and thus cannot be replayed. Typically this
                    //      happens when the wrapper leaks a model to the UI layer. For
                    //      instance, some improperly written command can return a model
                    //      inside some sophisticated structure, like an array inside a
                    //      custom object; since the wrapper doesn't expect this, it won't
                    //      be able to wrap that model properly.
                    //
                    //  2.  A sophisticated sequence of synchronous calls that causes ttt
                    //      to write several logs in such a sequence, that when it attempts
                    //      to replay them, the sequence of these calls changes. This problem
                    //      is harder to identify, but if identified, it's usually solved
                    //      by making on the calls asynchrounous with setTimeout, which is not
                    //      always possible because not all calls can be made asynchrounous.
                    //
                    //  3.  The trace being replayed does not match the source code against
                    //      which it's being replayed. It's ok to modify the sources in such
                    //      a way that the internal state of the object model doesn't change.
                    //      For instance it's ok to add the "debugger" statement, extra logging
                    //      that doesn't throw exceptions and so on. It's not ok to make extra
                    //      calls to global functions, such as Math.random, because these
                    //      extra calls will confuse the ttt tool.
                    //
                    debugger;
                }
            }
            Rec.assert = assert;
            function stack() {
                var stack = Error().stack; // not all JS engines give it
                return stack && stack.toString().split('\n').slice(4).join('\n');
            }
            Rec.stack = stack;
            Rec.clone = function (x) { return x && JSON.parse(JSON.stringify(x)); };
        })(Rec = Web.Rec || (Web.Rec = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="base.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Rec;
        (function (Rec) {
            'use strict';
            /** Encapsulates the ttt trace. */
            var Trace = (function () {
                function Trace(trace, config) {
                    if (trace === void 0) { trace = []; }
                    if (config === void 0) { config = {}; }
                    this.trace = trace;
                    this.config = config;
                    this.index = 0;
                    this.recording = true;
                    this.recording = trace.length == 0;
                }
                Object.defineProperty(Trace.prototype, "current", {
                    get: function () {
                        return this.trace[this.index];
                    },
                    enumerable: true,
                    configurable: true
                });
                Trace.prototype.write = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    args.splice(0, 0, '#' + this.trace.length);
                    if (this.config.saveTimestamps)
                        args.push(new Skype.$window.Date().toJSON());
                    if (this.config.saveCallstacks)
                        args.push(Rec.stack().split('\n').slice(1));
                    this.trace.push(args);
                };
                Trace.prototype.read = function (name) {
                    var e = this.current;
                    Rec.assert(!name || e[1] == name);
                    this.index++;
                    return e.slice(2);
                };
                Trace.prototype.toJSON = function () {
                    return this.trace;
                };
                return Trace;
            })();
            Rec.Trace = Trace;
        })(Rec = Web.Rec || (Web.Rec = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Rec;
        (function (Rec) {
            'use strict';
            // The SDK is not supposed to call global functions directly; instead, it's
            // supposed to import needed global functions from here and use them.
            Rec.PAL = function (trace, window) {
                // while ttt creates a virtual global environment for the SDK,
                // unit tests create a virtual global environment for ttt itself
                var Date = window.Date;
                var Math = window.Math;
                var setTimeout = window.setTimeout;
                var setInterval = window.setInterval;
                var clearTimeout = window.clearTimeout;
                var clearInterval = window.clearInterval;
                var sessionStorage = window.sessionStorage;
                var console = window.console;
                var document = window.document;
                var XMLHttpRequest = window.XMLHttpRequest;
                var xhrs = {};
                var timers = {};
                var iframes = {};
                var listeners = {};
                var xhrId = 1;
                var iframeId = 1;
                var listenerId = 1;
                var proxy = {
                    /** used by media. Not mocked by ttt yet. */
                    navigator: null,
                    location: {
                        // location may be absent in unit tests
                        hash: window.location && window.location.hash,
                        href: window.location && window.location.href
                    },
                    console: {
                        log: function () {
                            var args = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                args[_i - 0] = arguments[_i];
                            }
                            console.log.apply(console, args);
                        }
                    },
                    /** There is a small problem with this Date mock: the instanceof operator
                        doesn't work with it: (new Date instanceof Date) === false. If a trace
                        depends on the result of such instanceof, it's likely that the trace
                        won't be replayable. */
                    Date: function tttDate(ms) {
                        // for simplicity, only "new Date()" and "new Date(n)" calls
                        // are intercepted; other forms can also be handled if needed            
                        Rec.assert(this instanceof tttDate);
                        Rec.assert(arguments.length < 2);
                        Rec.assert(/number|undefined|string/.test(typeof ms));
                        if (ms)
                            return new Date(ms);
                        if (trace.recording) {
                            var dt = new Date;
                            trace.write(Rec.eGetDate, +dt);
                            return dt;
                        }
                        else {
                            skipTimers();
                            var ms_1 = trace.read(Rec.eGetDate)[0];
                            return new Date(ms_1);
                        }
                    },
                    Math: {
                        log: function (x) {
                            return Math.log(x);
                        },
                        pow: function (x, y) {
                            return Math.pow(x, y);
                        },
                        floor: function (x) {
                            return Math.floor(x);
                        },
                        round: function (x) {
                            return Math.round(x);
                        },
                        random: function () {
                            if (trace.recording) {
                                var num = Math.random();
                                trace.write(Rec.eGetRandom, num);
                                return num;
                            }
                            else {
                                skipTimers();
                                var num = trace.read(Rec.eGetRandom)[0];
                                return num;
                            }
                        }
                    },
                    setTimeout: function (fn, dt) {
                        if (trace.recording) {
                            var id = setTimeout(function () {
                                trace.write(Rec.eFireTimer, id);
                                fn();
                            }, dt);
                            trace.write(Rec.eSetTimer, id, dt, /*recurring=*/ false);
                            return id;
                        }
                        else {
                            var _a = trace.read(Rec.eSetTimer), id = _a[0], _dt = _a[1], recurring = _a[2];
                            Rec.assert(_dt == dt);
                            Rec.assert(!recurring);
                            Rec.assert(!timers[id]);
                            timers[id] = fn;
                            return id;
                        }
                    },
                    clearTimeout: function (id) {
                        if (trace.recording) {
                            trace.write(Rec.eClearTimer, id);
                            clearTimeout(id);
                        }
                        else {
                            var _id = trace.read(Rec.eClearTimer)[0];
                            Rec.assert(_id == id);
                            Rec.assert(timers[id]);
                            delete timers[id];
                        }
                    },
                    setInterval: function (fn, dt) {
                        if (trace.recording) {
                            var id = setInterval(function () {
                                trace.write(Rec.eFireTimer, id);
                                fn();
                            }, dt);
                            trace.write(Rec.eSetTimer, id, dt, /*recurring=*/ true);
                            return id;
                        }
                        else {
                            var _a = trace.read(Rec.eSetTimer), id = _a[0], _dt = _a[1], recurring = _a[2];
                            Rec.assert(_dt == dt);
                            Rec.assert(recurring);
                            Rec.assert(!timers[id]);
                            timers[id] = fn;
                            return id;
                        }
                    },
                    clearInterval: function (id) {
                        if (trace.recording) {
                            trace.write(Rec.eClearTimer, id);
                            clearInterval(id);
                        }
                        else {
                            var _id = trace.read(Rec.eClearTimer)[0];
                            Rec.assert(_id == id);
                            Rec.assert(timers[id]);
                            delete timers[id];
                        }
                    },
                    addEventListener: function (name, callback) {
                        // this is the only event that the client needs
                        Rec.assert(name == 'message');
                        if (trace.recording) {
                            var cid = listenerId++;
                            trace.write(Rec.eAddEventListener, cid);
                            window.addEventListener('message', function (event) {
                                try {
                                    var data = JSON.parse(event.data);
                                    trace.write(Rec.eFireEvent, cid, data);
                                    callback(event);
                                }
                                catch (err) {
                                }
                            });
                        }
                        else {
                            var _id = trace.read(Rec.eAddEventListener)[0];
                            Rec.assert(_id == listenerId);
                            Rec.assert(!listeners[listenerId]);
                            listeners[listenerId] = callback;
                            listenerId++;
                        }
                    },
                    document: {
                        createElement: function (name) {
                            // this is the only element that the client creates
                            Rec.assert(name == 'iframe');
                            if (trace.recording) {
                                var iframe = document.createElement(name);
                                iframe[Rec.sId] = iframeId++;
                                trace.write(Rec.eCreateElemenet, iframe[Rec.sId]);
                                return iframe;
                            }
                            else {
                                var e = trace.read(Rec.eCreateElemenet);
                                var iid = e[0];
                                var iframe = { style: {}, contentWindow: { postMessage: function () { } } };
                                iframe[Rec.sId] = iid;
                                Rec.assert(!iframes[iid]);
                                iframes[iid] = iframe;
                                return iframe;
                            }
                        },
                        body: {
                            appendChild: function (iframe) {
                                if (trace.recording) {
                                    Rec.assert(iframe[Rec.sId]);
                                    trace.write(Rec.eAppendChild, iframe[Rec.sId]);
                                    var onload_1 = iframe.onload;
                                    iframe.onload = function () {
                                        // in chrome .onload can be somehow directly called
                                        // by .appendChild: I can't explain this; setTimeout
                                        // is a workaround for this
                                        setTimeout(function () {
                                            trace.write(Rec.eLoadFrame, iframe[Rec.sId]);
                                            onload_1.call(iframe);
                                        }, 0);
                                    };
                                    document.body.appendChild(iframe);
                                }
                                else {
                                    var _id = trace.read(Rec.eAppendChild)[0];
                                    Rec.assert(_id == iframe[Rec.sId]);
                                }
                            },
                            removeChild: function (iframe) {
                                if (trace.recording) {
                                    trace.write(Rec.eRemoveChild, iframe[Rec.sId]);
                                    document.body.removeChild(iframe);
                                }
                                else {
                                    var _id = trace.read(Rec.eRemoveChild)[0];
                                    Rec.assert(_id == iframe[Rec.sId]);
                                }
                            }
                        }
                    },
                    sessionStorage: {
                        setItem: function (key, val) {
                            if (trace.recording) {
                                sessionStorage.setItem(key, val);
                                trace.write(Rec.eSetSSItem, key);
                            }
                            else {
                                var _key = trace.read(Rec.eSetSSItem)[0];
                                Rec.assert(_key == key);
                            }
                        },
                        getItem: function (key) {
                            if (trace.recording) {
                                var val = sessionStorage.getItem(key);
                                trace.write(Rec.eGetSSItem, key, val);
                                return val;
                            }
                            else {
                                var _a = trace.read(Rec.eGetSSItem), _key = _a[0], val = _a[1];
                                Rec.assert(_key == key);
                                return val;
                            }
                        },
                        removeItem: function (key) {
                            if (trace.recording) {
                                sessionStorage.removeItem(key);
                                trace.write(Rec.eRemoveSSItem, key);
                            }
                            else {
                                var _key = trace.read(Rec.eRemoveSSItem)[0];
                                Rec.assert(_key == key);
                            }
                        }
                    },
                    XMLHttpRequest: ((function () {
                        function XMLHttpRequestTTT() {
                            this.headers = {};
                            this.id = xhrId++;
                            if (trace.recording)
                                this.xhr = new XMLHttpRequest;
                            xhrs[this.id] = this;
                        }
                        XMLHttpRequestTTT.prototype.open = function (type, url, async) {
                            if (async === void 0) { async = true; }
                            if (trace.recording) {
                                this.type = type;
                                this.url = url;
                                if (!async)
                                    throw Error('XHR requests must be async');
                                this.xhr.open(type, url, async);
                            }
                        };
                        XMLHttpRequestTTT.prototype.abort = function () {
                            if (trace.recording) {
                                trace.write(Rec.eXhrStop, this.id);
                                this.xhr.abort();
                            }
                            else {
                                var id = trace.read(Rec.eXhrStop)[0];
                                Rec.assert(id == this.id);
                            }
                        };
                        XMLHttpRequestTTT.prototype.setRequestHeader = function (name, value) {
                            if (trace.recording) {
                                this.headers[name] = value;
                                this.xhr.setRequestHeader(name, value);
                            }
                        };
                        XMLHttpRequestTTT.prototype.getAllResponseHeaders = function () {
                            return this.responseHeaders;
                        };
                        XMLHttpRequestTTT.prototype.send = function (data) {
                            var _this = this;
                            if (trace.recording) {
                                var xhr = this.xhr;
                                xhr.onreadystatechange = function () {
                                    // for simplicity, only the final
                                    // state change event is recorded
                                    if (xhr.readyState != 4)
                                        return;
                                    _this.readyState = xhr.readyState;
                                    _this.status = xhr.status;
                                    _this.statusText = xhr.statusText;
                                    _this.responseHeaders = xhr.getAllResponseHeaders();
                                    _this.responseText = xhr.responseText;
                                    trace.write(Rec.eXhrRecv, _this.id, {
                                        status: _this.status,
                                        statusText: _this.statusText,
                                        headers: _this.responseHeaders.split('\r\n'),
                                        data: _this.responseText
                                    });
                                    _this.xhr = null;
                                    _this.onreadystatechange();
                                };
                                trace.write(Rec.eXhrSend, this.id, {
                                    type: this.type,
                                    url: this.url,
                                    headers: this.headers,
                                    data: data
                                });
                                this.xhr.send(data);
                            }
                            else {
                                var id = trace.read(Rec.eXhrSend)[0];
                                Rec.assert(id == this.id);
                            }
                        };
                        XMLHttpRequestTTT.prototype.recv = function (_a) {
                            var status = _a.status, statusText = _a.statusText, headers = _a.headers, data = _a.data;
                            this.readyState = 4;
                            this.status = status;
                            this.statusText = statusText;
                            this.responseHeaders = headers.join('\r\n');
                            this.responseText = data;
                            this.onreadystatechange();
                        };
                        return XMLHttpRequestTTT;
                    })())
                };
                function skipTimers() {
                    while (true) {
                        var e = trace.current;
                        // is it a call from a promise object created by UI via .then?
                        // if so, simulate a fake call to setTimeout
                        // if not, there will be a cryptic error a thousand events later :)
                        if (e[1] == Rec.eSetTimer)
                            proxy.setTimeout(function () { }, e[3]);
                        else
                            return;
                    }
                }
                return {
                    window: proxy,
                    skipTimers: skipTimers,
                    play: function (name, id, data) {
                        switch (name) {
                            case Rec.eFireTimer:
                                timers[id].call();
                                return true;
                            case Rec.eFireEvent:
                                listeners[id].call(null, { data: JSON.stringify(data) });
                                return true;
                            case Rec.eLoadFrame:
                                iframes[id].onload();
                                return true;
                            case Rec.eXhrRecv:
                                xhrs[id].recv(data);
                                return true;
                        }
                    }
                };
            };
        })(Rec = Web.Rec || (Web.Rec = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Rec;
        (function (Rec) {
            'use strict';
            function setHiddenProperty(object, name, value) {
                Object.defineProperty(object, name, {
                    value: value,
                    enumerable: false
                });
            }
            function forward(name) {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    return Web['Utils'][name].apply(this, args);
                };
            }
            // ttt needs to use certain functions from utils,
            // but it cannot import them at the beginning because
            // tt is loaded before utils
            var isProperty = forward('isProperty');
            var isCollection = forward('isCollection');
            var isFunction = forward('isFunction');
            var Model = forward('Model');
            var Command = forward('Command');
            var ConstProperty = forward('ConstProperty');
            var isPromise = forward('isPromise');
            var isModel = forward('isModel');
            var map = forward('map');
            var foreach = forward('foreach');
            var isArray = forward('isArray');
            Rec.Wrapper = function (trace, window) {
                var wrappers = {};
                var subscriptions = {};
                var wrapperId = 1;
                function deferIf(condition, fn) {
                    if (condition)
                        window.setTimeout(fn, 0);
                    else
                        fn();
                }
                function wrap(obj) {
                    function $(is, fn, prefix) {
                        if (is(obj)) {
                            var id = prefix + wrapperId++;
                            var wr = fn(obj, id);
                            Rec.assert(wr);
                            setHiddenProperty(wr, Rec.sModel, obj);
                            setHiddenProperty(obj, Rec.sWrapper, wr);
                            setHiddenProperty(wr, Rec.sId, id);
                            setHiddenProperty(wr, Rec.sStack, Rec.stack());
                            wrappers[id] = wr;
                            return wr;
                        }
                    }
                    // trying to wrap a wrapper?
                    Rec.assert(!obj || !obj[Rec.sModel]);
                    // the model may have been already wrapped
                    var wrapper = obj && obj[Rec.sWrapper];
                    // there is a peculiar case when [sWrapper] refers
                    // to a wrong wrapper: if there is a model A, and
                    // model B is the prototype of A (i.e. a Message
                    // can be the prototype of an ActivityItem), then
                    // wrapping B first creates B[sWrapper] = wrB; then
                    // wrap(A) sees that A[sWrapper] is wrB, but wrB
                    // cannot be used as a wrapper for A because A is
                    // a superset of B and wrB is missing some properties
                    // for A; hence A[sWrapper] needs to be overwritten;
                    // however this doesn't overwrite B[sWrapper] due to
                    // the way prototypes work in JS and hence A[sWrapper]
                    // and B[sWrapper] refer to different wrappers while
                    // B remains the prototype of A
                    if (wrapper && wrapper[Rec.sModel] !== obj)
                        wrapper = null;
                    return wrapper ||
                        $(isProperty, wrapProperty, 'p') ||
                        $(isCollection, wrapCollection, 'c') ||
                        $(isFunction, wrapCommand, 'f') ||
                        $(isPromise, wrapPromise, 't') ||
                        $(isModel, wrapModel, 'm');
                }
                function wrid(wrapper) {
                    return wrapper && wrapper[Rec.sId];
                }
                function serialize(wr) {
                    return wrid(wr) || wr;
                }
                function deserialize(id) {
                    return wrappers[id] || id;
                }
                function unwrap(wrapper) {
                    return wrapper && wrapper[Rec.sModel] || wrapper;
                }
                function wrapModel(model) {
                    var wrModel = Model();
                    foreach(model, function (m, i) {
                        var w = wrap(m);
                        // drop all unrecognized fields
                        if (w)
                            wrModel[i] = w;
                    });
                    // TODO: some objects still add and remove members at runtime;
                    // once this is fixed, the "if" below can be removed
                    if (model.changed) {
                        model.changed(function () {
                            foreach(wrModel, function (val, key) {
                                if (!model[key])
                                    delete wrModel[key];
                            });
                            foreach(model, function (m, i) {
                                if (!wrModel[i]) {
                                    var w = wrap(m);
                                    if (w)
                                        wrModel[i] = w;
                                }
                            });
                        });
                    }
                    return wrModel;
                }
                function wrapProperty(p, id) {
                    var sub, init = true;
                    Rec.assert(id);
                    // TODO: the current implentation assumes that a property
                    // can contain a primitive value only; if it can contain a model,
                    // the wrapper will need to record the model id
                    var wrProperty = p.constructor({
                        get: function () {
                            if (trace.recording)
                                trace.write(Rec.eFetch, id);
                            return p.get();
                        },
                        set: function (value, reason) {
                            if (trace.recording)
                                trace.write(Rec.eSet, id, value, reason);
                            return p.set(value, reason);
                        },
                        subscribed: function () {
                            if (trace.recording)
                                trace.write(Rec.eSubscribe, id);
                            sub = p.subscribe();
                            subscriptions[id] = sub;
                        },
                        unsubscribed: function () {
                            if (trace.recording)
                                trace.write(Rec.eDispose, id);
                            sub.dispose();
                        }
                    });
                    // .location is a property which has attached properties:
                    // .street, .city and so on; this is the only instance of
                    // such "advanced" property in the entire model; note how
                    // "private" fields that start with _ are skipped: they
                    // could be made non-enumerable in the pm, but that would
                    // have had unpredictable impact on perf and mem consumption
                    foreach(p, function (m, i) {
                        if (isProperty(m) && !wrProperty[i] && !/^_/.test(i))
                            wrProperty[i] = wrap(m);
                    });
                    p.changed(function (value, reason) {
                        deferIf(!init && trace.recording, function () {
                            wrProperty(value, p.constructor.sUpdated);
                        });
                    });
                    init = false;
                    return wrProperty;
                }
                function wrapCollection(c, id) {
                    var sub, init = true;
                    Rec.assert(id);
                    var wrCollection = c.constructor({
                        get: function () {
                            if (trace.recording)
                                trace.write(Rec.eFetch, id);
                            return wrap(c.get());
                        },
                        subscribed: function () {
                            if (trace.recording)
                                trace.write(Rec.eSubscribe, id);
                            sub = c.subscribe();
                            subscriptions[id] = sub;
                        },
                        unsubscribed: function () {
                            if (trace.recording)
                                trace.write(Rec.eDispose, id);
                            sub.dispose();
                        }
                    });
                    c.added(function (val, key, idx) {
                        var wrItem = wrap(val) || val;
                        deferIf(!init && trace.recording, function () {
                            wrCollection.add(wrItem, key, idx);
                        });
                    });
                    c.removed(function (val, key) {
                        deferIf(trace.recording, function () {
                            wrCollection.remove(key);
                        });
                    });
                    init = false;
                    return wrCollection.asWritable({
                        add: function (wrapper) {
                            if (trace.recording)
                                // participants.add("sip:johndoe@contoso.com")
                                // wrid("sip:johndoe@contoso.com") == null
                                trace.write(Rec.eAddItem, id, wrid(wrapper) || wrapper);
                            return c.add(unwrap(wrapper));
                        },
                        remove: function (wrapper) {
                            if (trace.recording)
                                trace.write(Rec.eRemoveItem, id, wrid(wrapper) || wrapper);
                            return c.remove(unwrap(wrapper));
                        }
                    });
                }
                function wrapCommand(cmd, id) {
                    var wrCommand = Command(function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i - 0] = arguments[_i];
                        }
                        if (trace.recording)
                            trace.write(Rec.eInvoke, id, map(args, serialize));
                        var res = cmd.apply(null, args.map(unwrap));
                        return wrap(res) || res;
                    }, wrap(cmd.enabled || ConstProperty(true)));
                    return wrCommand;
                }
                function wrapPromise(p) {
                    return p.then(function (r) {
                        return isArray(r) ?
                            r.map(function (v) { return wrap(v) || v; }) :
                            (wrap(r) || r); // Property<Model>::get returns a Promise<Model>
                    });
                }
                return {
                    wrap: wrap,
                    play: function (e) {
                        switch (e[0]) {
                            case Rec.eFetch:
                                wrappers[e[1]].get();
                                return true;
                            case Rec.eSet:
                                wrappers[e[1]].set(e[2], e[3]);
                                return true;
                            case Rec.eSubscribe:
                                wrappers[e[1]].subscribe();
                                return true;
                            case Rec.eDispose:
                                subscriptions[e[1]].dispose();
                                return true;
                            case Rec.eInvoke:
                                wrappers[e[1]].apply(null, e[2].map(deserialize));
                                return true;
                            case Rec.eAddItem:
                                wrappers[e[1]].add(wrappers[e[2]] || e[2]);
                                return true;
                            case Rec.eRemoveItem:
                                wrappers[e[1]].remove(wrappers[e[2]] || e[2]);
                                return true;
                        }
                    }
                };
            };
        })(Rec = Web.Rec || (Web.Rec = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Rec;
        (function (Rec) {
            'use strict';
            /**
             * Records a complete trace of the SDK's activity.
             *
             * This is achieved by mocking the global environment,
             * such as the setTimeout and Math.random functions,
             * and wrapping the entire client object model into a
             * wrapper with the same interface which intercepts all the
             * calls from the UI and records them in the log.
             *
             * After the trace is recorded, it can be replayed to
             * simulate the recorded activity. This enables debugging
             * of the recorded scenario and replaying it deteministically.
             * Essemtially it allows to record a hard-to-repro bug
             * once and then replay it as many times as needed.
             *
             * @blame antonkh
             */
            function TTT(window, jsonlog) {
                'use strict';
                var isRecording = !jsonlog;
                var trace = new Rec.Trace(jsonlog, {});
                var pal = Rec.PAL(trace, window);
                var wrapper = Rec.Wrapper(trace, window);
                function play() {
                    while (trace.current) {
                        pal.skipTimers();
                        this.tick = trace.index;
                        var e = trace.current.slice(1);
                        trace.index++;
                        switch (e[0]) {
                            case Rec.eCreateRoot:
                                this.root(e[1]);
                                break;
                            default:
                                if (pal.play(e[0], e[1], e[2]))
                                    break;
                                if (wrapper.play(e))
                                    break;
                                Rec.assert(false);
                        }
                    }
                }
                function createRootModel(settings) {
                    var root = new this.ctor(settings || void 0);
                    var wrRoot = wrapper.wrap(root);
                    if (isRecording)
                        trace.write(Rec.eCreateRoot, Rec.clone(settings));
                    return wrRoot;
                }
                function makeFiles(name) {
                    // save a .json file with just the log if the client was loaded
                    // from separate files, which is the common case during development;
                    // otherwise if the client was loaded from a single file, generate
                    // a self executing script that loads the client's and the ttt's
                    // code that matches the generated trace and replays this trace
                    var timestamp = new Skype.$window.Date().toJSON();
                    var _a = name ? name.split('.') : [], _b = _a[0], fileName = _b === void 0 ? timestamp.replace(/:/g, '-') : _b, _c = _a[1], ext = _c === void 0 ? 'html' : _c;
                    var htmlFileName = fileName + '.' + ext;
                    // saving .js files under non .js extensions doesn't break the .html
                    // but allows to bypass the browser's prompt for saving "dangerous" files
                    var jsonFileName = fileName + '.ttt';
                    var selfFileName = fileName + '.src';
                    return (_d = {},
                        _d[jsonFileName] = new Blob([
                            'window["' + timestamp + '"] = ',
                            JSON.stringify(trace, null, '\t')
                        ], { type: 'application/json' }),
                        _d[selfFileName] = new Blob([
                            'var Skype; !' + $ + '(Skype = window.Skype || {}, "' + timestamp + '");'
                        ], { type: 'application/javascript' }),
                        _d[htmlFileName] = new Blob([
                            '<!doctype html>' +
                                '<html>' +
                                '<head>' +
                                '<title>' + timestamp + '</title>' +
                                '<script type="text/javascript" src="' + jsonFileName + '"></script>' +
                                '<script type="text/javascript" src= "' + selfFileName + '"></script>' +
                                '</head>' +
                                '<body><script>' +
                                'try { ttt.play();' +
                                'document.write("Trace has been replayed. See dev console.")' +
                                '} catch (err) { document.write("<pre>" + (err && err.stack || err) + "</pre>") }' +
                                '</script></body>' +
                                '</html>'
                        ], { type: 'text/html' }),
                        _d
                    );
                    var _d;
                }
                /** Currently not used, but can be used to automatically
                    send the trace to localhost, zip it on the server and
                    attach to a bug report. */
                function send(name, url) {
                    sendFiles(url, makeFiles(name));
                }
                function sendFiles(url, files) {
                    var data = new window.FormData;
                    var xhr = new window.XMLHttpRequest;
                    for (var name_1 in files)
                        data.append(name_1, files[name_1], name_1);
                    xhr.open('POST', url || '/ttt');
                    xhr.send(data);
                }
                function save(name) {
                    saveFiles(makeFiles(name));
                }
                function saveFiles(files) {
                    for (var name_2 in files)
                        saveFile(name_2, files[name_2]);
                }
                function saveFile(name, blob) {
                    var a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = name;
                    a.click();
                }
                // window.window checks whether ttt is being unit tested
                if (window.window) {
                    try {
                        if (isRecording) {
                            Error.stackTraceLimit = Infinity;
                            console.log('TTT is enabled. Invoke ttt.save() to get the recorded trace.');
                        }
                    }
                    catch (err) {
                    }
                }
                // ttt doesn't override any global functions or objects
                // but instead offers to use its own version of the global
                // environment; thus whoever wants to opt-in can do so
                // by using explicitly ttt.window as the global object,
                // while those who don't want to opt-in, won't notice ttt
                return {
                    window: pal.window,
                    save: save,
                    send: send,
                    play: play,
                    dump: function () { return JSON.parse(JSON.stringify(trace)); },
                    ctor: null,
                    root: createRootModel
                };
            }
            Rec.TTT = TTT;
        })(Rec = Web.Rec || (Web.Rec = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="ttt/trace.ts" />
/// <reference path="ttt/pal.ts" />
/// <reference path="ttt/wrapper.ts" />
/// <reference path="ttt/rec.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        'use strict';
        var isEnabled = false;
        try {
            /** TTT is enabled by the #ttt parameter in the URL
                or by "ttt" flag in sessionStorage. */
            isEnabled = typeof tttrace === 'string' ||
                typeof location === 'object' && /\bttt$/.test(location.hash) ||
                typeof location === 'object' && /\bttt$/.test(location.search) ||
                typeof sessionStorage === 'object' && sessionStorage.getItem('ttt');
        }
        catch (err) {
        }
        Web.TTT = Web.Rec.TTT;
        Web.ttt = isEnabled ? Web.TTT(Skype.$window, Skype.$window[tttrace]) : null;
        if (Web.ttt)
            Skype.$window.ttt = Web.ttt;
        // after this exports references to these symbols can be
        // intercepted by ttt: if there is a reference to a symbol
        // ts first checks whether the symbol exists in the namespace
        // and only then checks the global scope
        Web.window = Web.ttt ? Web.ttt.window : Skype.$window;
        Web.setTimeout = Web.window.setTimeout.bind(Web.window);
        Web.setInterval = Web.window.setInterval.bind(Web.window);
        Web.clearTimeout = Web.window.clearTimeout.bind(Web.window);
        Web.clearInterval = Web.window.clearInterval.bind(Web.window);
        Web.Date = Web.window.Date;
        Web.Math = Web.window.Math;
        Web.XMLHttpRequest = Web.window.XMLHttpRequest;
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="missing.d.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        /** This flag is set by the test runners. */
        Web.isUnitTested = !!Web['isUnitTested'];
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            Settings.dbgBreak = false;
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /** Uses Object.setPrototypeOf to replace the prototype of
                created properties and collection, which are functions.
                This trick reduces the memory usage, but might be unsafe. */
            Utils.replacePrototype = true;
            /** Just a function that does nothing. */
            Utils.noop = function () { };
            /** true in async functions */
            Utils.sIsAsync = Symbol('async');
            function isAsyncFunction(x) {
                return x && x[Utils.sIsAsync];
            }
            Utils.isAsyncFunction = isAsyncFunction;
            /**
             * Converts a regular function into an "async" function
             * that always returns a promise. Works similarly to
             * the "async" function from the "Q" library.
             *
             * @blame antonkh
             */
            function async(fn, mode, md) {
                if (isFunction(fn)) {
                    // async(async(fn)) == async(fn)
                    var fna = fn[Utils.sIsAsync] ? fn : function () {
                        try {
                            return Utils.Task.wait(fn.apply(this, arguments), mode);
                        }
                        catch (err) {
                            return new Utils.Task().reject(err).promise;
                        }
                    };
                    setHiddenProperty(fna, Utils.sIsAsync, true);
                    return fna;
                }
                else if (typeof fn === 'object' && typeof md === 'object') {
                    // async(proto, name, desc) was invoked as a decorator
                    var amd = inherit(md);
                    // when async(...) is invoked as a decorator, the `this`
                    // value can equal to "sync" to tell the async function
                    // must resolve/reject the promise immediately if the inner
                    // function (which is md.value) returns/throws something.
                    // The `this` value can be passed via async.bind("sync")
                    // and is used in one place to define the internal _setAsync
                    // method of Property.
                    amd.value = async(md.value, this);
                    return amd;
                }
                else {
                    assert(false);
                }
            }
            Utils.async = async;
            //#endregion
            //#region hidden
            /** A decorator to make a method non-enumerable. */
            function hidden(proto, name, desc) {
                desc.enumerable = false;
            }
            Utils.hidden = hidden;
            //#endregion
            //#region nothrow
            /** A decorator to suppress all exceptions thrown by the method. */
            function nothrow(proto, name, desc) {
                var fn = desc.value;
                desc = inherit(desc);
                desc.value = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    try {
                        return fn.apply(this, args);
                    }
                    catch (err) {
                    }
                };
                return desc;
            }
            Utils.nothrow = nothrow;
            //#endregion
            //#region Symbol
            /**
             * The idea is taken from the ES6 Symbol.
             *
             * A symbol is a string-like object that can be used as a key
             * to access an object's member. Its main difference from a plain
             * string is that the object's member can be accessed only if
             * a reference to the symbol is available:
             *
             *      var myObj = {};
             *      var mySym = Symbol("a descriptive name to simplify debugging");
             *      myObj[mySym] = secret;
             *
             * To a very good extent a symbol can be simulated by a random string.
             * At runtime a symbol is just a random string with a hint in it.
             * While executing unit tests a symbol is the same string that was
             * given to its constructor.
             *
             * @blame antonkh
             */
            function Symbol(name, addRandomTag) {
                if (name === void 0) { name = random(); }
                if (addRandomTag === void 0) { addRandomTag = !Web.isUnitTested; }
                return !addRandomTag ? name : name + '_' + random();
            }
            Utils.Symbol = Symbol;
            //#endregion
            //#region inherit
            /**
             * Creates an object with the given prototype
             * and optionally extends it with a set of properties.
             * As a nice side effect the created object will be
             * displayed in a debugger with the right type name,
             * i.e. inherit(ABC.prototype, { x: 1 }) will be displayed
             * as ABC { x: 1 }.
             */
            function inherit(proto, props, mode) {
                var descriptors = {};
                proto = proto || {};
                props = props || {};
                for (var key in props) {
                    if (!(key in proto) || mode != 'append')
                        descriptors[key] = {
                            value: props[key],
                            writable: true,
                            enumerable: true,
                            configurable: true
                        };
                }
                // not supported in IE 8, but there are already
                // many things here that don't work in IE 8
                return Object.create(proto, descriptors);
            }
            Utils.inherit = inherit;
            //#endregion
            //#region setHiddenProperty
            /**
             * It's typically used with Symbol:
             *
             *      var sName = Symbol('name');
             *      var myObj = {};
             *      setHiddenProperty(myObj, sName, 'Alice');
             *
             * In ES6 a function like this isn't needed and a simple
             * assignment does the job.
             */
            function setHiddenProperty(obj, sym, val, readOnly) {
                if (readOnly === void 0) { readOnly = false; }
                try {
                    Object.defineProperty(obj, sym, {
                        value: val,
                        configurable: true,
                        enumerable: false,
                        writable: !readOnly
                    });
                }
                catch (err) {
                    obj[sym] = val;
                }
            }
            Utils.setHiddenProperty = setHiddenProperty;
            //#endregion
            //#region extend
            /**
             * Copies properties from one object to another.
             * It overwrites existing properties.
             *
             * @example Returns {a:1, b:2}
             *
             *      extend({a:1}, {b:2});
             *
             * @example Returns {a:1, b: 3}
             *
             *      extend({a:1}, {a:2, b:3});
             *
             * @example Does nothing, because x.toString already exists.
             *
             *      var x = {};
             *      extend(x, {toString:function(){}});
             */
            function extend(res) {
                var args = []; /* ...srcs, mode = "override" */
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var src, i, name, mode = args[args.length - 1];
                res = res || {};
                mode = isString(mode) ? mode : '';
                for (i = 0; i < args.length; i++) {
                    src = args[i] || {};
                    if (src !== mode) {
                        for (name in src) {
                            if (mode != 'append' || !(name in res))
                                res[name] = src[name];
                        }
                    }
                }
                return res;
            }
            Utils.extend = extend;
            //#endregion
            /**
             * Returns a random number in the form of a hex string.
             */
            function random() {
                return Web.Math.random().toString(16).slice(2);
            }
            Utils.random = random;
            function setPrototypeOrExtend(obj, proto) {
                if (Utils.replacePrototype) {
                    if (obj.__proto__)
                        obj.__proto__ = proto;
                    else if (Object.setPrototypeOf)
                        Object.setPrototypeOf(obj, proto);
                    else
                        extend(obj, proto);
                }
                else {
                    extend(obj, proto);
                }
            }
            Utils.setPrototypeOrExtend = setPrototypeOrExtend;
            //#region Exception
            /**
             * Constructs an exception object with custom parameters.
             *
             * The constructed exception inherits from the native Error object
             * all its properties, including the captured stack trace, and adds
             * to it the "code" member and a few custom members that usually
             * include the "reason" which points to another exception object.
             *
             * To throw an exception with a code use:
             *
             *      throw Exception("InvalidArgument");
             *
             * To throw an exception with a code and a custom message use:
             *
             *      throw Exception.call("An invalid argument passed.", "InvalidArgument");
             *
             * To throw an exception with custom parameters use:
             *
             *      throw Exception("SomethingFailed", {
             *          reason: err,
             *          tag: 123
             *      });
             *
             * @param {String} code - An error code, e.g. "InvalidArgument"
             * @param {Object} [params] - An optional set of values associated with the error.
             *
             * @returns {Error}
             */
            function Exception(code, params) {
                params = extend({ code: code }, params);
                // this === window in IE9 which doesn't support the strict mode
                // this === Utils after tsc resolves Exception to Utils.Exception
                // this === "" in some special case in IE
                return extend(Error(this === Web.window || this === Utils || !this || this == '' ? code : this), params);
            }
            Utils.Exception = Exception;
            //#endregion
            //#region Common Exceptions
            function EWrongType(value, type) {
                var text = value + ' is not a ' + type;
                return Exception.call(text, 'WrongType', { value: value });
            }
            Utils.EWrongType = EWrongType;
            function EWrongArgType(name, value, type) {
                var text = '`' + name + '` = ' + value + ' is not a ' + type;
                return Exception.call(text, 'WrongArgType', { arg: name, value: value });
            }
            Utils.EWrongArgType = EWrongArgType;
            function EDoesNotEqual(lhs, rhs) {
                var text = lhs + ' != ' + rhs;
                return Exception.call(text, 'DoesNotEqual', { lhs: lhs, rhs: rhs });
            }
            Utils.EDoesNotEqual = EDoesNotEqual;
            function EInvalidArgument(name, reason) {
                var text = '`' + name + '` is invalid: ' + reason;
                return Exception.call(text, 'InvalidArgument', { arg: name, reason: reason });
            }
            Utils.EInvalidArgument = EInvalidArgument;
            function EInvalidState(state, expected) {
                var text = 'Invalid state: ' + state + ' (expected ' + expected + ')';
                return Exception.call(text, 'InvalidState', { actual: state, expected: expected });
            }
            Utils.EInvalidState = EInvalidState;
            function EKeyMissing(key, obj) {
                var text = 'the `' + key + '` property is missing';
                return Exception.call(text, 'KeyMissing', { key: key, object: obj });
            }
            Utils.EKeyMissing = EKeyMissing;
            function EAlreadyExists(item) {
                return Exception('AlreadyExists', { item: item });
            }
            Utils.EAlreadyExists = EAlreadyExists;
            function EDoesNotExist(item) {
                return Exception('DoesNotExist', { item: item });
            }
            Utils.EDoesNotExist = EDoesNotExist;
            function ENotSupported(reason) {
                return Exception('NotSupported', { reason: reason });
            }
            Utils.ENotSupported = ENotSupported;
            function ECanceled(reason) {
                return Exception('Canceled', { reason: reason });
            }
            Utils.ECanceled = ECanceled;
            //#endregion
            //#region defer
            /**
             * defer(fn, args...) invokes fn(args...) at the next event loop cycle
             * if the code is run in a browser during runtime, or invokes fn(args...)
             * right away if the code is invoked by a unit test.
             *
             * A more efficient way to do so is to use `postMessage` which may not be
             * supported on all browsers that SkypeWeb supports.
             */
            function defer(callback) {
                var _this = this;
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (Web.isUnitTested)
                    callback.apply(this, args);
                else
                    Web.setTimeout(function () { return callback.apply(_this, args); }, 0);
            }
            Utils.defer = defer;
            //#endregion
            //#region assert
            function assert(condition, message, params) {
                if (!condition) {
                    if (!Web.isUnitTested && Web.Settings.dbgBreak) {
                        /** So something went wrong and you are here. Try to reproduce the problem and record a trace:
                             
                            1. Add #ttt to the URL and reload the page.
        
                            If the original URL looked like https://contoso.com/customers?sort=descending
                            then the modified URL should look like https://contoso.com/customers?sort=descending#ttt
                            The #ttt tag in the URL will tell the SDK that it needs to start in the recording mode.
                            
                            2. Repeat whatever steps lead to this failure.
                        
                            Once this place is reached again, save the trace by either invoking ttt.save()
                            in the dev console or [TBD]. This should prompt you to download 3 files. Zip them
                            together and attach to a bug report. Note, that the trace will contain *all* the
                            data that has been seen by the SDK: all text messages sent by the SDK, the contact
                            list, the conversation history if it has been pulled by the SDK and so on. The trace
                            will not contain data outside the SDK boundary, i.e. it won't contain cookies, contents
                            of the page outside the SDK and so on. If possible, it's better to use a test account. */
                        debugger;
                    }
                    throw Exception(message || 'AssertionFailed', params);
                }
            }
            Utils.assert = assert;
            //#endregion
            //#region check    
            function check(condition, message, params) {
                if (!condition)
                    throw Exception(message || 'RuntimeCheckFailed', params);
            }
            Utils.check = check;
            var check;
            (function (check) {
                function equals(a, b) {
                    if (a != b)
                        throw EDoesNotEqual(a, b);
                }
                check.equals = equals;
                function state(actual, expected) {
                    if (isArray(expected)) {
                        if (indexOf(expected, actual) == -1)
                            throw EInvalidState(actual, expected);
                    }
                    else if (actual != expected)
                        throw EInvalidState(actual, expected);
                }
                check.state = state;
                function belongs(key, object) {
                    if (!(key in object))
                        throw EKeyMissing(key, object);
                }
                check.belongs = belongs;
            })(check = Utils.check || (Utils.check = {}));
            /**
             * This is a polyfill for Array#indexOf that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not extend prototypes of the global constructors such as Array.
             */
            function indexOf(a, v) {
                var i;
                if (a.indexOf) {
                    return a.indexOf(v);
                }
                else {
                    for (i = 0; i < a.length; i++) {
                        // an expression comparing objects is only true
                        // if the operands reference the same object
                        if (a[i] == v)
                            return i;
                    }
                    return -1;
                }
            }
            Utils.indexOf = indexOf;
            //#endregion
            //#region is
            function isPromise(x) {
                return x instanceof Utils.Promise;
            }
            Utils.isPromise = isPromise;
            function isCollection(x) {
                return x && x.constructor === Utils.Collection;
            }
            Utils.isCollection = isCollection;
            function isModel(x) {
                return x instanceof Utils.Model;
            }
            Utils.isModel = isModel;
            function isProperty(x) {
                // it's debatable whether a property is a collection;
                // currently a collection looks almost exactly as a
                // property object: it has .get, .changed, .call and other
                // features, but doesn't have .set (but should) and
                // .then (also should)
                return x && x.constructor === Utils.Property;
            }
            Utils.isProperty = isProperty;
            function isCommand(x) {
                return x && x.constructor === Utils.Command;
            }
            Utils.isCommand = isCommand;
            function isObject(x) {
                // IE8 thinks that {}.toString(undefined) == '[object Object]'
                return x && Object.prototype.toString.call(x) == '[object Object]';
            }
            Utils.isObject = isObject;
            function isDictionary(x) {
                return isObject(x);
            }
            Utils.isDictionary = isDictionary;
            function isArray(x) {
                return Object.prototype.toString.call(x) == '[object Array]';
            }
            Utils.isArray = isArray;
            function isArrayOf(a, is) {
                if (!isArray(a))
                    return false;
                for (var i = 0; i < a.length; i++)
                    if (!is(a[i]))
                        return false;
                return true;
            }
            Utils.isArrayOf = isArrayOf;
            function isString(x) {
                return Object.prototype.toString.call(x) == '[object String]';
            }
            Utils.isString = isString;
            function isNumber(x) {
                return Object.prototype.toString.call(x) == '[object Number]';
            }
            Utils.isNumber = isNumber;
            function isFunction(x) {
                return Object.prototype.toString.call(x) == '[object Function]';
            }
            Utils.isFunction = isFunction;
            function isBoolean(x) {
                return Object.prototype.toString.call(x) == '[object Boolean]';
            }
            Utils.isBoolean = isBoolean;
            function isNotEmptyString(x) {
                return isString(x) && x.length > 0;
            }
            Utils.isNotEmptyString = isNotEmptyString;
            function isVoid(x) {
                return x === null || x === undefined;
            }
            Utils.isVoid = isVoid;
            function isInteger(x) {
                return isNumber(x) && (x | 0) == x;
            }
            Utils.isInteger = isInteger;
            function isArrayIndex(x, a) {
                return isInteger(x) && isArray(a) && x >= 0 && x < a.length;
            }
            Utils.isArrayIndex = isArrayIndex;
            function isInRange(min, max, x) {
                return isNumber(x) && x >= min && x <= max;
            }
            Utils.isInRange = isInRange;
            function isAjaxRequest(r) {
                return isObject(r) && isNotEmptyString(r.type) && isNotEmptyString(r.url);
            }
            Utils.isAjaxRequest = isAjaxRequest;
            function isAjaxResponse(r) {
                return isDictionary(r) && ('status' in r);
            }
            Utils.isAjaxResponse = isAjaxResponse;
            function isEmptyObject(x) {
                for (var prop in x)
                    if (x.hasOwnProperty(prop))
                        return false;
                return true;
            }
            Utils.isEmptyObject = isEmptyObject;
            function isException(x) {
                return x && x instanceof Error && x.code;
            }
            Utils.isException = isException;
            function is(item, type) {
                var i, types = type.split('|');
                for (i = 0; i < types.length; i++)
                    if (types[i] in is.types && is.types[types[i]](item))
                        return true;
                return false;
            }
            Utils.is = is;
            function isThenable(obj) {
                // take into account promises that may be created
                // by other Promises/A+ compliant libraries, such
                // as Q - this function must recognize them as well
                return obj && isFunction(obj.then);
            }
            Utils.isThenable = isThenable;
            var is;
            (function (is) {
                is.types = {
                    String: isString,
                    NotEmptyString: isNotEmptyString,
                    Function: isFunction,
                    Dictionary: isDictionary,
                    Object: isObject,
                    Array: isArray,
                    Boolean: isBoolean,
                    Void: isVoid,
                    Number: isNumber,
                    Exception: isException
                };
            })(is = Utils.is || (Utils.is = {}));
            //#endregion
            //#region bind
            /**
             * This is a polyfill for Function#bind that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not extend prototypes of the global constructors such as Function.
             */
            function bind(fn) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var that = this;
                // use the native Function#bind if it's available
                return fn.bind ? fn.bind.apply(fn, [that].concat(args)) : function () {
                    return fn.apply(that, args.concat([].slice.call(arguments, 0)));
                };
            }
            Utils.bind = bind;
            //#endregion
            function removeAt(array, index) {
                array.splice(index, 1);
            }
            Utils.removeAt = removeAt;
            function insertAt(array, index, value) {
                array.splice(index, 0, value);
            }
            Utils.insertAt = insertAt;
            /**
             * Invokes a callback for each element in the array
             * or in the object.
             *
             * @example It prints 0->11 1->22 2->33
             *
             *      foreach([11, 22, 33], function (value, index) {
             *          console.log(index + "->" + value);
             *      });
             *
             * @example It prints a->1 b->2 c->3
             *
             *      foreach({a:1, b:2, c:3}, function (value, key) {
             *          console.log(key + "->" + value);
             *      });
             */
            function foreach(items, callback) {
                var retVal, i, key;
                if (isArray(items)) {
                    for (i = 0; i < items.length; ++i)
                        callback(items[i], i);
                }
                else {
                    for (key in items) {
                        retVal = callback(items[key], key);
                        assert(retVal === void 0);
                    }
                }
            }
            Utils.foreach = foreach;
            /**
             * This is an implementation of Array::map compatible with ECMAScript 5.
             *
             * @param {Array|Object} array
             * @param context
             * @param {Function} callback(value, index, array)
             *
             *      A function that takes the name and value of a source object
             *      property, and returns the result of a certain operation on that value.
             */
            function map(array, callback, context) {
                var mapped, i;
                if (isArray(array)) {
                    mapped = [];
                    for (i = 0; i < array.length; i++)
                        mapped.push(callback.call(context, array[i], i, array));
                }
                else if (isDictionary(array)) {
                    mapped = {};
                    for (i in array)
                        mapped[i] = callback.call(context, array[i], i, array);
                }
                return mapped;
            }
            Utils.map = map;
            //#endregion
            //#region values
            /**
             * Given a dictionary returns an array of dictionary values.
             */
            function values(items) {
                assert(isDictionary(items));
                var vals = [];
                foreach(items, function (value) {
                    vals.push(value);
                });
                return vals;
            }
            Utils.values = values;
            /**
             * Determines whether a collection (array or dictionary) contains an element
             * that satisfies a given condition
             */
            function contains(items, callback) {
                assert(isArray(items) || isDictionary(items));
                assert(isFunction(callback));
                var i;
                if (isArray(items)) {
                    for (i = 0; i < items.length; ++i) {
                        if (callback(items[i], i))
                            return true;
                    }
                }
                else {
                    for (i in items) {
                        if (callback(items[i], i))
                            return true;
                    }
                }
                return false;
            }
            Utils.contains = contains;
            //#endregion
            //#region deepEqual
            /**
             * Deep comparison of two objects.
             *
             * This function considers two objects as equal if they contain the
             * same list of primitive properties (object properties are compared
             * using strict comparison).
             *
             * This function may be improved in the future when there is a need
             * to compare properties at deeper levels.
             *
             * @created yodu, Jan 2014
             */
            function deepEqual(obj1, obj2) {
                var prop, t1 = typeof obj1, t2 = typeof obj2;
                // strict comparison (this will cover primitive types, including
                // undefined and null)
                if (obj1 === obj2)
                    return true;
                // both have to be object or function before continue
                if (t1 !== t2 || t1 !== 'object' && t1 !== 'function')
                    return false;
                if (obj1 === null || obj2 === null)
                    return obj1 === obj2;
                if (obj1 instanceof Web.Date && obj2 instanceof Web.Date)
                    return +obj1 == +obj2;
                // each property in obj1 must exist in obj2
                for (prop in obj1) {
                    if (!(prop in obj2) || obj1[prop] !== obj2[prop])
                        return false;
                }
                // each property in obj2 must exist in obj1
                for (prop in obj2) {
                    if (!(prop in obj1) || obj1[prop] !== obj2[prop])
                        return false;
                }
                return true;
            }
            Utils.deepEqual = deepEqual;
            function removeItem(array, predicate) {
                for (var i = 0; i < array.length; i++) {
                    if (predicate(array[i])) {
                        removeAt(array, i);
                        return i;
                    }
                }
            }
            Utils.removeItem = removeItem;
            //#endregion
            //#region insertItem
            /** Inserts an item into a sorted array:
                var index = insertItem(array, (x, y) => x < y); */
            function insertItem(items, item, order) {
                var i = 0, n = items.length;
                while (i < n && !order(item, items[i]))
                    i++;
                insertAt(items, i, item);
                return i;
            }
            Utils.insertItem = insertItem;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var isException = Utils.isException;
            var ECanceled = Utils.ECanceled;
            var sTask = Utils.Symbol('task');
            var sError = Utils.Symbol('error');
            var sResult = Utils.Symbol('result');
            function wrap(x) {
                if (Utils.isPromise(x))
                    return x;
                // note, that .then can be read only once, according to the spec
                var then = x !== true && x !== false && x !== null && x !== undefined
                    && typeof x !== 'number' && typeof x !== 'string' && x.then;
                // .then may be an object inheriting from Function.prototype
                if (typeof then === 'function')
                    return new Promise(Utils.bind.call(x, then));
            }
            /**
             * An instance of Task represents an asynchronously returned value
             * or an asynchronously thrown exception. Task corresponds to C#'s Task.
             *
             * A task can be resolved or rejected. Resolving a task means returning a value
             * asynchronously; rejecting it - throwing an exception asynchronously.
             *
             * A task is a promise to eventually return the result of an asynchronous operation.
             * If the operation succeeds the function resolves the task supplying the operation result.
             * If the operation fails the function rejects the task providing the failure reason (exception).
             *
             * There is an interesting limitation on the the implementation of Task:
             * it cannot invoke Property::set because this method creates a resolved
             * promise that invokes Property::set that creates a resolved promise...
             * However Task can invoke Property::call because it does not
             * create a promise and returns whatever was in `this` reference.
             *
             * @created Sep 2013
             * @blame antonkh
             */
            var Task = (function () {
                function Task(initialStatus, options) {
                    var _this = this;
                    if (!(this instanceof Task))
                        return new Task(initialStatus, options);
                    if (!Utils.isString(initialStatus)) {
                        options = initialStatus;
                        initialStatus = void 0;
                    }
                    var args = options || {};
                    this._ = {
                        leafs: [],
                        state: 'pending',
                        status: Utils.Property({ value: initialStatus }),
                        promise: Utils.inherit(Promise.prototype)
                    };
                    var _ = this._;
                    if (args.mode)
                        _.mode = args.mode;
                    if (args.cancel)
                        _.fnCancel = args.cancel;
                    Utils.setHiddenProperty(_.promise, sTask, this);
                    this.state = function () { return _.state; };
                    this.status = _.status;
                    this.promise = _.promise;
                    this.status.changed(function () { return _this.notify(); });
                }
                Task.prototype.resolve = function (result) {
                    var self = this, _ = self._;
                    if (_.state != 'pending')
                        return self;
                    _.value = result;
                    _.state = 'resolved';
                    Utils.setHiddenProperty(_.promise, sResult, result);
                    return self._complete();
                };
                Task.prototype.reject = function (error) {
                    var self = this, _ = self._;
                    if (_.state != 'pending')
                        return self;
                    _.value = error;
                    _.state = 'rejected';
                    Utils.setHiddenProperty(_.promise, sError, error);
                    return self._complete();
                };
                /**
                 * Redirects result or error from a promise to this task.
                 * It's pretty much the same as the following call to .then(...):
                 *
                 *      source.then(
                 *          r => { task.resolve(r); return r; },
                 *          e => { task.reject(e); throw e; });
                 *
                 * The only difference is special extra logic to properly remove
                 * dangling promise objects and chain cancellation.
                 */
                Task.prototype.from = function (source) {
                    var task = this, _ = task._;
                    if (_.promise[Task.sLocked])
                        return _.target.from(source);
                    _.source = source;
                    var p = _.source.then(function (res) { task.resolve(res); return res; }, function (err) { task.reject(err); throw err; }, _.status);
                    _.fnCancel = function (reason) { return _.source.cancel(reason); };
                    if (_.source[Task.sLocked])
                        _.source[sTask]._.target = task;
                    return p;
                };
                Task.prototype._complete = function () {
                    var self = this, _ = self._;
                    _.status(null);
                    for (var _i = 0, _a = _.leafs; _i < _a.length; _i++) {
                        var leaf = _a[_i];
                        this.exec(leaf);
                    }
                    _.fnCancel = null; // it holds a ref to the parent task
                    return self;
                };
                /**
                 * Once this task is completed, this method is invoked to
                 * complete tasks attached with .then(...): it invokes the
                 * associated done/fail handlers and then resolves/rejects
                 * the attached task.
                 */
                Task.prototype.exec = function (leaf, mode) {
                    var _ = this._;
                    // as required by spec, .then(...) is async by default
                    if (_.mode != 'sync' && mode != 'sync') {
                        Utils.defer.call(this, this.exec, leaf, 'sync');
                        return;
                    }
                    this.exec2(leaf, _.state, _.value);
                };
                Task.prototype.exec2 = function (leaf, state, value) {
                    var _this = this;
                    if (state == 'resolved')
                        try {
                            var p = wrap(value);
                            if (p) {
                                p.then(function (r) { return _this.exec2(leaf, 'resolved', r); }, function (e) { return _this.exec2(leaf, 'rejected', e); });
                                return;
                            }
                        }
                        catch (e) {
                            state = 'rejected';
                            value = e;
                        }
                    var done = leaf.done, fail = leaf.fail, task = leaf.task;
                    var result;
                    try {
                        if (state == 'resolved')
                            result = Utils.isFunction(done) ? done(value) : value;
                        else if (Utils.isFunction(fail))
                            result = fail(value);
                        else
                            throw value;
                    }
                    catch (error) {
                        task.reject(error);
                        return;
                    }
                    if (result === task.promise)
                        task.reject(new TypeError);
                    else
                        try {
                            var promise = wrap(result);
                            if (promise)
                                task.from(promise);
                            else
                                task.resolve(result);
                        }
                        catch (e) {
                            task.reject(e);
                        }
                };
                /** Propagates the status of this task to tasks attached with .then(...). */
                Task.prototype.notify = function () {
                    var _ = this._;
                    if (_.state != 'pending')
                        return;
                    var status = this.status();
                    var reason = this.status.reason;
                    if (status === undefined && reason === undefined)
                        return;
                    for (var _i = 0, _a = _.leafs; _i < _a.length; _i++) {
                        var _b = _a[_i], task = _b.task, info = _b.info;
                        task.status(status, reason);
                        if (Utils.isFunction(info))
                            info(status, reason);
                    }
                };
                /**
                 * If a task created by .then(...) is cancelled, it's detached
                 * from this task. If the last attached task is cancelled, this
                 * task is cancelled as well.
                 */
                Task.prototype.detach = function (leaf, reason) {
                    var _ = this._;
                    var task = leaf.task, fail = leaf.fail;
                    if (_.leafs.length < 2) {
                        _.promise.cancel(reason);
                    }
                    else {
                        Utils.removeAt(_.leafs, Utils.indexOf(_.leafs, leaf));
                        try {
                            if (Utils.isFunction(fail))
                                task.from(Task.wait(fail(reason)));
                            else
                                task.reject(reason);
                        }
                        catch (error) {
                            task.reject(error);
                        }
                    }
                };
                // see the explanation given in the comment for the repeat(...) function
                Task.sLocked = Utils.Symbol('locked');
                return Task;
            })();
            Utils.Task = Task;
            /**
             * This is the proposed in ES7 interface of a Promise to the Task class.
             * This interface is more convenient to use when constructing promise
             * objects inline. An example of use:
             *
             *      Promise((resolve, reject, notify) => {
             *          notify("waiting for 1.5 seconds");
             *          setTimeout(resolve, 1500); // resolve the promise after 1.5 seconds
             *      }).then(() => {
             *          ...
             *      });
             *
             * This way of constructing promise object doesn't allow to specify
             * the cancellation procedure or to report progress.
             */
            var Promise = (function () {
                function Promise(then) {
                    if (!(this instanceof Promise))
                        return new Promise(then);
                    var task = new Task();
                    try {
                        then(function (res) { return task.resolve(res); }, function (err) { return task.reject(err); }, task.status);
                    }
                    catch (err) {
                        // `then` may throw an exception after
                        // resolving or rejecting the promise
                        try {
                            task.reject(err);
                        }
                        catch (_) {
                        }
                    }
                    return task.promise;
                }
                /**
                 * Cancels the task.
                 *
                 * Every complex async operation, such as "sign in" consists of
                 * several stages where every stage is represented by a Task instance.
                 * For example such stages can be "awaiting xframe", "awaiting GET /me",
                 * or "waiting in the throttling queue": all these stages are
                 * essentially instances of Task that get resolved by their owners
                 * in due course.
                 *
                 * Owners of these tasks may specify a custom callback that knows
                 * how to cancel this particular task. For instance, in case of
                 * "awaiting xframe" task the cancellation routine would cancel
                 * the timer and possibly remove the xframe from the DOM tree;
                 * in case of "waiting in the throttling queue" the cancellation
                 * routine would remove the request from the queue.
                 *
                 * A task may have multiple branches (called "promises") and each branch
                 * has the "cancel" method that attempts to find the current task
                 * and invoke its cancel method. If the current task was given the
                 * cancellation routine, the Task::cancel would succeed and reject the
                 * current task (which results in invoking the "fail" handler of attached
                 * branches and those handlers may initiate other async operations).
                 * If the current task was not given the cancellation routine (because
                 * the owner of this operation was too lazy to implement it), Task::cancel
                 * would just reject the task.
                 *
                 * @exception [InvalidState] cancel(reason?) may throw exception if the
                 *     state of the current task or any up-stream tasks is not pending. For
                 *     example:
                 *
                 *     var t1 = new Task(); // create a task t1
                 *     var p1 = t1.promise;
                 *     var p2 = p1.then(fnSuccess1, fnFailure); // create a sourced task from p1.
                 *     var p3 = p2.then(fnSuccess2, fnFailure2); // create another sourced task from p2.
                 *
                 *     t1.resolve('Task1 is completed'); // p1.state() is 'resolved', but has not propagated to p2 and p3
                 *     try {
                 *         p3.cancel('cancelling task 3'); // cancelling p3
                 *     } catch (err) {
                 *         console.log(err); // got InvalidState exception, since p1.state() is 'resolved'
                 *     }
                 *
                 */
                Promise.prototype.cancel = function (reason) {
                    var task = this[sTask], _ = task._;
                    Utils.check.state(_.state, 'pending');
                    var err = isException(reason) && reason.code == 'Canceled' ? reason : ECanceled(reason);
                    if (_.fnCancel)
                        _.fnCancel(err);
                    else
                        task.reject(err);
                };
                Promise.prototype.then = function (fnDone, fnFail, fnInfo) {
                    var root = this[sTask];
                    var task = new Task({
                        cancel: function (reason) { return root.detach(leaf, reason); }
                    });
                    var leaf = {
                        task: task,
                        done: fnDone,
                        fail: fnFail,
                        info: fnInfo
                    };
                    if (root.state() == 'pending') {
                        root._.leafs.push(leaf);
                        root.notify();
                    }
                    else {
                        root.exec(leaf);
                    }
                    return task.promise;
                };
                /**
                 * Sets an error handler for an async operation.
                 *
                 * A call to .catch corresponds to wrapping an "await" into a try..catch.
                 * .catch is typically used as the very last handler of a complete async
                 * flow to handle all possible errors:
                 *
                 *     ucwa.send("GET", ".../me").catch(error => {
                 *         console.log(error);
                 *     });
                 *
                 * With the "await" keyword this code snippet can be rewritten as:
                 *
                 *     try {
                 *         await ucwa.send("GET", ".../me");
                 *     } catch (error) {
                 *         console.log(error);
                 *     }
                 *
                 * Note, that if the error handler returns a value, it essentially
                 * handles the error and the new promise returned by .catch is resolved;
                 * if it throws na exception, that promise gets rejected.
                 */
                Promise.prototype.catch = function (handler) {
                    return this.then(null, handler || Utils.noop);
                };
                /**
                 * An async version of try..finally.
                 *
                 * This method is a part of the Promise interface proposed in ES7.
                 * The intent is to simulate the try..finally construct for promises:
                 * a handler attached via .finally gets invoked no matter whether the
                 * promise has been resolved or rejected and the handler cannot read or
                 * alter the result. However if the handler fails, the thrown exception
                 * gets propagated.
                 *
                 *     ucwa.send("GET", ".../me").finally(() => {
                 *         console.log("GET has succeeded or failed");
                 *     });
                 *
                 * With the "await" keyword this code snippet can be rewritten as:
                 *
                 *     try {
                 *         await ucwa.send("GET", ".../me");
                 *     } finally {
                 *         console.log("GET has succeeded or failed");
                 *     }
                 *
                 * Typically .finally is used to add a final handler that will do some
                 * cleanup after the async operation completes.
                 */
                Promise.prototype.finally = function (handler) {
                    return this.then(function (res) { return Promise.resolve(handler()).then(function () { return res; }); }, function (err) { return Promise.resolve(handler()).then(function () { throw err; }); });
                };
                return Promise;
            })();
            Utils.Promise = Promise;
            var Task;
            (function (Task) {
                //#region Task.waitAny        
                /**
                 * Awaits the given tasks and stops waiting after the any of them resolves,
                 * then it cancels all pending tasks. For example, waiting for any of a few
                 * requests to succeed (or all of them to fail) can be done like this:
                 *
                 *      Task.waitAny([
                 *          ucwa.send("GET", "/me/name"),
                 *          ucwa.send("POST", "/me/makeAvailable", { data : { ... } })
                 *      ]);
                 *
                 * If JS allowed to overload operators, then this function could be replaced
                 * with the overloaded | operator for the Promise class.
                 *
                 * @created antonkh, Dec 2013
                 */
                function waitAny(promises) {
                    var nPending = promises.length;
                    var task = new Task({ cancel: cancel });
                    var promise = task.promise;
                    var statuses = [];
                    if (nPending == 1)
                        promise = Task.wait(promises[0]);
                    else if (nPending == 0)
                        task.reject(Error());
                    else {
                        Utils.foreach(promises, function (p, i) {
                            p.then(// p may already be completed
                            function (// p may already be completed
                                res) {
                                nPending--;
                                if (task) {
                                    task.resolve(res);
                                    task = null;
                                    // cancel all other tasks: they are not needed anymore
                                    cancel(Utils.Exception('CompetingTaskResolved'));
                                }
                            }, function (err) {
                                nPending--;
                                if (!nPending) {
                                    // all tasks has failed
                                    task.reject(err);
                                    task = null;
                                }
                            }, function (status) {
                                if (!task)
                                    return;
                                statuses[i] = status || '#' + i;
                                task.status(statuses.join(' || '));
                            });
                        });
                    }
                    function cancel(reason) {
                        for (var _i = 0; _i < promises.length; _i++) {
                            var p = promises[_i];
                            try {
                                // this will cause the task returned by Task.waitAny to fail
                                p.cancel(reason);
                            }
                            catch (err) {
                            }
                        }
                    }
                    return promise;
                }
                Task.waitAny = waitAny;
                /**
                 * Creates a promise that gets resolved after all the given
                 * promises succeed and get rejected after any of the given
                 * promises fail.
                 *
                 * If JS allowed to overload operators, then this function could be replaced
                 * with the overloaded & operator for the Promise class.
                 *
                 * @created antonkh, 2013
                 */
                function waitAll(promises) {
                    var nPending = promises.length;
                    var task = new Task({ cancel: cancel });
                    var promise = task.promise;
                    if (nPending == 0) {
                        task.resolve([]);
                    }
                    else if (nPending == 1) {
                        promise = Task.wait(promises[0]).then(function (r) { return [r]; });
                    }
                    else {
                        var inLoop = true;
                        var unresolved = promises.map(wait);
                        var results = promises.map(function (p) { return null; });
                        var statuses = [];
                        var refresh = function () { return !inLoop && task && task.status(statuses.filter(function (_, i) { return !!unresolved[i]; }).join(' && ')); };
                        promises = promises.map(wait);
                        Utils.foreach(promises, function (promise, i) {
                            promise.then(function (result) {
                                results[i] = result;
                                unresolved[i] = null;
                                refresh();
                                nPending--;
                                if (!nPending) {
                                    task.resolve(results);
                                    task = null;
                                }
                            }, function (error) {
                                unresolved[i] = null;
                                nPending--;
                                if (task) {
                                    task.reject(error);
                                    task = null;
                                    cancel(error);
                                }
                            }, function (status) {
                                statuses[i] = status || '#' + i;
                                refresh();
                            });
                        });
                        inLoop = false;
                        refresh();
                    }
                    function cancel(reason) {
                        for (var _i = 0; _i < promises.length; _i++) {
                            var p = promises[_i];
                            try {
                                p.cancel(reason);
                            }
                            catch (error) {
                            }
                        }
                    }
                    return promise;
                }
                Task.waitAll = waitAll;
                function wait(obj, mode) {
                    try {
                        return wrap(obj) || new Task({ mode: mode }).resolve(obj).promise;
                    }
                    catch (err) {
                        return Promise.reject(err);
                    }
                }
                Task.wait = wait;
                //#endregion
                //#region run
                /**
                 * Invokes an async function.
                 * Same as Task.wait(null, 'sync').then(fn) but faster.
                 */
                function run(fn) {
                    try {
                        return Task.wait(fn(), 'sync');
                    }
                    catch (err) {
                        return new Task().reject(err).promise;
                    }
                }
                Task.run = run;
            })(Task = Utils.Task || (Utils.Task = {}));
            var Promise;
            (function (Promise) {
                Promise.all = Task.waitAll;
                Promise.race = Task.waitAny;
                Promise.reject = function (err) { return new Task().reject(err).promise; };
                Promise.resolve = Task.wait;
            })(Promise = Utils.Promise || (Utils.Promise = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            if (typeof exports == 'object') {
                // see github.com/promises-aplus/promises-tests#adapters
                exports.deferred = Utils.Task;
                exports.resolved = Utils.Promise.resolve;
                exports.rejected = Utils.Promise.reject;
            }
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * It's a function that can be enabled or disabled.
             *
             * The point of commands is to bind them to certain UI elements and disable/enable
             * these elements according to state of their commands. For instance, UI may implement
             * the drag-and-drop way of adding contacts to a group: if the group model's command
             * that adds contacts is enabled, UI allows to drop a contact UI element to the group element.
             *
             * In the most general case, however, a command is callable object that contains all
             * the information needed to invoke a certain function with certain arguments. In addition
             * to that a command can be observed and it can tell whether it can be invoked with certain
             * arguments. To address that we may later extend the command class with the `bind` method:
             *
             *      var cmdSendMessage = messaging.send; // generic command
             *      var cmdSendGreeting = cmdSendMessage.bind(null, "Hello"); // specific command
             *
             *      cmdSendMessage.enabled(); // tells whether a message can be sent in general
             *      cmdSendGreeting.enabled(); // tells whether that particular message can be sent
             *
             * Thus to check whether it's ok to invoke a command with certain arguments a caller
             * may use the `bind` method and the `enabled` property:
             *
             *      if (messaging.send.bind(null, "Hello").enabled())
             *          console.log("This message can be sent.");
             *
             * The first `null` argument is needed to make `bind` be a superset of the existing Function::bind.
             * This `bind` method can be used to create UI elements that do very specific actions. For instance
             * here is how the `mute` and `unmute` buttons can be creates:
             *
             *      var btnMute = Button(audio.muted.set.bind(null, true));
             *      var btnUnmute = Button(audio.muted.set.bind(null, false));
             *
             * The first button executes audio.muted.set(true) and the second executes audio.muted.set(false).
             * Note, that the two buttons subscribe to the `enabled` property and make themselves grayed out
             * when the command cannot be executed. It's also noteworthy that one button can be enabled and
             * the other can be disabled at the same time: the two commands don't have to have the same state
             * as the underlying audio.muted.set command.
             *
             * @created Jun 2014
             * @blame antonkh
             */
            function Command(invoke, enabled) {
                var pm_command = function () {
                    var enabled = pm_command.enabled;
                    if (enabled())
                        return invoke.apply(this, arguments);
                    var err = Utils.Exception('CommandDisabled', { reason: enabled.reason });
                    if (Utils.isAsyncFunction(invoke))
                        return new Utils.Task().reject(err).promise;
                    else
                        throw err;
                };
                function stringify() {
                    // make it easier to inspect commands in the dev console
                    return '[Command: enabled = ' + pm_command.enabled() + ']';
                }
                // binding of the `enabled` property via canInvoke for instance
                // is more complicated than it seems because sometimes a command
                // needs to be wrapped into another command (ttt, etc.)
                function bindContext(that) {
                    return Command(function () {
                        return pm_command.apply(that, arguments);
                    }, pm_command.enabled);
                }
                if (invoke && invoke[Utils.sIsAsync])
                    Utils.setHiddenProperty(pm_command, Utils.sIsAsync, true);
                return Utils.extend(pm_command, {
                    constructor: Command,
                    // it's absent when the first const true and false properties are constructed
                    enabled: enabled && enabled.asReadOnly(),
                    bind: bindContext,
                    toString: stringify
                });
            }
            Utils.Command = Command;
            function AsyncCommand(fn, enabled) {
                return Command(Utils.async(fn), enabled);
            }
            Utils.AsyncCommand = AsyncCommand;
            /**
             * A command that is always enabled.
             *
             * Instead of creating a full blown command with the Command
             * constructor, it creates a function that looks like a command.
             * This considerably improves performance because Property creates
             * always enabled commands.
             */
            function EnabledCommand(fn) {
                return Utils.extend(fn, {
                    constructor: Command,
                    toString: function () { return '[Command: enabled = true]'; },
                    enabled: Utils.ConstProperty(true)
                });
            }
            Utils.EnabledCommand = EnabledCommand;
            function EnabledAsyncCommand(fn) {
                return EnabledCommand(Utils.async(fn || (function () { return null; })));
            }
            Utils.EnabledAsyncCommand = EnabledAsyncCommand;
            var EnabledCommand;
            (function (EnabledCommand) {
                EnabledCommand.async = EnabledAsyncCommand;
            })(EnabledCommand = Utils.EnabledCommand || (Utils.EnabledCommand = {}));
            /**
             * A permanently disabled command.
             *
             * Multiple calls to DisabledCommand without arguments return the very
             * same instance of a command. This considerably improves performance
             * because every property object has a disabled .set command.
             */
            function DisabledCommand(reason) {
                if (reason !== void 0)
                    return Command(Utils.noop, Utils.ConstProperty(false, reason));
                if (!DisabledCommand.instance)
                    DisabledCommand.instance = Command(Utils.noop, Utils.ConstProperty(false));
                return DisabledCommand.instance;
            }
            Utils.DisabledCommand = DisabledCommand;
            var DisabledCommand;
            (function (DisabledCommand) {
            })(DisabledCommand = Utils.DisabledCommand || (Utils.DisabledCommand = {}));
            /**
             * A permanently disabled async command.
             *
             * Multiple calls to DisabledAsyncCommand without arguments return the very
             * same instance of a command. This considerably improves performance
             * because every property object has a disabled .set command.
             */
            function DisabledAsyncCommand(reason) {
                if (reason !== void 0)
                    return Command(Utils.async(Utils.noop), Utils.ConstProperty(false, reason));
                if (!DisabledAsyncCommand.instance)
                    DisabledAsyncCommand.instance = Command(Utils.async(Utils.noop), Utils.ConstProperty(false));
                return DisabledAsyncCommand.instance;
            }
            Utils.DisabledAsyncCommand = DisabledAsyncCommand;
            var DisabledAsyncCommand;
            (function (DisabledAsyncCommand) {
            })(DisabledAsyncCommand = Utils.DisabledAsyncCommand || (Utils.DisabledAsyncCommand = {}));
            var Command;
            (function (Command) {
                Command.async = AsyncCommand;
                Command.enabled = EnabledCommand;
                Command.disabled = DisabledCommand;
            })(Command = Utils.Command || (Utils.Command = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Encapsulates an event and provides capabilities to trigger the event and observe it.
             *
             * An event object is essentially a list of callbacks that are executed whenever the owner
             * of the event wants so. The event object is split into the event emitter that has all
             * the access to the event and the event observer that provides limited capabilities that are
             * enough to observe the event.
             *
             * @created Jun 2014
             * @blame antonkh
             */
            var Event = (function () {
                function Event(options) {
                    if (options === void 0) { options = {}; }
                    if (!(this instanceof Event))
                        return new Event(options);
                    Utils.extend(this, options);
                    this._listeners = [];
                    this._modes = [];
                    this._locked = false;
                    this.observer = Event.Observer(this);
                }
                /** Invokes all listeners of the event. */
                Event.prototype.fire = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    var self = this;
                    if (self._enqueue(self, self._fire, arguments))
                        return;
                    self._fire.apply(self, arguments);
                    self._dequeue();
                };
                Event.prototype._invoke = function (fn, args, mode) {
                    var self = this;
                    /* istanbul ignore if */
                    if (mode == 'async' && !Web.isUnitTested) {
                        Utils.defer.call(self, self._invoke, fn, args, 'sync');
                    }
                    else {
                        try {
                            // this=null in event handlers
                            fn.apply(null, args);
                        }
                        catch (error) {
                            // if a handler throws an exception, it should not prevent other handlers
                            // from being invoked; however the thrown exception cannot be handled here,
                            // so it's just suppressed; Event._ie is a way for a unit test to specify
                            // an exception that needs to be ignored
                            Event.uncaught['_event'].fire(error);
                            /* istanbul ignore if */
                            if (error != Event._ie) {
                                // the error may be caused by a stack overflow and since a try..catch creates
                                // a new stack frame, this error handler cannot use another try..catch
                                if (console && console.log) {
                                    console.log(error && error.stack || error);
                                    console.log(Error().stack);
                                }
                                Utils.assert();
                            }
                        }
                    }
                };
                /** Tells whether the event has at least one listener. */
                Event.prototype.observed = function () {
                    return this._listeners.length > 0;
                };
                Event.prototype._fire = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    var i, self = this;
                    for (i = 0; i < self._listeners.length; i++)
                        self._invoke(self._listeners[i], arguments, self._modes[i]);
                };
                Event.prototype._enqueue = function (ctx, fn, args) {
                    var self = this;
                    if (self._locked) {
                        self._queue = self._queue || [];
                        self._queue.push([ctx, fn, args]);
                    }
                    else {
                        self._locked = true;
                    }
                    return self._queue && self._queue.length > 0;
                };
                Event.prototype._dequeue = function () {
                    var q, self = this;
                    if (self._queue) {
                        while (q = self._queue.shift())
                            q[1].apply(q[0], q[2]);
                        self._queue = null;
                    }
                    self._locked = false;
                };
                return Event;
            })();
            Utils.Event = Event;
            var Event;
            (function (Event) {
                var Subscription = (function () {
                    function Subscription(event, listener) {
                        this.event = event;
                        this.listener = listener;
                    }
                    Subscription.prototype.dispose = function () {
                        this.event.off(this.listener);
                    };
                    return Subscription;
                })();
                Event.Subscription = Subscription;
                var ObserverImpl = (function () {
                    function ObserverImpl(event) {
                        var observer = function (listener, mode) {
                            // addListener cannot return anything because it modifies
                            // the internal state of the event and thus a call to it
                            // may be delayed and executed later; however the correponding
                            // removeListener call can be executed right away as the only
                            // argument it needs is the callback function which is known
                            observer.on(listener, mode);
                            // LWX/SWX wants to execute a custom function on the target
                            // property or collection after adding an event listener to it
                            if (Utils.isFunction(mode))
                                mode(this);
                            return new Event.Subscription(observer, listener);
                        };
                        Utils.setPrototypeOrExtend(observer, Event.Observer.prototype);
                        observer._event = event;
                        return observer;
                    }
                    ObserverImpl.prototype.toString = function () {
                        var n = this._event._listeners.length;
                        return '[Event' + (n ? ': ' + n + ' listener' + (n == 1 ? '' : 's') : '') + ']';
                    };
                    /**
                     * Adds an event listener that is invoked synchronously.
                     * The second argument can be set to "async" if the listener
                     * needs to be executed asynchronously. This can be used in special cases.
                     *
                     * @param {Function} listener - A callback to be executed when the event gets fired.
                     *
                     *      To add a listener that will be invoked only once, use anonymous named
                     *      functions that have reference to themselves but aren't accessible outside:
                     *
                     *          event(function fn(message) {
                     *              event.off(fn);
                     *              console.log(message);
                     *          });
                     *
                     *      Note, that fn can be accessed only from inside fn.
                     *
                     * @param {String} [mode="sync"] - Tells how the listener should be invoked.
                     *
                     *      If an object o1 goes to state s1 and fires an event e1 to notify
                     *      about this change, then a handler h1 of this event must observe
                     *      the object in state s1. If o1 fired e1 asynchronously, then h1 could
                     *      catch e1 at the moment when o1 is no longer in state s1. However if s1
                     *      is the final state of o1, then e1 may be fired asynchronously. This is
                     *      the cases for promise objects: the resolved or the rejected states are
                     *      final for them. This is why all events are synchronous by default.
                     */
                    ObserverImpl.prototype.on = function (listener, mode) {
                        var self = this._event;
                        if (self._enqueue(this, this._addListener, [listener, mode]))
                            return;
                        this._addListener(listener, mode);
                        self._dequeue();
                    };
                    ObserverImpl.prototype._addListener = function (listener, mode) {
                        var self = this._event;
                        Utils.assert(Utils.isFunction(listener));
                        if (self.adding)
                            self.adding.call(self.context, listener);
                        self._listeners.push(listener);
                        self._modes.push(mode);
                        if (self.added)
                            self.added.call(self.context, listener);
                        if (self._listeners.length == 1 && self.subscribed)
                            self.subscribed.call(self.context);
                    };
                    ObserverImpl.prototype.off = function (listener) {
                        var self = this._event;
                        if (self._enqueue(this, this._removeListener, [listener]))
                            return;
                        this._removeListener(listener);
                        self._dequeue();
                    };
                    ObserverImpl.prototype._removeListener = function (listener) {
                        var self = this._event;
                        var i = Utils.indexOf(self._listeners, listener);
                        if (i >= 0) {
                            self._listeners.splice(i, 1);
                            self._modes.splice(i, 1);
                            if (self._listeners.length == 0 && self.unsubscribed)
                                self.unsubscribed.call(self.context);
                        }
                    };
                    return ObserverImpl;
                })();
                function Observer(event) {
                    return ObserverImpl(event);
                }
                Event.Observer = Observer;
                Observer.prototype = ObserverImpl.prototype;
                Event.uncaught = new Event().observer;
            })(Event = Utils.Event || (Utils.Event = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var Subscription = (function () {
                function Subscription(dispose) {
                    this.dispose = dispose;
                }
                return Subscription;
            })();
            Utils.Subscription = Subscription;
            /**
             * It's shared by Property::subscribe and Collection::subscribe.
             * It makes sure that the given `dispose` function is invoked only once.
             *
             * @blame antonkh
             */
            var RefCountedSubscription = (function () {
                function RefCountedSubscription(_callbacks) {
                    this._callbacks = _callbacks;
                    /** subs[i].dt <= subs[i+1].dt */
                    this._subscriptions = [];
                    /** polling interval in seconds */
                    this._period = Infinity;
                    /** periodically polls the value */
                    this._timer = null;
                }
                /**
                 * Most of the code here handles subscriptions via polling:
                 *
                 *      .subscribe() means a permanent subscription
                 *      .subscribe(3.5) means polling every 3.5 seconds
                 *
                 * Since .subscribe can be invoked multiple times, this object needs
                 * to aggregate such calls and switch between polling and permanent
                 * subscription and ir also needs to change the polling interval:
                 * it should be the min interval among all requested intervals.
                 */
                RefCountedSubscription.prototype.subscribe = function (dt) {
                    var _this = this;
                    if (dt === void 0) { dt = 0; }
                    var sub = new Subscription(function () {
                        if (!sub)
                            throw Utils.Exception('AlreadyDisposed');
                        Utils.removeItem(_this._subscriptions, function (x) { return x.sub === sub; });
                        sub = null;
                        _this._update();
                    });
                    Utils.insertItem(this._subscriptions, { sub: sub, dt: dt }, function (lhs, rhs) { return lhs.dt < rhs.dt; });
                    this._update();
                    return sub;
                };
                RefCountedSubscription.prototype._update = function () {
                    var newPeriod = this._subscriptions.length > 0 ? this._subscriptions[0].dt : Infinity;
                    var callbacks = this._callbacks;
                    if (newPeriod != this._period) {
                        if (this._timer)
                            Web.clearInterval(this._timer);
                        this._timer = null;
                        // period > 0, newPeriod = 0
                        if (newPeriod == 0 && callbacks.subscribed)
                            callbacks.subscribed();
                        // period = 0, newPeriod > 0
                        if (this._period == 0 && callbacks.unsubscribed)
                            callbacks.unsubscribed();
                        this._period = newPeriod;
                        if (this._period > 0 && this._period < Infinity && callbacks.updated)
                            this._timer = Web.setInterval(callbacks.updated, this._period * 1000 | 0);
                    }
                };
                return RefCountedSubscription;
            })();
            Utils.RefCountedSubscription = RefCountedSubscription;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="Command.ts" />
/// <reference path="Event.ts" />
/// <reference path="RefCountedSubscription.ts" />
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * An observable property.
             *
             * An owner of this property can change its value, while others get
             * a read-only version of it and can subscribe to changes of its value.
             *
             * In this example a constructor of class Person creates an observable
             * property "name" and exposes its read-only version in its interface:
             *
             *      var name = Property();
             *      name.set('John Doe');
             *
             *      return {
             *          name: name.asReadOnly()
             *      };
             *
             * The users of the Person subscribe to the property and get notified
             * when the person property is changed:
             *
             *      var person = Person(...);
             *      person.name.changed(function (name) {
             *          console.log('New name is', name);
             *      });
             *
             * So whenever the Person invokes name.set('NewName'), the new value
             * gets printed to the console log.
             *
             * This example demonstrates how the view layer binds to the model layer.
             * The model layer in turn subscribes to the stack layer via event mechanism
             * and update the model properties when it get events from the stack.
             *
             * @created Jul 2013
             * @blame sosobov
             * @blame antonkh
             */
            function Property(opts) {
                return PropertyImpl(opts);
            }
            Utils.Property = Property;
            /** If present, Property::call adds itself to this list,
                which is used to implement things like Property.observe. */
            var rdlog;
            var PropertyImpl = (function () {
                function PropertyImpl(opts) {
                    var self = pm_property;
                    var fnGet = opts && opts.get;
                    var fnSet = opts && opts.set;
                    var isReadOnly = opts && opts.readOnly;
                    if (opts && opts.value !== void 0)
                        self._value = opts.value; // undefined means no value
                    if (opts && opts.reason !== void 0)
                        self.reason = opts.reason;
                    if (opts && opts.check)
                        self._check = opts.check;
                    if (fnGet)
                        self._getter = Utils.async(fnGet);
                    if (isReadOnly)
                        self._ro = self;
                    if (fnSet)
                        self._setter = Utils.async(fnSet, 'sync');
                    if (opts && opts.subscribed)
                        self._subscribed = opts.subscribed;
                    if (opts && opts.unsubscribed)
                        self._unsubscribed = opts.unsubscribed;
                    // This trick is deeper than it might look.
                    // Read the comment for Property.prototype.
                    Utils.setPrototypeOrExtend(self, Property.prototype);
                    Utils.extend(self, {
                        get: Utils.isCommand(fnGet) ?
                            Utils.Command(self._getAsync, fnGet.enabled) :
                            Utils.EnabledCommand(self._getAsync),
                        set: isReadOnly ? Utils.DisabledAsyncCommand() :
                            Utils.isCommand(fnSet) ? Utils.Command(self._setAsync, fnSet.enabled) :
                                Utils.EnabledCommand(self._setAsync)
                    });
                    Object.defineProperty(self, 'changed', {
                        get: self._getChanged
                    });
                    // this function represents the read-write instance of the property
                    // and at the same time acts as its getter and setter
                    function pm_property(value, reason) {
                        if (arguments.length == 0) {
                            if (rdlog)
                                rdlog.push(self);
                            return self._value;
                        }
                        else {
                            self._write(value, reason);
                            return this;
                        }
                    }
                    return self;
                }
                PropertyImpl.prototype.toString = function () {
                    return '[Property: value = ' + this._value + ']';
                };
                /** Simulates overloading the || operator. */
                PropertyImpl.prototype.or = function (p) {
                    return ComputedProperty([this, p], function (a, b) { return a || b; });
                };
                /** Simulates overloading the && operator. */
                PropertyImpl.prototype.and = function (p) {
                    return ComputedProperty([this, p], function (a, b) { return a && b; });
                };
                /**
                 * Creates a new property by applying the given function to the value of this property.
                 * The created property can be observed and fetched and the requests will be properly
                 * redirected to the original property.
                 *
                 *     var p1 = Property();
                 *     var p2 = p1.map(x => Math.pow(2, x));
                 *
                 *     p1(3);
                 *     p2() == 8;
                 *
                 * The created property is read-only because it's usually not possible to "unmap"
                 * values from the created property to the original one. However if the inverse mapping
                 * function is provided, the created property becomes writable:
                 *
                 *     var p1 = Property();
                 *     var p2 = p1.map(x => Math.pow(2, x), y => Math.log(y, 2));
                 *
                 *     p2(8);
                 *     p1() == 3;
                 */
                PropertyImpl.prototype.map = function (fn, ifn) {
                    var self = this, s, p = Property({
                        get: Utils.Command(function () { return self.get().then(fn); }, self.get.enabled),
                        subscribed: function () { return s = self.subscribe(); },
                        unsubscribed: function () { return s.dispose(); }
                    });
                    self.changed(function (value, reason) {
                        p(fn(value), reason);
                    });
                    return p.fork(Utils.Command(function (value) { return self.set(ifn(value)).then(fn); }, ifn ? self.set.enabled : ConstProperty(false)));
                };
                /**
                 * Adds a listener to the given value.
                 *
                 * Specifies a callback to be invoked when the property obtains the given value:
                 *
                 *     state.when("Disconnected", function (reason, oldState) {
                 *         // handling of the Disconnected state
                 *     });
                 *
                 * If the callback needs to handle multiple values, it's possible to write a
                 * predicate function that would recognize these values:
                 *
                 *     anyOf = vs => v => vs.indexOf(v) >= 0;
                 *     state.when(anyOf("Connected", "Disconnected"), function (reason) {
                 *         // the state is either Connected or Disconnected
                 *     });
                 *
                 * To remove the event listener invoke the dispose method:
                 *
                 *     sub = state.when("Connected", fn);
                 *     sub.dispose();
                 *
                 * Note, that the callback is invoked synchronously immediately after it's added
                 * if the property already had a value and thus an attempt to dispose the listener
                 * inside the callback won't work:
                 *
                 *     p = Property();
                 *     p(123);
                 *     s = p.when(123, function () {
                 *         s.dipose(); // => s is undefined at the moment
                 *     });
                 *
                 * A workaround is to dispose the listener at the next event cycle:
                 *
                 *     s = p.when(123, function () {
                 *         setTimeout(s.dipose, 0);
                 *     });
                 *
                 * Or invoke this.dispose() inside the callback, as this refers to the created
                 * subscription object:
                 *
                 *     p.when(123, function () {
                 *         // do something
                 *         this.dispose();
                 *     });
                 *
                 * Notice, that if the callback was created via .bind in order to overwrite `this`,
                 * it won't be possible to invoke the .dispose method.
                 */
                PropertyImpl.prototype.when = function (value, handler) {
                    var changed = this.changed;
                    var sub = {
                        dispose: function () { return changed.off(fn); }
                    };
                    var matches = Utils.isFunction(value) ?
                        value :
                        function (v) { return v === value; };
                    function fn(newValue, reason, oldValue) {
                        if (matches(newValue))
                            handler.call(sub, reason, oldValue);
                    }
                    changed(fn);
                    return sub;
                };
                /**
                 * Adds a one-time listener.
                 *
                 * Specifies a callback to be invoked once the property obtains the given value:
                 *
                 *     state.once("Disconnected", function (reason, oldState) {
                 *         // handling of the Disconnected state
                 *     });
                 *
                 * After the callback is invoked, it's removed from the event listeners.
                 * If the callback needs to handle multiple values, it's possible to write a
                 * predicate function that would recognize these values:
                 *
                 *     anyOf = vs => v => vs.indexOf(v) >= 0;
                 *     state.once(anyOf("Connected", "Disconnected"), function (reason) {
                 *         // the state is either Connected or Disconnected
                 *     });
                 *
                 * To remove the event listener before it's invoked, use the dispose method:
                 *
                 *     sub = state.once("Connected", fn);
                 *     sub.dispose();
                 */
                PropertyImpl.prototype.once = function (value, callback) {
                    return this.when(value, function () {
                        this.dispose();
                        callback.apply(null, arguments);
                    });
                };
                /**
                 * Returns a boolean property, which indicates whether the value of self property equals to the given value.
                 * The boolean property always gets updated when the self property changes.
                 */
                PropertyImpl.prototype.equals = function (value) {
                    return this.map(function (v) { return v == value; });
                };
                PropertyImpl.prototype.equalsAny = function () {
                    var array = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        array[_i - 0] = arguments[_i];
                    }
                    return this.map(function (value) { return Utils.contains(array, function (x) { return x == value; }); });
                };
                PropertyImpl.prototype.fork = function (setter) {
                    var self = this;
                    var sub;
                    var enabled = Utils.isProperty(setter) ? setter : setter.enabled || ConstProperty(true);
                    var isReadOnly = enabled === ConstProperty(false);
                    var p = Property({
                        value: self._value,
                        reason: self.reason,
                        readOnly: isReadOnly,
                        set: isReadOnly ? null :
                            Utils.isProperty(setter) ? Utils.Command(function (v, r) { return self.set(v, r); }, enabled) :
                                Utils.Command(function (v, r) { return Utils.async(setter)(v, r).then(function (v) { return self.set(v, r); }); }, enabled),
                        get: self.get.bind(self),
                        subscribed: function () { return sub = self.subscribe(); },
                        unsubscribed: function () { return sub.dispose(); }
                    });
                    (self._forks = self._forks || []).push(p);
                    return p;
                };
                /**
                 * Returns a read-only property.
                 *
                 * The value of the read-only property can be modified only by its
                 * creator (this Property object).
                 *
                 * The read-only property allows the short-hand syntax to get a value
                 * and to convert it to a string:
                 *
                 *     var p = Property({ value: 123 }).asReadOnly();
                 *
                 *     assert(p() == 123);
                 *     assert(p == '123'); // instead of p().toString()
                 *
                 * The read-only property has the same interface as the regular property,
                 * but its .set command is disabled.
                 */
                PropertyImpl.prototype.asReadOnly = function () {
                    var self = this;
                    if (!self._ro)
                        self._ro = self.fork(Utils.DisabledAsyncCommand());
                    return self._ro;
                };
                PropertyImpl.prototype.observed = function () {
                    var self = this, changed = self._changed;
                    return changed && changed.observed();
                };
                /**
                 * Tells the property to keep its value always up to date.
                 *
                 * This method should be invoked if the up to date property value is needed at all times.
                 * The difference between .subscribe and .get is that .get fetches the value once, while
                 * .subscribe keeps the value always up to date. A call to .subscribe is generally heavier
                 * than a call to .get. Typically it's used to create a presence subscription:
                 *
                 *     var sub = person.status.subscribe();
                 *     person.status.changed(value => console.log(value));
                 *     setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
                 *
                 * If the property value is needed only once, it's better to use .get.
                 *
                 * The first call to this method notifies the property's owner via the `subscribed` hook.
                 * After the last subscription is disposed, the property's owner is notified via the `unsubscribed` hook.
                 */
                PropertyImpl.prototype.subscribe = function (dt) {
                    var self = this;
                    // the first call to .subscribe creates a subscription object
                    var sub = new Utils.RefCountedSubscription({
                        unsubscribed: self._unsubscribed,
                        subscribed: self._subscribed,
                        updated: function () { return self.get(); }
                    });
                    // all subsequent calls will be handled by that object: see how
                    // the .subscribe method is being replaced here
                    self.subscribe = function (dt) { return sub.subscribe(dt); };
                    return self.subscribe(dt);
                };
                /**
                 * Changes the value bypassoing the custom setter.
                 * This method isn't recommended to use because it breaks encapsulation.
                 */
                PropertyImpl.prototype._set = function (value, reason) {
                    var self = this, oldValue = self._value, i, forks = self._forks, changed = self._changed;
                    if (!self._same(value, reason)) {
                        self._value = value;
                        self.reason = reason;
                        if (changed)
                            changed.fire(value, reason, oldValue);
                        if (forks) {
                            for (i = 0; i < forks.length; i++)
                                forks[i]._set(value, reason);
                        }
                    }
                    return value;
                };
                PropertyImpl.prototype._same = function (value, reason) {
                    var self = this;
                    return Utils.deepEqual(value, self._value) && Utils.deepEqual(reason, self.reason);
                };
                PropertyImpl.prototype._getChanged = function () {
                    var self = this;
                    if (!self._changed) {
                        self._changed = new Utils.Event({
                            context: self,
                            added: self._listenerAdded
                        });
                    }
                    // it might be tempting to replace the property getter
                    // with the actual value which is known now by using 
                    // Object.defineProperty and thus avoid calling this getter
                    // later, but the surprising fact is that such an
                    // "optimization" makes the property with a listener about
                    // 1.5x heavier and about 1.5x slower
                    return self._changed.observer;
                };
                PropertyImpl.prototype._listenerAdded = function (listener) {
                    var self = this, changed = self._changed, value = self._value, reason = self.reason;
                    if (value !== void 0)
                        // Event::_invoke knows better how to invoke a listener properly
                        changed._invoke(listener, [value, reason]);
                };
                PropertyImpl.prototype._getAsync = function () {
                    var self = this, getter = self._getter, value = self._value;
                    if (!getter)
                        return value;
                    if (!self._dfdget)
                        self._dfdget = getter.call(self, value, self.reason);
                    return self._dfdget.then(function (value) {
                        self._dfdget = null;
                        self._set(value, self.reason);
                        return self._value;
                    }, function (error) {
                        // it can be nulled in a nicer way by .finally(...)
                        // at the expense of creating an extra promise which
                        // is not acceptable in Property::get calls as they
                        // are made frequently
                        self._dfdget = null;
                        throw error;
                    });
                };
                PropertyImpl.prototype._setAsync = function (value, reason) {
                    var self = this, check = self._check, setter = self._setter;
                    Utils.assert(arguments.length > 0);
                    if (self._same(value, reason))
                        return value;
                    if (check)
                        check(value);
                    // _set could be invoked once at the price of always creating
                    // an extra task which would make the whole property model a bit slower
                    return !setter ?
                        self._set(value, reason) :
                        setter.call(self, value, reason).then(function (value) { return self._set(value, reason); });
                };
                PropertyImpl.prototype._write = function (value, reason) {
                    var self = this, check = self._check, setter = self._setter;
                    if (self._same(value, reason))
                        return;
                    if (check)
                        check(value);
                    if (!self.set.enabled())
                        throw Error('This is a read-only property.');
                    // obj.prop(123) is a shortcut to obj.prop.set(123)
                    // except that it returns the owner object `obj`
                    // note, that f.set returns a promise; also
                    // `update` could be invoked once at the price of always creating
                    // an extra task which would make the whole property model a bit slower
                    if (setter && reason !== Property.sUpdated)
                        setter.call(self, value, reason).then(function (value) { return self._set(value, reason); });
                    else
                        self._set(value, reason);
                };
                __decorate([
                    Utils.async
                ], PropertyImpl.prototype, "_getAsync", null);
                __decorate([
                    Utils.async.bind('sync')
                ], PropertyImpl.prototype, "_setAsync", null);
                return PropertyImpl;
            })();
            // The created property object must be a function with a few extra methods.
            // It also must have at least .call, .apply and .bind methods that all functions have,
            // as the created property object can be used as a function. At the same time some
            // browsers do not support replacing prototype of a function and in such browsers
            // changing the prototype is replacing with copying all the methods from the desired
            // property's prototype object. This works because if replacing the prototype is not
            // supported, then the created property object remains a regular function with its
            // original prototype with .call, .bind and .apply methods, and is extended with custom
            // methods. This is why property objects behave the same way in old and new browsers,
            // though employ quite different techniques to achieve that.
            Property.prototype = Utils.extend(function () { }, PropertyImpl.prototype, { constructor: Property });
            /**
             * A read only property with the given value.
             * It also acts as a cache of created const property objects.
             */
            function ConstProperty(value, reason) {
                if (reason === void 0) {
                    if (value === null)
                        return Property['null'];
                    if (value === true)
                        return Property['true'];
                    if (value === false)
                        return Property['false'];
                }
                return Property({
                    value: value,
                    reason: reason,
                    readOnly: true
                });
            }
            Utils.ConstProperty = ConstProperty;
            var Property;
            (function (Property) {
                // TODO: This thing is deprecated and shouldn't be used in new code.
                //
                // If a property was created with an overridden .set, i.e. p = Property({ set: fn }),
                // then in order to change the property value without triggering the custom setter
                // the owner of the property needs to use some kind of backdoor and this sUpdated
                // is this backdoor, as p.set(val, sUpdated) changes the value without invoking fn.
                //
                // A cleaner solution is to fork a property and give a custom setter to that property:
                //
                //  var pInternal = Property();
                //  var pExternal = pInternal.fork(fnSet);
                //
                // This way the owner of the property can change the value of the internal property
                // which doesn't have custom .set, while a consumer gets an external version of the property
                // with overridedn .set and .get.
                Property.sUpdated = {};
                // The const true and false properties are also regular properties
                // with .get and .set commands. These commands, in turn, are regular
                // commands that have the .enabled property which is either the const true
                // or the const false property. To break this recursion, the const true
                // and false properties are created once with .get and .set commands
                // without the .enabled property and after they are created, their .get and
                // .set commands are given the .enabled properties. Thus the structure
                // of the created two properties look like this:
                //
                //      <t> = {
                //          get: { enabled: <t> },
                //          set: { enabled: <f> }
                //      };
                //
                //      <f> = {
                //          get: { enabled: <t> },
                //          set: { enabled: <f> }
                //      };
                //
                // This makes an impression that there is an infinitely long chain of
                // someProperty.get.enabled.set.enabled.set.enabled.get.enabled... while in
                // fact this chain is a loop between the two const properties.
                var $true = Property({ value: true, readOnly: true });
                var $false = Property({ value: false, readOnly: true });
                Property['true'] = $true;
                Property['false'] = $false;
                $true.get.enabled = $true;
                $true.set.enabled = $false;
                $false.get.enabled = $true;
                $false.set.enabled = $false;
                Utils.DisabledAsyncCommand.instance.enabled = $false;
                var $null = Property({ value: null, readOnly: true });
                Property['null'] = $null;
            })(Property = Utils.Property || (Utils.Property = {}));
            var Property;
            (function (Property) {
                /**
                 * Adds a callback to the .changed event of several properties at once.
                 * The callback is invoked whenever any property in the list changes.
                 *
                 *      const sub = Property.observe([p1, p2], (value1, value2) => {
                 *          ...
                 *      });
                 *
                 * The attached callback can be then detached from all the properties:
                 *
                 *      sub.dispose();
                 *
                 * If an empty array of deps is passed, the `observe` acts like ko.computed:
                 * it detects all deps, subscribes to them and unsubvscribes from the list changes.
                 */
                function observe(properties, callback) {
                    if (properties.length == 0) {
                        observe2(callback);
                        return new Utils.Subscription(Utils.noop);
                    }
                    // note, that this `observe` essentially aggregates .changed events
                    // from the given properties, so an even more generic implementation
                    // would look like Event.all([p1.changed, p2.changed], callback); it's
                    // not clear, though, what to do with multiple event arguments
                    var psubs = properties.map(function (p) {
                        return p.changed(function () {
                            var values = properties.map(function (p) { return p(); });
                            callback.apply(null, values);
                        });
                    });
                    return new Utils.Subscription(function () {
                        for (var _i = 0; _i < psubs.length; _i++) {
                            var s = psubs[_i];
                            s.dispose();
                        }
                    });
                }
                Property.observe = observe;
                function observe2(callback) {
                    var deps = [];
                    function refresh() {
                        // collect new deps
                        Utils.assert(!rdlog);
                        rdlog = [];
                        callback();
                        var newDeps = rdlog;
                        rdlog = null;
                        // unsubscribe from old deps
                        for (var _i = 0; _i < deps.length; _i++) {
                            var p = deps[_i];
                            if (newDeps.indexOf(p) < 0)
                                p.changed.off(refresh);
                        }
                        // subscribe to new deps
                        for (var _a = 0; _a < newDeps.length; _a++) {
                            var p = newDeps[_a];
                            if (deps.indexOf(p) < 0)
                                p.changed.on(refresh);
                        }
                        deps = newDeps;
                    }
                    refresh(); // collect initial deps
                }
            })(Property = Utils.Property || (Utils.Property = {}));
            /**
             * A property that contains an numeric value.
             * Usually it contains an integer value:
             *
             *      p = NumProperty(0);
             *      p.inc(); // p() == 1
             *      p.dec(); // p() == 2
             *
             * @method inc
             * @method dec
             *
             * @blame antonkh
             */
            function NumProperty(value, reason) {
                var p = Property({ value: value, reason: reason });
                // note, that p.asReadOnly() drops these
                // two methods which is fine because a read
                // only property cannot be incremented or
                // decremented
                p.inc = function () { return p(p() + 1); };
                p.dec = function () { return p(p() - 1); };
                return p;
            }
            Utils.NumProperty = NumProperty;
            /**
             * A property that contains a boolean value.
             */
            function BoolProperty(value, reason) {
                var p = Property({ value: value, reason: reason });
                p.not = function () { return p.map(function (x) { return !x; }); };
                return p;
            }
            Utils.BoolProperty = BoolProperty;
            /**
             * Constructs a property which values depends on a few other properties.
             *
             * Note, that a computed property that depends on only one property
             * can be constructed with a call to Property::map; a computed property
             * that depends on two properties corresponds to an overloaded operator
             * of the Property class (which isn't possible in JS as of today).
             *
             *      var a = Property({ value: 1 });
             *      var b = Property({ value: 2 });
             *      var c = ComputedProperty(a, b, (x, y) => x + y);
             *
             * In the knockout library there is something similar. Perhaps, the only
             * major difference between this thing and ko.observable is that ko can
             * figure out the list of dependencies on its own, which is very convenient:
             *
             *      var a = ko.observable(1);
             *      var b = ko.observable(2);
             *      var c = ko.computed(() => a() + b());
             *
             * This can be achieved by passing the empty list of deps:
             *
             *      var c = ComputedProperty([], () => a() + b());
             *
             * @blame antonkh
             * @created Jun 2015
             */
            function ComputedProperty(properties, fn) {
                var psubs;
                var computed = Property({
                    get: function () {
                        var pgets = Utils.map(properties, function (p) { return p.get(); });
                        return Utils.Task.waitAll(pgets).then(function (values) {
                            return fn.apply(null, values);
                        });
                    },
                    subscribed: function () {
                        psubs = Utils.map(properties, function (p) { return p.subscribe(); });
                    },
                    unsubscribed: function () {
                        Utils.foreach(psubs, function (s) { return s.dispose(); });
                    }
                });
                Property.observe(properties, function () {
                    // the current version of ts we are using (1.5.0-beta)
                    // converts rest arguments (...values) to an array first
                    // which would be terribly inefficient if the array is
                    // only passed as-is to another function via .apply(...)
                    computed(fn.apply(null, arguments));
                });
                // if we later decide to somehow make the returned property writable,
                // this will be the right place for the change: asReadOnly will need
                // to be replaced with fork(...)
                return computed.asReadOnly();
            }
            Utils.ComputedProperty = ComputedProperty;
            var Property;
            (function (Property) {
                Property.computed = ComputedProperty;
                Property.bool = BoolProperty;
                Property.just = function (value) { return Property({ value: value }); };
                Property.readonly = ConstProperty;
                Property.numeric = NumProperty;
            })(Property = Utils.Property || (Utils.Property = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="base.ts" />
/// <reference path="Promise.ts" />
/// <reference path="Property.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * An observable ordered collection of items.
             *
             * A creator of this collection can add items to it, while others get a read-only
             * version of the collection and can subscribe to changes in it.
             *
             * In this example a constructor of class Conversation creates an observable
             * collection "messages" and exposes its read-only version in its interface:
             *
             *      var messages = Collection();
             *      messages.add('First Message');
             *
             *      return {
             *          messages: messages.asReadOnly()
             *      };
             *
             * The users of the Conversation subscribe to the collection and get notified
             * when the Conversation adds items to it:
             *
             *      var conversation = Conversation(...);
             *      conversation.chatService.messages.added(function (message) {
             *          console.log('New message:', message);
             *      });
             *
             * So whenever the Conversation invokes messages.add('Another Message'), the new message
             * gets printed to the console log.
             *
             * This example demonstrates how the view layer binds to the model layer.
             * The model layer in turn subscribes to the stack layer via event mechanism
             * and update the model properties when it get events from the stack.
             *
             * @created Jul 2013
             * @blame antonkh
             */
            function Collection(options) {
                return CollectionImpl(options);
            }
            Utils.Collection = Collection;
            var CollectionImpl = (function () {
                function CollectionImpl(options) {
                    var self = pm_collection;
                    self._ = Utils.extend({}, options);
                    var _ = self._;
                    if (options && options.get)
                        _.get = Utils.async(options.get);
                    _.vals = []; // Map<Index, Value>
                    _.keys = []; // Map<Index, Key>
                    _.idxs = {}; // Map<Key, Index>
                    // this function represents the read-write instance of the property
                    // and at the same time acts as its getter and setter, which takes
                    // ar array of items and replaces contents of the collection with them
                    function pm_collection(key) {
                        if (arguments.length == 0) {
                            return self._asArray();
                        }
                        else if (Utils.isArray(key)) {
                            self.empty();
                            self._addArray(key);
                            return this;
                        }
                        else {
                            return self._getFromCache(key);
                        }
                    }
                    Utils.setPrototypeOrExtend(self, Collection.prototype);
                    self._init();
                    return self;
                }
                /**
                 * Tells the collection to keep its list of items always up to date.
                 *
                 * This method should be invoked if the up to date list of items is needed at all times.
                 * The difference between .subscribe and .get is that .get fetches the list once, while
                 * .subscribe keeps the list always up to date. A call to .subscribe is generally heavier
                 * than a call to .get.
                 *
                 *     var sub = client.devices.subscribe();
                 *     client.devices.changed(items => console.log(items));
                 *     setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
                 *
                 * If the list of items is needed only once, it's better to use .get.
                 *
                 * The first call to this method notifies the collection's owner via the `subscribed` hook.
                 * After the last subscription is disposed, the collection's owner is notified via the `unsubscribed` hook.
                 */
                CollectionImpl.prototype.subscribe = function (dt) {
                    var self = this, _ = self._;
                    // the first call to .subscribe creates a subscription object
                    var sub = new Utils.RefCountedSubscription({
                        unsubscribed: _.unsubscribed,
                        subscribed: _.subscribed,
                        updated: function () { return self.get(); }
                    });
                    // all subsequent calls will be handled by that object: see how
                    // the .subscribe method is being replaced here
                    self.subscribe = function (dt) { return sub.subscribe(dt); };
                    return self.subscribe(dt);
                };
                CollectionImpl.prototype.observed = function () {
                    var _ = this._, added = _.added, removed = _.removed, changed = _.changed;
                    return added && added.observed() ||
                        removed && removed.observed() ||
                        changed && changed.observed();
                };
                /**
                 * Adds an item to the collection.
                 *
                 * If key is omitted, a random key is generated.
                 * If index is omitted, the item is appended to the end of the collection.
                 */
                CollectionImpl.prototype.add = function (val, key, idx) {
                    var _ = this._, n = _.vals.length;
                    key = key || (_.key ? _.key(val) : Utils.random());
                    if (key in _.idxs)
                        throw Utils.EAlreadyExists(key);
                    idx = Utils.isInteger(idx) ? idx : n;
                    if (idx < 0)
                        idx = 0; // .add(..., -123) works as .add(..., 0)
                    if (idx > n)
                        idx = n; // .add(..., +Infinity) works as .add(..., .size())
                    this._insert(val, key, idx);
                    if (_.size)
                        _.size.inc();
                    if (_.added)
                        _.added.fire(val, key, idx);
                    if (_.changed)
                        _.changed.fire();
                    return key;
                };
                /**
                 * Removes an item by key or index.
                 *
                 * .remove(key) removes an item by its key, which is a string.
                 * .remove(idx) removes an item from the given index.
                 */
                CollectionImpl.prototype.remove = function (key) {
                    var _ = this._, idx, val, i;
                    if (Utils.isInteger(key)) {
                        idx = key;
                        key = _.keys[idx];
                    }
                    else {
                        idx = _.idxs[key];
                    }
                    val = _.vals[idx];
                    if (idx >= 0 && idx < _.vals.length) {
                        for (i = idx + 1; i < _.keys.length; i++)
                            _.idxs[_.keys[i]]--;
                        Utils.removeAt(_.vals, idx);
                        Utils.removeAt(_.keys, idx);
                        delete _.idxs[key];
                        if (_.size)
                            _.size.dec();
                        if (_.removed)
                            _.removed.fire(val, key, idx);
                        if (_.changed)
                            _.changed.fire();
                    }
                };
                /** Removes all items chosen by a predicate function.
                    Returns the number of items removed. */
                CollectionImpl.prototype.removeAll = function (predicate) {
                    var _ = this._, n = _.vals.length, rmkeys = [];
                    for (var i = 0; i < n; i++) {
                        var v = _.vals[i];
                        var k = _.keys[i];
                        if (predicate(v))
                            rmkeys.push(k);
                    }
                    for (var _i = 0; _i < rmkeys.length; _i++) {
                        var key = rmkeys[_i];
                        this.remove(key);
                    }
                    return rmkeys.length;
                };
                /**
                 * Returns an item associated with the specified key or index.
                 *
                 * .get() fetches all the items and returns them as an array.
                 * .get(key) fetches an item with the given key, which is a string.
                 * .get(index) fetches an item with the given index.
                 *
                 * Multiple calls to .get(...) invoke the custom getter, if it's set, only once.
                 */
                CollectionImpl.prototype.get = function (key) {
                    // `get` is wrapped by `async` so it may return values and promises
                    // if `key` is a string - return an item associated with this key
                    // if `key` is a number - return an item associated with this zero-based index
                    // if `key` is undefined - return all items as an array
                    var self = this, _ = self._, get = _.get, promise;
                    if (get && !_.dfdget)
                        _.dfdget = get();
                    if (_.dfdget) {
                        promise = _.dfdget.then(function (items) {
                            _.dfdget = null;
                            return self._setNewItems(items);
                        }, function (error) {
                            _.dfdget = null;
                            throw error;
                        });
                    }
                    return Utils.Task.wait(promise).then(function () {
                        return Utils.isVoid(key) ? self._asArray() : self._getFromCache(key);
                    });
                };
                CollectionImpl.prototype.index = function (key) {
                    return this._.idxs[key];
                };
                CollectionImpl.prototype.key = function (idx) {
                    return this._.keys[idx];
                };
                CollectionImpl.prototype.empty = function () {
                    var _ = this._, i;
                    if (_.removed) {
                        for (i = 0; i < _.vals.length; i++)
                            _.removed.fire(_.vals[i], _.keys[i]);
                    }
                    _.vals = [];
                    _.keys = [];
                    _.idxs = {};
                    if (_.size)
                        _.size(0);
                    if (_.changed)
                        _.changed.fire();
                };
                /** Returns a read-only version of the collection. */
                CollectionImpl.prototype.asReadOnly = function () {
                    var self = this, readonly = ro;
                    function ro(key) {
                        return arguments.length == 0 ?
                            self._asArray() :
                            self._getFromCache(key);
                    }
                    Utils.setPrototypeOrExtend(readonly, self);
                    readonly._init();
                    // the delete operator won't work deletes a member 
                    // from the object, but not from its prototype
                    readonly.add = null;
                    readonly.remove = null;
                    readonly.empty = null;
                    return readonly;
                };
                /**
                 * Creates a fork of the collection with customized .add and .remove commands.
                 *
                 * All the forks share the same state and have the same set of items.
                 * In fact they are the same instance of the collection.
                 * Different forks have different customized .add and .remove commands
                 * that can have custom logic and can be async.
                 */
                CollectionImpl.prototype.fork = function (methods) {
                    var self = this;
                    var writable = wr;
                    function wrap(fn) {
                        return Utils.isCommand(fn) ? Utils.Command(Utils.async(fn), fn.enabled) :
                            Utils.isFunction(fn) ? Utils.EnabledCommand(Utils.async(fn)) :
                                Utils.DisabledAsyncCommand(Utils.ENotSupported());
                    }
                    function wr(key) {
                        return arguments.length == 0 ? self() : self(key);
                    }
                    Utils.setPrototypeOrExtend(writable, self);
                    Utils.extend(writable, {
                        add: wrap(methods.add),
                        remove: wrap(methods.remove)
                    });
                    writable._init();
                    return writable;
                };
                /** this method is depercated; use .fork */
                CollectionImpl.prototype.asWritable = function (methods) {
                    return this.fork(methods);
                };
                CollectionImpl.prototype.toString = function () {
                    return '[Collection: ' + this.size() + ' items]';
                };
                CollectionImpl.prototype.each = function (fn) {
                    var _ = this._;
                    for (var i = 0; i < _.vals.length; i++)
                        fn(_.vals[i], _.keys[i]);
                    return this;
                };
                CollectionImpl.prototype.contains = function (predicate) {
                    var res = false;
                    // before making this function work with
                    // primitive values, consider collections that
                    // contain functions
                    this.each(function (val) {
                        if (predicate(val))
                            res = true;
                    });
                    return res;
                };
                /**
                 * Collects batches of changes and sends them to the callback every event cycle.
                 *
                 * Whenever an item is added to the collection or removed from it, the collection
                 * fires an appropriate event. However if the UI starts updating the DOM tree
                 * after every change, it may become pretty slow. It might be better to collect
                 * all changes made within a short period of time and then update the DOM tree once.
                 * This method starts listening to the changes in the collection, summarizes these
                 * changes and invokes the specified callback at the next event cycle:
                 *
                 *     var sub = conversations.observe(function (added, removed) {
                 *         foreach(added, function (conversation, key) {
                 *             console.log("conversation has been added");
                 *         });
                 *
                 *         foreach(removed, function (conversation, key) {
                 *             console.log("conversation has been removed");
                 *         });
                 *     });
                 *
                 *     // some time later...
                 *     sub.dispose();
                 *
                 * This theoretically allows to handle the list of changes and efficiently redraw the UI.
                 */
                CollectionImpl.prototype.observe = function (callback) {
                    var hTimer, source = this, added = {}, removed = {};
                    function itemAdded(val, key) {
                        added[key] = val;
                        delete removed[key];
                        startTimer();
                    }
                    function itemRemoved(val, key) {
                        removed[key] = val;
                        delete added[key];
                        startTimer();
                    }
                    function startTimer() {
                        if (!hTimer) {
                            hTimer = Web.setTimeout(function () {
                                var _added = added, _removed = removed;
                                added = {}; // callback may add an item indirectly
                                removed = {}; // callback may remove an item indirectly
                                hTimer = null;
                                callback(_added, _removed);
                            }, 0);
                        }
                    }
                    function stopTimer() {
                        if (hTimer) {
                            Web.clearTimeout(hTimer);
                            hTimer = null;
                        }
                    }
                    source.added(itemAdded);
                    source.removed(itemRemoved);
                    return {
                        dispose: function () {
                            stopTimer();
                            source.added.off(itemAdded);
                            source.removed.off(itemRemoved);
                        }
                    };
                };
                /**
                 * Creates a collection with mapped items.
                 *
                 * source.map(fn) creates a collection in which all items satisfy the following
                 * condition: source.map(fn)(i) == fn(source(i)). The created collection is
                 * observable and correctly handles calls to .get and .subscribe by routing
                 * them to the source collection:
                 *
                 *     var phones = teluris.map(formatTelUriNicely);
                 *
                 * This example maps every tel uri, which looks like "tel:+1234...", to nicely
                 * looking phone numbers like "+1 (234) 456-7890", and the created collection
                 * remains observable and thus can be attached to UI.
                 */
                CollectionImpl.prototype.map = function (fn) {
                    var source = this, sub, mapped = Collection({
                        // the call to .get cannot be directly routed to the source
                        // collection because these collections have different items,
                        // despite these items have the same keys and the same order
                        get: function (src) {
                            return source.get().then(function () {
                                return mapped(src);
                            });
                        },
                        subscribed: function () {
                            sub = source.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    source.added(function (val, key, idx) {
                        // it's important to preserve the order of items
                        mapped.add(fn(val), key, idx);
                    });
                    source.removed(function (val, key) {
                        mapped.remove(key);
                    });
                    // theoretically the mapped collection can be left writable
                    // if it was possible to "unmap" every item with the inverse
                    // mapping function; since an arbitrary function cannot be
                    // inversed, the caller would need to pass both mapping and
                    // inverse mapping function
                    return mapped.asReadOnly();
                };
                /**
                 * Creates a collection that doesn't have certain items.
                 *
                 * source.filter(fn) creates a collection which contains all the items from
                 * the source collection except certain items that are filtered out by the
                 * given predicate:
                 *
                 *     var activityItems = conversation.historyService.activityItems;
                 *     var messages = activityItems.filter(i => i.type() == "TextMessage");
                 *
                 * The order of items in the filtered collection is preserved. The created collection
                 * handles correctly calls to .get and .subscribe and remains observable and thus can
                 * be attached to UI.
                 */
                CollectionImpl.prototype.filter = function (fn) {
                    var source = this, sub, filtered = Collection({
                        get: function (src) {
                            return source.get().then(function () {
                                return filtered(src);
                            });
                        },
                        subscribed: function () {
                            sub = source.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    source.added(function (val, key, idx) {
                        if (!fn(val))
                            return;
                        var si = idx + 1;
                        var sn = source.size();
                        // To preserve the original order of items find
                        // the closest item in the source collection which
                        // also exists in the filtered collection and insert
                        // the new item before that item.
                        while (si < sn && !fn(source(si)))
                            si++;
                        var fi = si < sn ?
                            filtered.index(source.key(si)) :
                            filtered.size();
                        filtered.add(val, key, fi);
                    });
                    source.removed(function (val, key) {
                        filtered.remove(key);
                    });
                    return filtered.asReadOnly();
                };
                /**
                 * Creates a sorted collection.
                 *
                 * It seems obvious that one collection exposed by the model layer can be displayed
                 * in different parts of UI in different ways: one UI element may need to sort items
                 * by one criteria, while another may need to use another criteria. To meet this
                 * requirement every collection exposed by the model need to have a method that
                 * creates another collection which is sorted:
                 *
                 *     var byName = persons.sort((p1, p2) => p1.displayName() < p2.displayName());
                 *     var byDept = persons.sort((p1, p2) => p1.department() < p2.department());
                 *
                 * The created sorted collections are observable and are updated whenever the source
                 * collection is updated, but in addition to that they are sorted.
                 */
                CollectionImpl.prototype.sort = function (isOrderCorrect) {
                    var unsorted = this, sub, sorted = Collection({
                        get: function (src) {
                            // the call cannot be directly routed to the unsorted collection
                            // because the order of items in the two collections is different
                            // and thus the same .get with the same index can return different items
                            return unsorted.get().then(function () {
                                return sorted(src);
                            });
                        },
                        subscribed: function () {
                            sub = unsorted.subscribe();
                        },
                        unsubscribed: function () {
                            sub.dispose();
                        }
                    });
                    function ord(x, y) {
                        // ord(x, y) = x @ y tells whether x can precede y in the ordered collection;
                        // essentially @ is a transitive relation over the set of items;
                        // a well behaved relation must allow either (x, y) or (y, x) for any given x and y;
                        // if, however, it allows neither, it can be assumed that it doesn't care;
                        return isOrderCorrect(x, y) || !isOrderCorrect(y, x);
                    }
                    unsorted.added(function (val, key, idx) {
                        var n = sorted.size(), i = 0;
                        // The @ relation splits the entire collection into several groups:
                        // items witin a group can be placed in any order as @ cannot distinguish them,
                        // but the groups must come in a certain "ascending" order.
                        // Thus the first step before insering a new item into the sorted collection
                        // is to find the appropriate group G for that item. This loop finds the leftmost
                        // boundary of the appropriate group.
                        while (i < n && !ord(val, sorted(i)))
                            i++;
                        // After the appropriate group G is found, the item can be theoretically
                        // inserted at any position within the group, i.e. at the beginning or at the end,
                        // however it's better to consider how items in the group are ordered in
                        // the unsorted collection. The group G can be called "sorted" if for any
                        // pair of items x and y from G, if x appears before y in G, then it also appears
                        // before y in the unsorted collection. To not break this property of G, the new
                        // item must be inserted at the right position and, obviously, there is only
                        // one such position. The loop below finds this only possible position.
                        // Thus this loop makes the sorting algorithm stable.
                        while (i < n && ord(sorted(i), val) && unsorted.index(sorted.key(i)) < idx)
                            i++;
                        sorted.add(val, key, i);
                    });
                    unsorted.removed(function (val, key) {
                        sorted.remove(key);
                    });
                    return sorted.asReadOnly();
                };
                /**
                 * Aggregates the items in the collection into an observable property.
                 *
                 * The key feature of this method is that it's like ko.computed observes
                 * the list of dependent properties and updates the aggregated value
                 * whenever any of the deps changes.
                 *
                 *      const values = Collection();
                 *      const product = values.reduce((val, prop) => val ? val * prop() : 0, 1);
                 *
                 *      const x = Property(); x.set(3);
                 *      const y = Property(); y.set(5);
                 *      const z = Property(); z.set(7);
                 *
                 *      values.add(x); // product() == 3
                 *      values.add(y); // product() == 3*5
                 *      values.add(z); // product() == 3*5*7
                 *
                 *      y.set(0); // product() == 0 and z is not even being observed
                 *      y.set(11); // product() == 3*11*7 and z is being observed again
                 *
                 * A possible application is computing the number of online users:
                 *
                 *      const nOnline = persons.reduce((n, p) => n + (!!p.status() == "Online"), 0);
                 *      nOnline.changed(n => document.title = n + " people online");
                 *
                 * This works as long as the computed value doesn't depend on some external source.
                 */
                CollectionImpl.prototype.reduce = function (aggregate, initialValue) {
                    var _this = this;
                    var aggregated = Utils.Property();
                    var values = this._.vals; // this ref never changes
                    Utils.Property.observe([], function () {
                        _this.size(); // the aggregated value depends on this property as well
                        var newValue = values.reduce(aggregate, initialValue);
                        aggregated(newValue); // this might result in other properties being read
                    });
                    return aggregated.asReadOnly();
                };
                CollectionImpl.prototype._init = function () {
                    var self = this;
                    Object.defineProperties(self, {
                        added: {
                            enumerable: true,
                            get: self._initAddedEvent
                        },
                        removed: {
                            enumerable: true,
                            get: self._initRemovedEvent
                        },
                        changed: {
                            enumerable: true,
                            get: self._initChangedEvent
                        },
                        size: {
                            enumerable: true,
                            get: self._initSizeProperty
                        }
                    });
                };
                CollectionImpl.prototype._getFromCache = function (key) {
                    var _ = this._;
                    return Utils.isString(key) ?
                        _.vals[_.idxs[key]] :
                        _.vals[key]; // get by index
                };
                CollectionImpl.prototype._setNewItems = function (newItems) {
                    var self = this, _ = self._, key;
                    if (!Utils.isDictionary(newItems))
                        return;
                    for (key in _.idxs)
                        if (!(key in newItems) || _.vals[_.idxs[key]] !== newItems[key])
                            self.remove(key);
                    for (key in newItems)
                        if (!(key in _.idxs))
                            self.add(newItems[key], key);
                };
                CollectionImpl.prototype._initAddedEvent = function () {
                    var self = this, _ = self._, name = 'added', val;
                    _[name] = _[name] || new Utils.Event({
                        context: self,
                        adding: self._addedListenerAdding
                    });
                    val = _[name].observer;
                    return val;
                };
                CollectionImpl.prototype._addedListenerAdding = function (listener) {
                    var self = this, _ = self._, event = _.added;
                    Utils.foreach(_.vals, function (v, i) {
                        event._invoke(listener, [v, _.keys[i], i]);
                    });
                };
                CollectionImpl.prototype._initRemovedEvent = function () {
                    var self = this, _ = self._, name = 'removed', val;
                    _[name] = _[name] || new Utils.Event();
                    val = _[name].observer;
                    return val;
                };
                CollectionImpl.prototype._initChangedEvent = function () {
                    var self = this, _ = self._, name = 'changed', val;
                    _[name] = _[name] || new Utils.Event({
                        context: self,
                        added: self._changedListenerAdded
                    });
                    val = _[name].observer;
                    return val;
                };
                CollectionImpl.prototype._changedListenerAdded = function (listener) {
                    var self = this, _ = self._, event = _.changed;
                    event._invoke(listener, []);
                };
                CollectionImpl.prototype._initSizeProperty = function () {
                    var self = this, _ = self._, name = 'size', val;
                    _[name] = _[name] || Utils.NumProperty(_.vals.length);
                    val = _[name].asReadOnly();
                    return val;
                };
                CollectionImpl.prototype._insert = function (val, key, idx) {
                    var i, _ = this._, n = _.vals.length;
                    for (i = idx; i < n; i++)
                        _.idxs[_.keys[i]]++;
                    Utils.insertAt(_.vals, idx, val);
                    Utils.insertAt(_.keys, idx, key);
                    _.idxs[key] = idx;
                };
                CollectionImpl.prototype._addArray = function (arr) {
                    for (var i = 0; i < arr.length; i++)
                        this.add(arr[i]);
                };
                CollectionImpl.prototype._asArray = function () {
                    return this._.vals.slice(0); // clone the array
                };
                return CollectionImpl;
            })();
            // Collections are functions and in order to behave like proper functions,
            // they need to have all the function's methods like .apply and .call.
            Collection.prototype = Utils.extend(function () { }, CollectionImpl.prototype, { constructor: Collection });
            var Collection;
            (function (Collection) {
                // An empty read only collection is useful to create stubs
                // in place of real collections. Since two empty read only
                // collections cannot be distinguished, it's reasonble to
                // have only one instance of such a collection.
                Collection.empty = Collection().asReadOnly();
            })(Collection = Utils.Collection || (Utils.Collection = {}));
            function ConstCollection(items) {
                var collection = Collection();
                collection(items);
                return collection.asReadOnly();
            }
            Utils.ConstCollection = ConstCollection;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * A property that takes its value from another (source) property.
             *
             * @created Feb 2015
             * @blame sosobov
             */
            function SourcedProperty(source) {
                var src, s, cs, isSubscribed = false, enabled = Utils.Property({ value: false });
                var p = Utils.Property({
                    get: function () {
                        return src && src.get();
                    },
                    set: Utils.Command(function (value, reason) {
                        return src && src.set(value, reason).then(function () {
                            return p();
                        });
                    }, enabled),
                    subscribed: function () {
                        isSubscribed = true;
                        s = src && src.subscribe();
                    },
                    unsubscribed: function () {
                        isSubscribed = false;
                        if (s) {
                            s.dispose();
                            s = null;
                        }
                    }
                });
                p.setSource = function (source) {
                    Utils.assert(Utils.isProperty(source) || !source);
                    if (src === source)
                        return;
                    src = source;
                    enabled(!!src);
                    if (cs) {
                        cs.dispose();
                        cs = null;
                    }
                    if (src) {
                        cs = src.changed(function (value, reason) {
                            p._set(value, reason);
                        });
                        if (src() === void 0)
                            p._set(src());
                    }
                    if (s) {
                        s.dispose();
                        s = null;
                    }
                    if (isSubscribed && src)
                        s = src.subscribe();
                    if (!src)
                        p._set(void 0);
                };
                p.setSource(source);
                return p;
            }
            Utils.SourcedProperty = SourcedProperty;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * A command that delegates its execution to another (source) command.
             *
             * @method setSource(source) - Sets source cmd
             *
             * NB: it is assumed that source command is not using "this" in its implementation -
             * its context is coming from the closures.
             *
             * @created Feb 2015
             * @blame sosobov
             */
            function SourcedCommand() {
                var src, enabled = Utils.SourcedProperty();
                // cmd with undefined source is disabled
                enabled.setSource(Utils.ConstProperty(false));
                var cmd = Utils.Command(function () {
                    return src.apply(null, arguments);
                }, enabled);
                cmd.setSource = function (source) {
                    Utils.assert(Utils.isCommand(source) || !source);
                    src = source;
                    enabled.setSource(src ? src.enabled : Utils.ConstProperty(false));
                };
                return cmd;
            }
            Utils.SourcedCommand = SourcedCommand;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * A model composed of properties sourced by properties of another (source) model.
             *
             * @param {Model} model - A model used as a blueprint for sourced model construction.
             *
             * @method setSource(source) - Sets source model
             *
             * @created Feb 2015
             * @blame sosobov
             */
            function SourcedModel(model) {
                var m = Utils.Model(Utils.map(model, function (member) {
                    return Utils.isProperty(member) ? Utils.SourcedProperty() :
                        Utils.isModel(member) ? SourcedModel(member) :
                            Utils.isCommand(member) ? Utils.SourcedCommand() :
                                // TODO: add collections
                                Utils.assert(false);
                }));
                Utils.setHiddenProperty(m, 'setSource', function (source) {
                    for (var i in m)
                        m[i].setSource(source && source[i]);
                });
                return m;
            }
            Utils.SourcedModel = SourcedModel;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="Collection.ts" />
/// <reference path="SourcedProperty.ts" />
/// <reference path="SourcedCommand.ts" />
/// <reference path="SourcedModel.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            function Model(members) {
                return Utils.inherit(Model.prototype, members);
            }
            Utils.Model = Model;
            var BaseModel = (function () {
                function BaseModel() {
                }
                /**
                 * Takes a snapshot of the model object and returns
                 * it as a plain JS object with primitive properties.
                 * The `toJSON` name wasn't a good choice because it
                 * conflicts with the .toJSON method which is supposed
                 * to return a string and is used by JSON.stringify to
                 * adjust the generated json string; a more accurate
                 * name would be `snapshot`.
                 */
                BaseModel.prototype.toJSON = function () {
                    return Utils.map(this, function fn(member) {
                        return Utils.isModel(member) ? member.toJSON() :
                            Utils.isCollection(member) ? Utils.map(member(), fn) :
                                Utils.isProperty(member) ? fn(member()) :
                                    Utils.isCommand(member) ? { enabled: !!member.enabled() } :
                                        Utils.isFunction(member) ? { enabled: true } :
                                            member;
                    });
                };
                BaseModel.prototype.toString = function (indent) {
                    if (indent === void 0) { indent = 4; }
                    return JSON.stringify(this.toJSON(), null, indent)
                        .replace(/{\s*\n\s*("\w+"):\s*(\w+)\s*\n\s*}/gm, '{ $1: $2 }');
                };
                __decorate([
                    Utils.hidden
                ], BaseModel.prototype, "toJSON", null);
                __decorate([
                    Utils.hidden
                ], BaseModel.prototype, "toString", null);
                return BaseModel;
            })();
            Utils.BaseModel = BaseModel;
            Model.prototype = BaseModel.prototype;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * A pattern is an object with a parsing function that
             * reads a given input string from a given position,
             * parses it and returns whatever it has parsed with
             * the position where the parsing ended. A composition
             * of such parsing function constitutes an LL(k) recursive
             * descent parser.
             *
             * @created Dec 2013
             * @blame antonkh
             */
            var Pattern = (function () {
                // the "private" modifier tells ts to create a class member with this name
                // and make an assignment in the constructor: this._exec = _exec
                function Pattern(_exec) {
                    this._exec = _exec;
                }
                // this method implements both signatures above; note that
                // the return type is "any" - that's the only common type
                // between T and [T, number]; also note the
                // default value for pos: ts determines the absence of the
                // parameter by comparing it with (void 0), not by checking
                // the number of arguments
                Pattern.prototype.exec = function (str, pos) {
                    if (pos === void 0) { pos = 0; }
                    var r = this._exec(str, pos);
                    if (arguments.length == 2)
                        return r;
                    if (!r || r[1] != str.length)
                        return null;
                    return r[0];
                };
                Pattern.prototype.then = function (fn) {
                    var _this = this;
                    return new Pattern(function (str, pos) {
                        // note, how the arrow function captures `this` from outside
                        var r = _this.exec(str, pos);
                        if (!r)
                            return null;
                        var res = r[0], end = r[1];
                        return [fn(res, str, pos, end), end];
                    });
                };
                Pattern.prototype.text = function () {
                    return this.then(function (res, str, pos, end) { return str.slice(pos, end); });
                };
                Pattern.prototype.select = function (key) {
                    return this.then(function (r) { return r[key]; });
                };
                // ts lacks a way to express the fact that this method
                // can  be called only if T is an array type, i.e. any[]
                Pattern.prototype.merge = function (sep) {
                    if (sep === void 0) { sep = ''; }
                    // ...so I had to trick ts and coerce T to any[]
                    return this.then(function (r) { return r.join(sep); });
                };
                Pattern.prototype.join = function (key, val) {
                    return this.then(function (r) {
                        var map = {};
                        for (var _i = 0, _a = r; _i < _a.length; _i++) {
                            var pair = _a[_i];
                            map[pair[key]] = pair[val];
                        }
                        return map;
                    });
                };
                return Pattern;
            })();
            Utils.Pattern = Pattern;
            /** txt = "abc" */
            function txt(text) {
                return new Pattern(function (str, pos) {
                    if (str.slice(pos, pos + text.length) == text)
                        return [text, pos + text.length];
                });
            }
            Utils.txt = txt;
            /** rgx = /[a-z]+/ */
            function rgx(regexp) {
                return new Pattern(function (str, pos) {
                    var m = regexp.exec(str.slice(pos));
                    if (m && m.index == 0)
                        return [m[0], pos + m[0].length];
                });
            }
            Utils.rgx = rgx;
            /** opt = [something] */
            function opt(p, defvalue) {
                return new Pattern(function (str, pos) { return p.exec(str, pos) || [defvalue, pos]; });
            }
            Utils.opt = opt;
            /** escaped-char = any-char ~ double-quote */
            function exc(pattern, except) {
                return new Pattern(function (str, pos) { return !except.exec(str, pos) && pattern.exec(str, pos); });
            }
            Utils.exc = exc;
            /** seq = abc def ghi ... */
            function seq() {
                var patterns = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    patterns[_i - 0] = arguments[_i];
                }
                return new Pattern(function (str, pos) {
                    var results = [];
                    for (var _i = 0; _i < patterns.length; _i++) {
                        var p = patterns[_i];
                        var r = p.exec(str, pos);
                        if (!r)
                            return;
                        results.push(r[0]);
                        pos = r[1];
                    }
                    return [results, pos];
                });
            }
            Utils.seq = seq;
            /** any = abc | def | ghi | ... */
            function any() {
                var patterns = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    patterns[_i - 0] = arguments[_i];
                }
                return new Pattern(function (str, pos) {
                    for (var _i = 0; _i < patterns.length; _i++) {
                        var p = patterns[_i];
                        var r = p.exec(str, pos);
                        if (r)
                            return r;
                    }
                });
            }
            Utils.any = any;
            /** rep = *pattern */
            function rep(pattern) {
                return new Pattern(function (str, pos) {
                    var r, results = [];
                    while (r = pattern.exec(str, pos)) {
                        results.push(r[0]);
                        pos = r[1];
                    }
                    return [results, pos];
                });
            }
            Utils.rep = rep;
            /** sep = [attr *(comma attr)] */
            function sep(pattern, separator) {
                var separated = seq(separator, pattern).select(1);
                var sequence = seq(pattern, rep(separated)).then(function (r) { return [r[0]].concat(r[1]); });
                return opt(sequence, []);
            }
            Utils.sep = sep;
            function quoted(lquote, rquote) {
                var esc = rgx(/\\./).then(function (str) { return str.slice(1); });
                var chr = any(esc, exc(rgx(/./), rquote));
                return seq(lquote, rep(chr), rquote).select(1).merge();
            }
            Utils.quoted = quoted;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Parses a URI, provides API to edit its parts and to stringify
             * the changed URI parts into a URI string:
             *
             *      uri = URI("http://contoso.com/data?tag=1");
             *      uri.scheme("https").port(443);
             *      uri == "https://contoso.com:443/data?tag=1");
             *
             * @property {String} scheme - e.g. "https"
             * @property {String} user - e.g. "johndoe:123"
             * @property {String} host - e.g. "contoso.com"
             * @property {String} port - e.g. "8081"
             * @property {String} path - e.g. "/ucwa/oauth/v1/me/name"
             * @property {String} query - e.g. "groupId=wnm176snmq=&tag=2"
             * @property {String} hash - e.g. "Introduction"
             *
             * @created antonkh, Dec 2013.
             */
            var URI = (function () {
                function URI(text) {
                    var _this = this;
                    var parts;
                    if (!(this instanceof URI))
                        return new URI(text);
                    parts = URI.pattern.exec((text || '') + '');
                    // the regexp is written in such a way, that it matches any string,
                    // so this exception is never thrown; this may change once the regexp
                    // is written more accurately
                    if (!parts)
                        throw new SyntaxError('Invalid URI: ' + text);
                    function bind(name) {
                        var prop = function (value) {
                            if (arguments.length == 0)
                                return (parts[name] || '') + '';
                            parts[name] = (value || '') + '';
                            return this;
                        };
                        prop.toString = function () {
                            return prop();
                        };
                        return prop;
                    }
                    this.scheme = bind('scheme');
                    this.user = bind('user');
                    this.host = bind('host');
                    this.port = bind('port');
                    this.path = bind('path');
                    this.query = bind('query');
                    this.hash = bind('hash');
                    this.query.get = function (arg) {
                        return URI.Query(_this.query())[arg];
                    };
                    this.query.set = function (arg, val) {
                        var q = URI.Query(_this.query());
                        q[arg] = val;
                        _this.query(q + '');
                    };
                }
                URI.prototype.toString = function () {
                    var prefixed = function (prefix, value) { return value ? prefix + value : ''; };
                    var authority = (!this.user() ? '' : this.user() + '@') + (this.host() || '') + prefixed(':', this.port());
                    return (this.scheme() ? this.scheme() + ':' : '') +
                        prefixed('//', authority) + this.path() +
                        prefixed('?', this.query()) +
                        prefixed('#', this.hash());
                };
                return URI;
            })();
            Utils.URI = URI;
            var URI;
            (function (URI) {
                URI.pattern = {
                    // RFC 3986 specifies an ABNF of URI, but since we don't have an ABNF parser and since that particular
                    // ABNF can be represented with a regular expression, I chose to write a regexp here. The mentioned ABNF
                    // has the following form: [scheme ":"] ["//" [user "@"] host [":" port]] path ["?" query] ["#" hash]
                    regexp: /^(?:([a-zA-Z][\w+-.]*):)?(?:\/\/(?:([^/@]*)@)?([^:/?#]*)(?:\:(\d*))?)?([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/,
                    exec: function (text) {
                        var p = this.regexp.exec(text);
                        return p && { scheme: p[1], user: p[2], host: p[3], port: p[4], path: p[5], query: p[6], hash: p[7] };
                    }
                };
                /**
                 * Parses the query part of the URI
                 * and lets stringify it back:
                 *
                 *      var uri = URI.Query("a=1&b=2&c=3");
                 *
                 *      uri.a = 111;
                 *      delete uri.b;
                 *      uri.d = 444;
                 *
                 *      uri == "a=111&c=3&d=444";
                 *
                 * @created Feb 2014
                 * @blame antonkh
                 */
                function Query(text) {
                    if (!(this instanceof Query))
                        return new Query(text);
                    var self = this;
                    if (Utils.isString(text)) {
                        Utils.foreach(text.split('&'), function (pair) {
                            var k, v, i = pair.indexOf('=');
                            if (i < 0) {
                                k = pair;
                                v = '';
                            }
                            else {
                                k = pair.slice(0, i);
                                v = pair.slice(i + 1);
                            }
                            if (k)
                                self[Utils.DataUri.decodeData(k)] = Utils.DataUri.decodeData(v);
                        });
                    }
                    else if (text) {
                        // note how clone gets rid of the object's prototype
                        Utils.foreach(Utils.clone(text), function (v, k) {
                            self[k] = v;
                        });
                    }
                }
                URI.Query = Query;
                Query.prototype.toString = function () {
                    var pairs = [];
                    // note how clone(this) gets rid of this.toString
                    Utils.foreach(Utils.clone(this), function (v, k) {
                        pairs.push(v ?
                            Utils.DataUri.encodeData(k) + '=' + Utils.DataUri.encodeData(v) :
                            Utils.DataUri.encodeData(k));
                    });
                    return pairs.join('&');
                };
            })(URI = Utils.URI || (Utils.URI = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Parses or constructs a data uri string compliant with RFC 2397.
             *
             * UCWA server sends instant messages in the data uri format and
             * this class can be involved to parse them.
             *
             * Data URLs have to be parsed because SkypeWeb needs to extract separate
             * attributes from them and this cannot be done with a regular expression.
             *
             * @example
             *
             *      var uri = DataUri('data:text/plain;charset=utf-8,How+are+you%3f');
             *
             *      uri.mime == 'text/plain';
             *      uri.attributes.charset == 'utf-8';
             *      uri.data == 'How are you?';
             *
             * @created antonkh, Dec 2013
             */
            function DataUri(string) {
                var parts = DataUri.pattern.exec(string);
                if (!parts)
                    throw new SyntaxError('Invalid data URL: ' + string);
                return parts;
            }
            Utils.DataUri = DataUri;
            var DataUri;
            (function (DataUri) {
                function encodeData(data) {
                    return encodeURIComponent(data).replace(/%20/gm, '+');
                }
                DataUri.encodeData = encodeData;
                function decodeData(data) {
                    return decodeURIComponent(data.replace(/\+/gm, ' '));
                }
                DataUri.decodeData = decodeData;
                ;
            })(DataUri = Utils.DataUri || (Utils.DataUri = {}));
            /**
             * Parsing rules (ABNF) from RFC 2397 and RFC 2045:
             *
             *      dataurl     := "data:" [ mediatype ] [ ";base64" ] "," data
             *      mediatype   := [ token "/" token ] *( ";" parameter )
             *      data        := *urlchar
             *      parameter   := attribute "=" value
             *      attribute   := token ; Matching of attributes is ALWAYS case-insensitive.
             *      value       := token / quoted-string
             *      token       := 1*<any (US-ASCII) CHAR except SPACE, CTLs, or tspecials>
             *      tspecials   :=  "(" / ")" / "<" / ">" / "@" / "," / ";" / ":" / "\" / <"> / "/" / "[" / "]" / "?" / "="
             */
            var DataUri;
            (function (DataUri) {
                var token = Utils.rgx(/[^()<>@,;:\\\x22/\[\]?=\s]+/);
                var mime = Utils.seq(token, Utils.txt('/'), token).merge();
                var data = Utils.rgx(/[^\uffff]*/).then(DataUri.decodeData);
                var str = Utils.quoted(Utils.txt('"'), Utils.txt('"'));
                var val = Utils.seq(Utils.rgx(/\s*=\s*/), Utils.any(str, token)).select(1);
                var attr = Utils.seq(Utils.rgx(/\s*;\s*/), token, Utils.opt(val, true));
                DataUri.pattern = Utils.seq(Utils.txt('data:'), Utils.opt(mime), Utils.rep(attr).join(1, 2), Utils.rgx(/\s*,\s*/), data)
                    .then(function (_a) {
                    var m = _a[1], a = _a[2], d = _a[4];
                    return ({ mime: m, attributes: a, data: d, base64: !!a['base64'] });
                });
            })(DataUri = Utils.DataUri || (Utils.DataUri = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Parses a CSS style of the following form:
             *
             *      position: fixed;
             *      color: red;
             *      font: Arial 10px;
             *
             * @created Mar 2015
             * @blame antonkh
             */
            function Style(text) {
                if (!(this instanceof Style))
                    return new Style(text);
                var parsed = Style.pattern.exec(text);
                if (!parsed)
                    throw new SyntaxError('Invalid CSS style: ' + text);
                Utils.extend(this, parsed);
            }
            Utils.Style = Style;
            /**
             * Parsing rules (ABNF):
             *
             *      style       := kvpair *( ";" kvpair ) ";"?
             *      kvpair      := name ":" 1*value
             *      name        := <dashes are allowed in names>
             *      value       := string / measure / name / color
             *      string      := <single-quoted or double-quoted string>
             *      measure     := number ["%" / "pt" / "px" / "em"]
             *      number      := <floating point number>
             *      color       := "#" 1*hexdigit
             *
             */
            var Style;
            (function (Style) {
                // parsing a style could've been as simple as splitting
                // the input at ";" symbols and then at ":" symbols if
                // css didn't allow quoted and double-quoted strings in
                // style values, i.e. font: "Arial";
                var wsp = Utils.rgx(/[\x00-\x20]+/);
                var wspComma = Utils.rgx(/[,\x00-\x20]+/);
                var color = Utils.rgx(/#[\da-fA-F]+/i); // in css #f80 = #ff8800
                var number = Utils.rgx(/[+-]?(\d+[\.]?\d*|\.\d+)/); // that's a bit stricter than needed
                var measure = Utils.seq(number, Utils.opt(Utils.rgx(/%|[a-z]+/i))).text(); // ie. 12.3px
                var string = Utils.any(Utils.quoted(Utils.txt('"'), Utils.txt('"')), Utils.quoted(Utils.txt("'"), Utils.txt("'")));
                var name = Utils.rgx(/[a-z][a-z-]*[a-z]|[a-z]/i); // dashes are allowed only inside the name
                var value = Utils.any(measure, string, name, color).text(); // url('...')-like things aren't handled
                var kvpair = Utils.seq(name.text(), Utils.opt(wsp), Utils.txt(':'), Utils.opt(wsp), Utils.sep(value, wspComma));
                var separator = Utils.seq(Utils.opt(wsp), Utils.txt(';'), Utils.opt(wsp));
                // another option would be to allow empty styles between semicolons:
                // this would simplify this pattern, but the .join(...) below will have
                // to become more complicated in order to handle empty styles
                var style = Utils.seq(Utils.sep(kvpair, separator), Utils.opt(separator)).select(0);
                // well, .join(...) won't work if the same style name appears twice,
                // which is allowed in css and means that the style definition is
                // split across multiple lines
                Style.pattern = style.join(0, 4);
            })(Style = Utils.Style || (Utils.Style = {}));
            Utils.setHiddenProperty(Style.prototype, 'toString', function () {
                var name, lines = [], styles = this;
                for (name in styles)
                    lines.push(name + ':' + styles[name].join(' '));
                return lines.join(';');
            });
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var entities = {
                'lt': '<',
                'gt': '>',
                'amp': '&',
                'nbsp': '\xA0',
                'quot': '"'
            };
            /**
             * Unescapes XML entities, such as &amp; and &#160;.
             * Such escaped entities can be found in XML tags.
             *
             *      unescapeXml('123 &amp; 456') == '123 & 456';
             *
             * @created antonkh, Feb 2014
             */
            function unescapeXml(escaped) {
                return escaped.replace(/&(#?\w+);/gm, function (str, num) {
                    return num.charAt(0) == '#' ? String.fromCharCode(+num.slice(1)) : entities[num];
                });
            }
            /**
             * Reconstitutes a tree of XML nodes from their textual representation.
             *
             * @method {String} name - Returns the tag name of the node.
             * @method {String} text - Returns the text content of the node.
             * @method {String} attr - Returns value of the given attribute.
             *
             * @member {Map<String, String>} attrs - All attributes as a dictionary.
             * @member {XmlNode[]} nodes - All inner nodes.
             *
             * @method {XmlNode} selectOne - Searches for a specific child node.
             *
             * @created antonkh, Feb 2014
             */
            function XmlNode(input) {
                if (!(Utils.isString(input) || input && input.ast))
                    throw new Error('Invalid argument: ' + input);
                if (!(this instanceof XmlNode))
                    return new XmlNode(input);
                var ast, err;
                try {
                    ast = input.ast || XmlNode.pattern.exec(input); // AST of the XML
                    if (!ast)
                        throw void 0;
                }
                catch (reason) {
                    err = new SyntaxError('Invalid XML: ' + input);
                    err.reason = reason;
                    throw err;
                }
                var attrs = ast.attrs || {};
                var nodes = (ast.nodes || []).map(function (node) {
                    return XmlNode({ ast: Utils.isString(node) ? { text: node } : node });
                });
                var join = function (text, node) { return text + node.text(); };
                var name = function () { return ast.name; };
                var text = function () { return ast.text || nodes.reduce(join, ''); };
                this.attrs = attrs;
                this.nodes = nodes;
                this.name = name;
                this.text = text;
            }
            Utils.XmlNode = XmlNode;
            XmlNode.prototype.toString = function () {
                var attrs = '', content = '', root = this, name = root.name();
                Utils.foreach(root.attrs, function (val, key) {
                    attrs += ' ' + key;
                    if (!Utils.isVoid(val))
                        attrs += '="' + val.replace(/\x22/gm, '&quot;') + '"';
                });
                Utils.foreach(root.nodes, function (node) {
                    content += node;
                });
                content = content || root.text().replace(/</gm, '&lt;').replace(/>/gm, '&gt;');
                return !name ? content :
                    !content ? '<' + name + attrs + '/>' :
                        '<' + name + attrs + '>' + content + '</' + name + '>';
            };
            XmlNode.prototype.attr = function (name) {
                Utils.assert(name in this.attrs, 'Attribute does not exist: ' + this.name() + '.' + name);
                return this.attrs[name];
            };
            XmlNode.prototype.selectOne = function (name, attrs) {
                var nodes = Utils.filter(this.nodes, Utils.isFunction(name) ? name : function (node) {
                    var attr, lca;
                    // attribute names are lower cased by the parser
                    if (attrs) {
                        for (attr in attrs) {
                            lca = attr.toLowerCase();
                            if (attrs[lca] != node.attrs[lca])
                                return false;
                        }
                    }
                    // node names are lower cased by the parser
                    return node.name() == name.toLowerCase();
                });
                Utils.assert(nodes.length == 1, 'Single node expected: ' + name);
                return nodes[0];
            };
            /**
             * Parsing rules (ABNF) for the XML subset supported by this implementation:
             *
             *      xml-node    := open-tag *(xml-node / text) close-tag / empty-tag
             *      open-tag    := "<" name *attr ">"
             *      close-tag   := "</" name ">"
             *      empty-tag   := "<" name *attr "/>"
             *      attr        := name ["=" quoted-string]
             *      text        := <an xml-escaped text>
             *      name        := <a case insensitive name>
             */
            var XmlNode;
            (function (XmlNode) {
                var wsp = Utils.rgx(/[\x00-\x20]*/);
                var qstr = Utils.rgx(/\x22[^\x22]*\x22/).then(function (s) { return s.slice(+1, -1); });
                var rawval = Utils.rgx(/[^\s<>\x22]+/);
                var value = Utils.any(qstr, rawval).then(unescapeXml);
                var text = Utils.rgx(/[^<]+/m).then(unescapeXml);
                var name = Utils.rgx(/[\w:-]+/).then(function (s) { return s.toLowerCase(); });
                var attr = Utils.seq(name, Utils.opt(Utils.seq(wsp, Utils.txt('='), wsp, value).select(3)));
                var attrs = Utils.sep(attr, wsp).join(0, 1);
                var opentag = Utils.seq(Utils.txt('<'), wsp);
                var closetag = Utils.seq(wsp, Utils.txt('>'));
                var comment = Utils.rgx(/<!--[\s\S]*?-->/m).then(function (r) { return ({ name: '--' }); });
                var open = Utils.seq(opentag, name, wsp, attrs, closetag).then(function (r) { return ({ name: r[1], attrs: r[3] }); });
                var empty = Utils.seq(opentag, name, wsp, attrs, Utils.seq(wsp, Utils.txt('/>'))).then(function (r) { return ({ name: r[1], attrs: r[3] }); });
                var close = Utils.seq(Utils.txt('</'), wsp, name, closetag).select(2);
                var node = new Utils.Pattern(function (str, pos) { return XmlNode.pattern.exec(str, pos); });
                var full = Utils.seq(open, Utils.rep(Utils.any(node, text, comment)), close).then(function (_a) {
                    var open = _a[0], nodes = _a[1], close = _a[2];
                    if (open.name != close)
                        throw new SyntaxError('</' + close + '> does not match <' + open.name + '>');
                    return { name: close, nodes: nodes, attrs: open.attrs };
                });
                XmlNode.pattern = Utils.any(full, empty);
            })(XmlNode = Utils.XmlNode || (Utils.XmlNode = {}));
            /**
             * @param {String} src - XML representation of the document.
             *
             * @member {XmlNode} root
             */
            function XmlDoc(src) {
                return {
                    // <?xml version="1.0" encoding="utf-8"?>
                    // needs to be removed before parsing XML
                    root: XmlNode(Utils.trim(src.replace(/^<\?.+?\?>/, '')))
                };
            }
            Utils.XmlDoc = XmlDoc;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var rxSafeTags = /^(body|b|i|u|s|span|table|tr|td|th|br|div|hr|p|h\d|font|a)$/i;
            var rxSafeAttrs = /^(style|width|height|color|face|size|href)$/i;
            var rxSafeStyles = /^(font(-[a-z]+)?|margin(-[a-z]+)?|line(-[a-z]+)?|color)$/i;
            function parseHtml(html) {
                // Since a linebreak <br> is a void element, which doesn't require a closing tag, it violates
                // the parsing pattern for XML node. Have to replace any single linebreak with a space here.
                // Other void elements (such as <hr>, <img>, <input>, etc.), are not considered here, since
                // the lync client doesn't send them.
                var s = html.replace(/<(br|meta)\b(.*?)\/?>/gim, '<$1$2/>');
                s = /^\s*<html\b[\s\S]*<\/html>\s*$/igm.test(s) ?
                    Utils.trim(s) : '<html><body>' + s + '</body></html>';
                return Utils.XmlNode(s).selectOne('body');
            }
            //#region convertTextToHtml
            /**
             * Escapes certain HTML (XML) characters to make a text input
             * usable as a HTML string. Consider the case when e remote party
             * sends a text/plain message with "<script>alert(1)</script>"
             * content and this text needs to be shown in HTML.
             */
            function convertTextToHtml(text) {
                return text
                    .replace(/[<>&;#/]/gm, function (chr) { return '&#' + chr.charCodeAt(0) + ';'; })
                    .replace(/\r\n|\n/gm, function () { return '<br>'; });
            }
            Utils.convertTextToHtml = convertTextToHtml;
            //#endregion
            //#region convertHtmlToText
            /**
             * Extracts text from html. This is done by parsing the given html
             * and merging all text nodes from it. It's useful to get the plain
             * text representation of an html message if the only format known is
             * html.
             *
             * @created antonkh, Feb 2014
             */
            function convertHtmlToText(html) {
                return parseHtml(html.replace(/<br\s*\/?>/gi, '\x0D\x0A')
                    .replace(/&(nbsp|#160);/gi, '\x20')).text();
            }
            Utils.convertHtmlToText = convertHtmlToText;
            //#endregion convertHtmlToText
            //#region sanitizeHtml
            /**
             * Removes everything that can be used in an XSS attack.
             *
             * This is a basic sanitizer based on allow list. It first parses
             * html and css and then removes all not listed html tags, attributes
             * and css styles. This sanitizer is necessary to prevent XSS if
             * the UI developer makes a very common mistake:
             *
             *      document.getElementById(...).innerHTML = message.html();
             *
             * If the message html contains scripts or specially styled html tags,
             * that UI will be subject to XSS attacks.
             *
             * Obviously, there are quite safe html messages that will be corrupted
             * by this sanitizer, but their fraction is assumed to be small and the
             * allow list can be extended any time later.
             *
             * @created Mar 2015
             * @blame antonkh
             */
            function sanitizeHtml(html) {
                function removeUnsafeAttrs(root) {
                    var name, attrs = root.attrs;
                    for (name in attrs) {
                        if (!rxSafeAttrs.test(name))
                            delete attrs[name];
                    }
                }
                function removeUnsafeStyles(root) {
                    var styles, name, str = root.attrs.style;
                    if (str) {
                        styles = Utils.Style(str);
                        for (name in styles) {
                            if (!rxSafeStyles.test(name))
                                delete styles[name];
                        }
                        root.attrs.style = styles + '';
                    }
                }
                function sanitize(root) {
                    var i, name, nodes = root.nodes;
                    removeUnsafeAttrs(root);
                    removeUnsafeStyles(root);
                    for (i = 0; i < nodes.length; i++) {
                        name = nodes[i].name();
                        if (name && !rxSafeTags.test(name))
                            Utils.removeAt(nodes, i--);
                        else
                            sanitize(nodes[i]);
                    }
                    return root;
                }
                try {
                    return html && sanitize(parseHtml(html)).nodes.join('');
                }
                catch (_) {
                    // Someone sent a broken html? This might be an XSS attack.
                    // But in case it's not, present at least the raw html contents
                    // with all html disabled: the message may contain something
                    // important to the user.
                    return disableHtmlInText(html);
                }
            }
            Utils.sanitizeHtml = sanitizeHtml;
            //#endregion
            //#region disableHtmlInText
            /**
             * An attacker may send a message in the text/plain format with html inside:
             * the html can either aim at injecting a script into the destination page
             * or inject certain tags that would break the layout or show a popup window.
             * The problem applies not only to messages that can be sent in a conversation,
             * but also to all text data, such as a contact's note, a distribution group's
             * title, a conversation's subject and so on: they all can potentially contain
             * harmful html. Many webapps that uses the SDK contain a typical mistake:
             *
             *  document.getElementById("text123").innerHTML = message.text();
             *
             * In this case the attacker will be able to inject a script into such page.
             * To prevent this, the SDK alters all the text that comes from the server and
             * can be displayed in UI in such a way, that the text's appearance isn't affected,
             * but all potential harmful html constructs are disabled.
             *
             * @created Mar 2015
             * @blame antonkh
             */
            function disableHtmlInText(text) {
                // U+2329 and U+232A are misc technical punctuation symbols
                return text && text.replace(/</gm, '\u2329').replace(/>/gm, '\u232a');
            }
            Utils.disableHtmlInText = disableHtmlInText;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Represents the "WWW-Authenticate" HTTP header
             * that contains information about how to get the auth token.
             * Here is an example of how it may look:
             *
             *      Basic realm="johndoe@contoso.com",Digest realm="testrealm@host.com", qop="auth,auth-int"
             *
             * @param {string} text - The value of the "WWW-Authenticate" header.
             *
             * @example
             *
             *      var auth = WWWAuthenticateHeader(
             *          'Bearer client_id="0", uri="qq://login" + '\n' +
             *          'MsRtcOAuth href="qq://login/token",grant_type="urn:microsoft.rtc:passive,urn:microsoft.rtc:anonmeeting"');
             *
             *      auth.Bearer.client_id === "0";
             *      auth.Bearer.uri === "qq://login";
             *      auth.MsRtcOAuth.href === "qq://login/token";
             *      auth.MsRtcOAuth.grant_type === "urn:microsoft.rtc:passive,urn:microsoft.rtc:anonmeeting";
             *
             * @created antonkh, Dec 2013
             */
            function WWWAuthenticateHeader(text) {
                var parts = WWWAuthenticateHeader.pattern.exec(text || '');
                if (parts)
                    return parts;
                throw new SyntaxError('Invalid WWW-Authenticate header:\n' + text);
            }
            Utils.WWWAuthenticateHeader = WWWAuthenticateHeader;
            /**
             *  ABNF rules for the WWW-Authenticate header:
             *
             *  www-auth        := *( challenge )
             *  challenge       := scheme *( param )
             *  param           := param-name "=" param-value
             *  scheme          := token
             *  param-name      := token
             *  param-value     := quoted-string
             */
            var WWWAuthenticateHeader;
            (function (WWWAuthenticateHeader) {
                var comma = Utils.rgx(/[\s,]*/);
                var name = Utils.rgx(/[^\s,=]+/);
                var value = Utils.quoted(Utils.txt('"'), Utils.txt('"'));
                var attr = Utils.seq(name, Utils.rgx(/\s*=\s*/), value);
                var attrs = Utils.sep(attr, comma).join(0, 2);
                var challenge = Utils.seq(name, comma, attrs);
                WWWAuthenticateHeader.pattern = Utils.sep(challenge, comma).join(0, 2);
            })(WWWAuthenticateHeader = Utils.WWWAuthenticateHeader || (Utils.WWWAuthenticateHeader = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Unlike a regular dictionary which maps a string
             * to something, WeakMap maps an object to something.
             * This is used to attach hidden members to an object
             * without modifying that object. See ES6 WeakMap for
             * a full spec.
             *
             * This class is an incomplete and inefficient polyfill
             * for the ES6 WeakMap.
             *
             * @created Jul 2015
             * @blame antonkh
             */
            var WeakMap = (function () {
                /**
                 * @param description - A short string to simplify debugging.
                 *
                 *      If a wm attached a property to an object, then in the
                 *      debugger this will be shown as a hidden property:
                 *
                 *      Object {
                 *          foo: 123,
                 *          "name:1b44hc": 456
                 *      }
                 */
                function WeakMap(description) {
                    if (description === void 0) { description = 'wm'; }
                    // each wm must have its own tag because
                    // two wms can attach properties to the
                    // same object
                    this._sTag = Utils.Symbol(description, true);
                }
                WeakMap.prototype.get = function (obj) {
                    return obj[this._sTag];
                };
                WeakMap.prototype.set = function (obj, val) {
                    Utils.setHiddenProperty(obj, this._sTag, val);
                };
                WeakMap.prototype.has = function (obj) {
                    return this._sTag in obj;
                };
                WeakMap.prototype.delete = function (obj) {
                    delete obj[this._sTag];
                };
                return WeakMap;
            })();
            Utils.WeakMap = WeakMap;
            // if WeakMap is implemented natively by the current
            // JS engine, use it instead of the clumsy polyfill
            Utils.WeakMap = !Web.isUnitTested && Web.window['WeakMap'] || WeakMap;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var Http;
            (function (Http) {
                ;
                function isSuccess(status) {
                    return 200 <= status && status < 300;
                }
                Http.isSuccess = isSuccess;
            })(Http = Utils.Http || (Utils.Http = {}));
            //#region HttpHeaders
            /**
             * This is a collection of HTTP headers.
             * jQuery returns HTTP headers as a string, so it needs
             * to be parsed before use.
             *
             * @param {string} text - A multiline string with all the headers.
             *
             * @method {string} get(name) - Returns the value associated with the header.
             * @method add(name, value) - Adds a new value for a header.
             * @method {string} toString - Returns the textual representation of the headers.
             *
             * @example
             *
             *      var headers = HttpHeaders('Authorization: Bearer cwt=abcdef\nH: Qwerty\n\n');
             *      headers.get('authorization') == 'Bearer cwt=abcdef';
             *      headers.get('h') == 'Qwerty';
             *
             * @created antonkh, Jun 2013
             */
            function HttpHeaders(text) {
                /**
                 * Parses the multi-line string containing the headers.
                 */
                function parse(text) {
                    Utils.assert(Utils.isString(text));
                    var lines = text.split('\r\n');
                    var sep, name, value, line;
                    for (var i = 0; i < lines.length; i++) {
                        if (line = Utils.trim(lines[i])) {
                            sep = line.indexOf(':');
                            // silently skip invalid headers
                            if (sep >= 0) {
                                name = Utils.trim(line.substr(0, sep));
                                value = Utils.trim(line.substr(sep + 1));
                                add(name, value);
                            }
                        }
                    }
                }
                /**
                 * Copies headers from another list of headers.
                 */
                function copy(hdrs) {
                    Utils.assert(Utils.isDictionary(hdrs));
                    for (var name in hdrs)
                        add(name, hdrs[name] + '');
                }
                /**
                  * Gets the value of the header.
                  *
                  * @param {string} name
                  * @returns {string}
                  */
                function get(name) {
                    Utils.assert(Utils.isNotEmptyString(name));
                    return headers[name.toLowerCase()];
                }
                /**
                 * Adds a new value to a header.
                 *
                 * @param {string} name - The name of the header.
                 * @param {string} value - The new value for the header.
                 */
                function add(name, value) {
                    Utils.assert(Utils.isNotEmptyString(name));
                    name = name.toLowerCase();
                    if (headers[name])
                        headers[name] += '\n' + value;
                    else
                        headers[name] = value;
                }
                /**
                 * Returns a text representation of the headers.
                 *
                 * @returns {string}
                 */
                function stringify() {
                    var i, name, values, text = '';
                    for (name in headers) {
                        values = headers[name].split('\n');
                        for (i = 0; i < values.length; i++)
                            if (values[i])
                                text += name + ': ' + values[i] + '\r\n';
                    }
                    return text + '\r\n';
                }
                var headers = {};
                if (Utils.isNotEmptyString(text))
                    parse(text);
                else if (Utils.isDictionary(text))
                    copy(text);
                return {
                    get: get,
                    add: add,
                    toString: stringify
                };
            }
            Utils.HttpHeaders = HttpHeaders;
            //#endregion HttpHeaders    
            //#region ContentTypeHeader
            /**
             * Parses a value of the Content-Type header. An example of such as header:
             *
             *      Content-Type: multipart/related; type="text/plain"; charset=utf-8; boundary=123
             *
             * @param {String} value - The text value of the Content-Type header.
             *
             * @member {String} mimeType - e.g. "multipart/related"
             * @member {Object} attributes - e.g. {charset:"utf-8"}
             */
            function ContentTypeHeader(value) {
                // DataUri already has a parser for mime types
                var dataUri = Utils.DataUri('data:' + value.replace(/\s/g, '') + ',');
                return {
                    mimeType: dataUri.mime,
                    attributes: dataUri.attributes
                };
            }
            Utils.ContentTypeHeader = ContentTypeHeader;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
// Right, this is nothing to do with LINQ,
// but I couldn't find a better name.
// This module contains all utils that we
// use to deal with simple objects and arrays.
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            //#region getOption
            function getOption(values, name, defaultValue) {
                return name in values ? values[name] : defaultValue;
            }
            Utils.getOption = getOption;
            //#endregion
            //#region keys
            /**
             * This is a polyfill for Object.keys that doesn't exist in IE 8.
             * To avoid possible interference with other JS code, it's better
             * to not override global function, such as Object.keys.
             */
            function keys(obj) {
                var names;
                if (Object.keys) {
                    names = Object.keys(obj);
                }
                else {
                    names = [];
                    Utils.foreach(obj, function (val, key) {
                        names.push(key);
                    });
                }
                return names;
            }
            Utils.keys = keys;
            //#endregion
            //#region all
            /**
             * Checks whether a condition is satisfied for a set of items.
             */
            function all(items, condition) {
                // `foreach` could be used here with a `throw` statement
                // to simulate a `break` in a regular `for` loop, but there
                // reasons to not do this:
                //
                //  1. at the moment `all` doesn't need to support arrays
                //  2. throw/break will be executed in almost every call to `all`
                //  3. `throw` would significantly degrade performance
                // 
                for (var name in items)
                    if (!condition(items[name], name))
                        return false;
                return true;
            }
            Utils.all = all;
            //#endregion
            //#region namespace
            /**
             * Creates or extends a namespace.
             *
             * @param {String} path - e.g. "Skype.Web.Utils"
             * @param {Object} [members] - Members to be added to the namespace.
             * @param {Object} [root=window]
             *
             * @returns {Object} - The created namespace.
             */
            function namespace(path, members, root) {
                var i, ns = root || Web.window, names = path.split('.');
                for (i = 0; i < names.length; i++)
                    ns = ns[names[i]] || (ns[names[i]] = {});
                for (i in members) {
                    Utils.assert(!(i in ns), path + '.' + i + ' already exists');
                    ns[i] = members[i];
                }
                return ns;
            }
            Utils.namespace = namespace;
            //#endregion
            //#region take
            /** take({ a:1, b:2 }, "a") -> { a:1 } */
            function take(object, key) {
                var result = {};
                result[key] = object[key];
                return result;
            }
            Utils.take = take;
            //#endregion
            //#region filter
            /**
             * Creates a subset with all items that pass the test implemented by the
             * callback. For an array argument this subset is a new array, for a dictionary
             * argument is a new dictionary.
             *
             * @example
             *      var res = filter([11, 22, 33], function (value) {
             *          return value > 20;
             *      });
             *      // res is [22, 33]
             *
             * @example
             *      var res = filter({a:1, b:2, c:3, d:4}, function (value, key) {
             *          return value > 3 || key < 'b';
             *      });
             *      // res is {a:1, d:4}
             */
            function filter(items, callback) {
                var res;
                if (Utils.isArray(items)) {
                    res = [];
                    Utils.foreach(items, function (val, key) {
                        if (callback(val, key))
                            res.push(val);
                    });
                }
                else {
                    res = {};
                    Utils.foreach(items, function (val, key) {
                        if (callback(val, key))
                            res[key] = val;
                    });
                }
                return res;
            }
            Utils.filter = filter;
            //#endregion        
            //#region size
            /**
             * Returns the size of a collection (array or dictionary).
             */
            function size(items) {
                Utils.assert(Utils.isArray(items) || Utils.isDictionary(items));
                return Utils.isArray(items) ? items.length :
                    keys(items).length;
            }
            Utils.size = size;
            /**
             * Determines whether a collection (array or dictionary) contains an element
             * that satisfies a given condition and returns this element or null if no
             * such element is found
             */
            function find(items, predicate) {
                var i, res = {};
                if (Utils.isArray(items)) {
                    for (i = 0; i < items.length; ++i) {
                        if (predicate(items[i], i))
                            return items[i];
                    }
                }
                else {
                    for (i in items) {
                        if (predicate(items[i], i)) {
                            res[i] = items[i];
                            return res;
                        }
                    }
                }
                return null;
            }
            Utils.find = find;
            /**
             * Determines whether an array contains an element that satisfies a given
             * condition and returns the index of this element or -1 if no such element
             * is found. It is basically the combination of find and indexOf.
             */
            function findIndex(items, callback) {
                for (var i = 0; i < items.length; ++i) {
                    if (callback(items[i], i))
                        return i;
                }
                return -1;
            }
            Utils.findIndex = findIndex;
            //#endregion
            //#region setEqual
            /**
             * Compares two sets and determines if they are equal by checking if each is a subset of the other
             *
             * @param {Array} set1 - First set to compare
             * @param {Array} set2 - Second set to compare
             *
             * @returns {boolean} - indicates where the first and second sets are equal
             */
            function setEqual(set1, set2) {
                function isSubSet(a, b) {
                    for (var i = 0; i < a.length; i++) {
                        if (Utils.indexOf(b, a[i]) < 0) {
                            return false;
                        }
                    }
                    return true;
                }
                return isSubSet(set1, set2) && isSubSet(set2, set1);
            }
            Utils.setEqual = setEqual;
            //#endregion
            //#region removeAll
            /**
             * Removes all items matching the given criteria.
             */
            function removeAll(items, test) {
                var keys = [];
                for (var key in items)
                    if (test(items[key]))
                        keys.push(key);
                for (var _i = 0; _i < keys.length; _i++) {
                    var key = keys[_i];
                    delete items[key];
                }
            }
            Utils.removeAll = removeAll;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Implements a sequential state machine, i.e. the unidirectional state machine that advances
             * through an ordered set of states until it reaches the target state
             *
             * @param {Number} uninitState - Uninitialized state.
             *
             * @method defineState(state, handler)
             *
             *      Defines a state and an action needed to reach
             *      this state from the previous state.
             *
             * @method advanceTo(state) - Advances the state machine to the given state.
             * @method reset() - Reset the state machine to the uninitialized state.
             * @property {Number} state - The current state of the state machine.
             * @property {Number} target - The target state of the state machine.
             *
             * @example
             *
             *    var State = Enum('Zero', 'One', 'Two');
             *    var sm = SequentialStateMachine(State.Zero);
             *    sm.defineState(State.One, function () {
             *              // actions to get to One
             *              return 'Ok';
             *          });
             *    sm.defineState(State.Two, function () {
             *              // actions to get to Two
             *              return send('GET', '/me/name');
             *          });
             *
             *    sm.advanceTo(State.Two).then(function () {
             *          assert(sm.state() == State.Two);
             *    });
             *
             * @created August 2013
             * @blame sosobov
             */
            function SequentialStateMachine(uninitState) {
                var current = Utils.Property({ value: uninitState }), target = Utils.Property({ value: uninitState }), handlers = {}, task, // advanceTo returns task.promise
                promise; // the current pending operation returned by handler[i]
                /**
                 * Defines machine actions for the state
                 *
                 * @param {Number} state
                 * @param {Function} handler
                 *
                 *      Action to be executed to reach this state from the previous one.
                 *      This function may return a value, a promise or throw an exception.
                 */
                function defineState(state, handler) {
                    Utils.assert(!handlers[state]);
                    Utils.assert(state > uninitState);
                    Utils.assert(Utils.isFunction(handler));
                    handlers[state] = Utils.async(handler);
                }
                /**
                 * Reset the state machine to the uninitialized state
                 *
                 *      The function will set the state machine to the uninitialized state,
                 *      keep all defined hanlders, and cancel the pending promise if there is one.
                 */
                function reset() {
                    current(uninitState);
                    target(uninitState);
                    // promise already set as null if it is cancelled or resolved
                    if (promise)
                        cancel(Utils.Exception('Reset'));
                    task = null;
                    promise = null;
                }
                /**
                 * Advances the state machine to the given state
                 *
                 * @param {Number} state - The desired state.
                 */
                function advanceTo(state) {
                    Utils.check(state >= target(), 'InvalidTargetState', {
                        currentTarget: target(),
                        requestedTarget: state
                    });
                    if (state == current())
                        return;
                    if (state > target()) {
                        task = new Utils.Task('advancing to target state ' + state, {
                            cancel: cancel
                        });
                        target.set(state);
                        next(task);
                    }
                    return task.promise;
                }
                function cancel(reason) {
                    // this will invoke task.reject
                    promise.cancel(reason);
                    promise = null;
                }
                function next(task) {
                    // an existing promise signals that state transition is in progress
                    if (promise)
                        return;
                    var nextState = current() + 1;
                    task.status('advancing to state ' + nextState);
                    // the returned promise can be already resolved
                    // or rejected: to handle this case its "then"
                    // method is invoked separately
                    promise = handlers[nextState].call(null);
                    promise.then(function (result) {
                        promise = null;
                        current.set(nextState);
                        if (current() < target())
                            next(task);
                        else
                            task.resolve(result);
                    }, function (error) {
                        promise = null;
                        task.reject(error);
                    });
                }
                return {
                    defineState: defineState,
                    reset: reset,
                    advanceTo: Utils.async(advanceTo),
                    state: current.asReadOnly(),
                    target: target.asReadOnly()
                };
            }
            Utils.SequentialStateMachine = SequentialStateMachine;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            //#region repeat
            /**
             * Repeats an asynchronous function.
             *
             * Repeats a function asynchronously until the returned promise is canceled or
             * a non-recoverable error is encountered. The control over what errors can be
             * recovered can be handled (for async functions only!) by providing a failure
             * handler and preventing the exception from bubbling up which will make it
             * eligible for the next repeat cycle. The logic of `repeat` is functionally
             * equivalent to:
             *
             *      while (true)
             *          await fn();
             *
             * @blame antonkh
             */
            function repeat(fn) {
                // With the await keyword the repeat function can be rewritten as:
                //
                //  function repeat(fn) {
                //      await fn();
                //      await repeat(fn);
                //  }
                //
                // The last statement is a proper tail call and doesn't need to create an
                // extra frame on the stack or it's asynchronous equivalent - a new promise
                // in the chain of promises. If the n-th call to repeat returns a promise p(n)
                // and fn always succeeds, repeat creates an endless chain of promises attached
                // one to another:
                //
                //  p(0) <- p(1) <- p(2) <- ... <- p(n - 1) <- p(n) <- fn()
                //
                // It can be seen that all intermediate promises from p(1) to p(n - 1) can be
                // removed from the chain:
                //
                //  p(0) <- p(n) <- fn()
                //
                // This eliminates the memory leak. This optimization consists of two simpler
                // optimizations:
                //
                //  (p0 <- p1 <- p2) => (p0 <- p2 -> p1) => (p0 <- p2), (p1)
                //
                // The first step removes the intermediate promise p1 by lifting p0 by one level
                // and the second step discovers that nobody will ever invoke p1.then, so p1 is
                // simply detached from p2. Then p1 gets gc'd. To make the second step possible,
                // p1 - the last promise returned from inside .then - needs to be marked somehow.
                return Utils.async(fn)().then(function () {
                    return Utils.extend(repeat(fn), (_a = {}, _a[Utils.Task.sLocked] = true, _a));
                    var _a;
                });
            }
            Utils.repeat = repeat;
            //#endregion
            //#region repeatAndExit
            /**
             * Adds to repeat(...) a convenient way to return a value.
             *
             * The only way to terminate an async repeat(...) loop is to
             * throw an exception. In some cases it's useful to end an async loop
             * with a result. This function solves this by wrapping the result
             * into an exception to terminate the loop and unwrapping it at the end
             * to resolve the promise.
             *
             *      repeatAndExit(function (exit) {
             *          return ucwa.send("GET", "/status").then(function (rsp) {
             *              if (rsp.status == 409)
             *                  exit(rsp);
             *              return sleep(10);
             *          });
             *      }).then(function (rsp) {
             *          console.log(rsp); // status = 409
             *      });
             *
             * Unlike the repeat function, repeatAndExit invokes the given async function
             * with one argument - a specially constructed `exit` function that throws a
             * specially constructed exception, which is caught by repeatAndExit and used
             * to resolve the promise.
             *
             * @created Dec 2014
             * @blame antonkh
             */
            function repeatAndExit(fn) {
                var res = [null];
                function exit(result) {
                    res[0] = result;
                    throw res;
                }
                return repeat(Utils.bind(fn, exit)).catch(function (err) {
                    if (err === res)
                        return res[0];
                    throw err;
                });
            }
            Utils.repeatAndExit = repeatAndExit;
            //#endregion
            //#region repeatDelayed
            /**
             * A specialized version of repeat(...) that handles delaying execution cycles
             * by sleeping a supplied amount. The logic of `repeatDelayed` is functionally
             * equivalent to:
             *
             *      while (true) {
             *          await fn();
             *          await sleep(delay);
             *      }
             *
             */
            function repeatDelayed(fn, delay) {
                // repeatDelayed(fn, 0) is equivalent to repeat(fn)
                Utils.assert(Utils.isNumber(delay) && delay > 0);
                // this will check whether fn is a function
                var afn = Utils.async(fn);
                return repeat(function () {
                    return afn().then(Utils.bind(Utils.sleep, delay));
                });
            }
            Utils.repeatDelayed = repeatDelayed;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * @param ajax - A function that sends a HTTP request.
             *
             *      This function has the same signature as jQuery.ajax:
             *
             *          function ajax(request) {
             *              return Task().promise;
             *          }
             *
             * @param size - The max number of concurrent HTTP requests.
             *
             *      This parameter limits the number of HTTP requests that can
             *      be sent at the same time. If the caller tries to send
             *      more requests, the throttle will queue them and will send them
             *      in due order after the server replies to first requests.
             *
             * @returns A function that has the same signature as jQuery.ajax.
             *
             *      In addition it has a parameter specifying the priority of the request:
             *
             *          {async Response} send(Request request, Number priority)
             *
             *      The higher the priority, the sooner the request will leave
             *      the queue and will be actually sent.
             *
             *      If the function is invoked multiple times, it will send
             *      up to the specified number of requests and will save other
             *      requests into an internal queue. Then, after the server replies
             *      to first requests, the throttle will send requests from
             *      the queue.
             *
             * @created antonkh, August 2013
             */
            function throttle(ajax, size) {
                Utils.assert(Utils.isFunction(ajax));
                Utils.assert(size > 0);
                ajax = Utils.async(ajax);
                var sent = 0; // the number of sent requests to which the server has not replied
                var queue = []; // the ids of requests waiting for being sent
                var results = {}; // results[id] = the deferred for the id-th request
                var requests = {}; // requests[id] = the id-th request
                var priorities = []; // priorities[i] corresponds to queue[i]
                var pending = {}; // pending[id] is a promise that observes the progress of the corresponding request
                function dequeue() {
                    Utils.assert(sent <= size);
                    while (sent < size && queue.length > 0)
                        send();
                }
                function send() {
                    var id = queue.splice(0, 1)[0];
                    var request = requests[id];
                    var result = results[id];
                    delete requests[id];
                    delete results[id];
                    priorities.splice(0, 1);
                    sent++;
                    pending[id] = ajax(request);
                    pending[id].then(function (res) { return result.resolve(res); }, function (err) { return result.reject(err); }, result.status).then(function () {
                        sent--;
                        delete pending[id];
                        dequeue();
                    });
                }
                function insert(id, priority) {
                    var i = priorities.length;
                    while (i > 0 && priority > priorities[i - 1])
                        i--;
                    priorities.splice(i, 0, priority);
                    queue.splice(i, 0, id);
                }
                function cancel(id, reason) {
                    var i;
                    if (pending[id]) {
                        // this will invoke result.reject
                        pending[id].cancel(reason);
                    }
                    else {
                        results[id].reject(reason);
                        delete requests[id];
                        delete results[id];
                        for (i = 0; i < queue.length; i++) {
                            if (queue[i] == id) {
                                queue.splice(i, 1);
                                priorities.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                return function (request, priority) {
                    var id = Utils.random();
                    var task = new Utils.Task('Waiting in the throttling queue.', {
                        cancel: Utils.bind(cancel, id)
                    });
                    results[id] = task;
                    requests[id] = request;
                    insert(id, priority);
                    dequeue();
                    return task.promise;
                };
            }
            Utils.throttle = throttle;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * Debounces multiple requests to an async function.
             *
             * While the promise returned by the first call is pending,
             * all subsequent calls will return the same promise and won't
             * invoke the function.
             *
             *      fetch = debounced(function () {
             *          return ucwa.send("GET", "/presence").then(r => r.get("availability"));
             *      });
             *
             *      // fetch is invoked only once
             *      status1 = fetch();
             *      status2 = fetch();
             *
             * @created Dec 2014
             * @blame antonkh
             */
            function debounced(fn) {
                var res, dfd, afn = Utils.async(fn);
                return function () {
                    if (!dfd) {
                        res = dfd = afn();
                        // if dfd is completed and the underlying task is sync,
                        // this callback will be executed right away, nulling dfd
                        dfd.finally(function () {
                            dfd = null;
                        });
                    }
                    return res;
                };
            }
            Utils.debounced = debounced;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * JS code lives in a single-threaded event-based environment.
             * When an event occurs, a JS handler for that event may need
             * to send multiple HTTP requests in a loop and these requests
             * may be sent as a single batch request to UCWA. To achieve that
             * the function that sends HTTP requests puts a request into a
             * queue and invokes setTimeout/postMessage in order to empty the
             * queue and send the batch request after the JS code currently
             * being executed completes sending HTTP requests and quits.
             *
             * @param {Function} batch - Sends a batch request.
             *
             *  It has the following signature:
             *
             *      Response[] batch(Request[] requests)
             *
             *  It may return the results asynchronously.
             *
             * @param {Number} maxBatchSize
             *
             *      The max number of requests that the batch can send.
             *
             * @returns A function with the following signature:
             *
             *      {async Response} send(Request request, Number priority)
             *
             *          {Request} request - A request acceptable by the <batch> function.
             *          {Number} priority - Requests with higher priority are sent first.
             *
             *      The <send> function inserts <request> into an internal queue
             *      at a position appropriate to the given <priority> value: the
             *      higher priority the sooner the request will be extracted from
             *      the queue and sent with the <batch> function.
             *
             * @created antonkh, Oct 2013
             */
            function batched(batch, maxBatchSize) {
                if (maxBatchSize === void 0) { maxBatchSize = Infinity; }
                // queue[i].request is a request to be sent with <batch>.
                // queue[i].task is a task that adopts a result of <batch>.
                // queue[i].priority is the importance of the request.
                // queue[i].priority <= queue[i + 1].priority
                var queue = [];
                // a handle of the pending timer that when expired
                // reads requests from the queue and sends them in batch
                var hTimer;
                /**
                 * Inserts a pending request into the queue and
                 * associates it with the given priority.
                 *
                 * @param {Number} priority
                 * @param {Object} request
                 * @param {Task} task
                 */
                function insert(priority, request, task) {
                    Utils.assert(Utils.isNumber(priority));
                    Utils.assert(task instanceof Utils.Task);
                    var i = 0;
                    while (i < queue.length && priority > queue[i].priority)
                        i++;
                    queue.splice(i, 0, { priority: priority, request: request, task: task });
                }
                /**
                 * Finds up to the given number of most urgent pending requests,
                 * removes them from the queue and returns them as an array.
                 *
                 * @param {Number} count
                 *
                 *      The max number of requests to extract.
                 *
                 * @returns Null or an object with two keys:
                 *
                 *      {Request[]} requests - All requests from the queue that are due to the given time.
                 *      {Task[]} tasks - Corresponding tasks.
                 */
                function extract(count) {
                    Utils.assert(count > 0);
                    Utils.assert(queue.length > 0);
                    var i, requests = [], tasks = [];
                    for (i = queue.length - 1; i >= 0 && requests.length < count; i--) {
                        requests.push(queue[i].request);
                        tasks.push(queue[i].task);
                    }
                    queue.splice(i + 1, count);
                    return { requests: requests, tasks: tasks };
                }
                /**
                 * Attempts to cancel the given task.
                 */
                function cancel(task, reason) {
                    var i;
                    for (i = 0; i < queue.length; i++)
                        if (queue[i].task === task)
                            break;
                    if (i < queue.length) {
                        // the request is still waiting in the queue,
                        // so it can be just removed from and marked as cancelled
                        queue.splice(i, 1);
                        task.reject(reason);
                    }
                    else {
                        // the request has been sent in a batch of other
                        // requests to the throttling queue; it cannot be
                        // thus cancelled, but the response may be ignored
                        task.cancelled = true;
                        task.reject(reason);
                    }
                }
                /**
                 * Periodically extracts pending requests up to maximum batch size,
                 * sends them in a batch and redirects the batch response to pending tasks.
                 */
                function send() {
                    var pending = extract(maxBatchSize);
                    function forEachPendingTask(fn) {
                        Utils.foreach(pending.tasks, function (task, i) {
                            if (!task.cancelled)
                                fn(task, i);
                        });
                    }
                    Utils.Task.wait(batch(pending.requests)).then(function (responses) {
                        forEachPendingTask(function (task, i) {
                            var rsp = Utils.isArray(responses) ? responses[i] : responses;
                            Utils.Task.wait(rsp).then(function (res) { return task.resolve(res); }, function (err) { return task.reject(err); }, task.status);
                        });
                    }, function (error) {
                        forEachPendingTask(function (task) {
                            task.reject(error);
                        });
                    }, function (status) {
                        forEachPendingTask(function (task) {
                            task.status(status);
                        });
                    });
                }
                return function (request, priority) {
                    if (priority === void 0) { priority = 0; }
                    var task = new Utils.Task('Waiting in the batching queue.', {
                        cancel: function (reason) {
                            cancel(task, reason);
                        }
                    });
                    if (!hTimer) {
                        hTimer = Web.setTimeout(function () {
                            hTimer = null;
                            while (queue.length > 0)
                                send();
                        }, 0);
                    }
                    insert(priority, request, task);
                    return task.promise;
                };
            }
            Utils.batched = batched;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var keyString = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            // fix for JavaScript modulo operation bug (wrong result for negative values)
            function mod(value, modulo) {
                return ((value % modulo) + modulo) % modulo;
            }
            /**
             * Contains static methods for conversion of UTF-16 strings to UTF-8 byte arrays
             *
             * @method byteArrayToString - converts a UTF-8 byte array to a UTF-16 string
             * @method stringToByteArray - converts a UTF-16 string to a UTF-8 byte array
             *
             * @blame sosobov
             */
            var ByteArray;
            (function (ByteArray) {
                /**
                 * Converts a byte array representation of a Unicode (UTF-8) string to a Unicode (UTF-16) string
                 */
                function byteArrayToString(value) {
                    Utils.assert(Utils.isArray(value));
                    var str = '', curByte, byte1, byte2, byte3, i = 0;
                    while (i < value.length) {
                        curByte = value[i];
                        if ((curByte < 0) || (curByte > 0xFF))
                            throw new Error('Unexpected utf8 byte');
                        // 1 byte, < 128, up to U+007F, ascii values
                        if (curByte < 0x80) {
                            str += String.fromCharCode(curByte);
                            i++;
                        }
                        else if ((curByte & 0xE0) == 0xC0) {
                            if ((i + 1) >= value.length)
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // extract 5 bits from curByte and 6 bits from byte1
                            str += String.fromCharCode(((curByte & 0x1F) << 6) | (byte1 & 0x3F));
                            i += 2;
                        }
                        else if ((curByte & 0xF0) == 0xE0) {
                            if (((i + 1) >= value.length) || ((i + 2) >= value.length))
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            byte2 = value[i + 2];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte2 < 0) || (byte2 > 0xFF) || ((byte2 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // extract 4 bits from curByte and 6 bits from byte1 and byte 2
                            str += String.fromCharCode(((curByte & 0x0F) << 12) | ((byte1 & 0x3F) << 6) | (byte2 & 0x3F));
                            i += 3;
                        }
                        else if ((curByte & 0xF8) == 0xF0) {
                            if (((i + 1) >= value.length) || ((i + 2) >= value.length) || ((i + 3) >= value.length))
                                throw new Error("Unexpected end of array");
                            byte1 = value[i + 1];
                            byte2 = value[i + 2];
                            byte3 = value[i + 3];
                            // (test for 10xxxxxx)
                            if ((byte1 < 0) || (byte1 > 0xFF) || ((byte1 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte2 < 0) || (byte2 > 0xFF) || ((byte2 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // (test for 10xxxxxx)
                            if ((byte3 < 0) || (byte3 > 0xFF) || ((byte3 & 0xC0) != 0x80))
                                throw new Error("Unexpected utf8 byte");
                            // Extract 3 bits from curByte and 6 bits from byte1 and byte 2 and byte 3
                            var unicodeValue = ((curByte & 0x07) << 18) | ((byte1 & 0x3F) << 12) | ((byte2 & 0x3F) << 6) | (byte3 & 0x3F);
                            // From unicode.org utf faq
                            var lead_offset = 0xD800 - (0x10000 >> 10);
                            // Equivalent of - Subtract 0x10000, split into two 10-bit pieces
                            // Add D800 to the high 10 bit piece, Add DC00 to the low 10 bit piece
                            // to get the surrogate pairs
                            var lead = lead_offset + (unicodeValue >> 10);
                            var trail = 0xDC00 + (unicodeValue & 0x3FF);
                            str += String.fromCharCode(lead);
                            str += String.fromCharCode(trail);
                            i += 4;
                        }
                        else {
                            throw new Error('Illegal utf8 converter input');
                        }
                    }
                    return str;
                }
                ByteArray.byteArrayToString = byteArrayToString;
                /**
                 * Converts a UTF-16 string to a UTF-8 byte array
                 */
                function stringToByteArray(value) {
                    Utils.assert(Utils.isString(value));
                    var bytes = [];
                    var i = 0;
                    while (i < value.length) {
                        // JavaScript encodes strings in UTF-16 - each character is represented with one or two 16-bit values
                        // Sample - "\uD834\uDD2A" - U+1D12A represented by a UTF-16 surrogate pair
                        // Sample - "\uD800\uDC00" - U+10000 (65536) represented by a UTF-16 surrogate pair
                        // A surrogate pair needs to be converted into 4-byte utf-8
                        // Illegal to take each surrogate separately and convert into two 3-byte utf-8
                        var curChar = value.charCodeAt(i);
                        // 1 byte, < 128, upto U+007F, ascii values
                        if (curChar < 0x80) {
                            bytes.push(curChar);
                            i++;
                        }
                        else if (curChar < 0x800) {
                            // 11000000 | curchar >> 6
                            bytes.push((0xC0 | (curChar >> 6)));
                            // 10000000 | curChar & 00111111
                            bytes.push((0x80 | (curChar & 0x3F)));
                            i++;
                        }
                        else if (0xD800 <= curChar && curChar <= 0xDBFF) {
                            var highSurrogate = curChar;
                            if ((i + 1) >= value.length)
                                throw new Error('High Surrogate at the end of string');
                            var lowSurrogate = value.charCodeAt(i + 1);
                            if (!(0xDC00 <= lowSurrogate && lowSurrogate <= 0xDFFF))
                                throw new Error('High Surrogate followed by invalid low surrogate');
                            // From unicode.org utf faq
                            // (highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000
                            var surrogate_offset = 0x10000 - (0xD800 << 10) - 0xDC00;
                            var unicodeValue = (highSurrogate << 10) + lowSurrogate + surrogate_offset;
                            // 11110000 | (unicodeValue >> 18)
                            bytes.push(0xF0 | (unicodeValue >> 18));
                            // 10000000 | (unicodeValue >> 12) & 00111111
                            bytes.push(0x80 | ((unicodeValue >> 12) & 0x3F));
                            // 10000000 | (unicodeValue >> 6) & 00111111
                            bytes.push(0x80 | ((unicodeValue >> 6) & 0x3F));
                            // 10000000 | unicodeValue & 00111111
                            bytes.push(0x80 | (unicodeValue & 0x3F));
                            // Skip the next value (already account for the low surrogate)
                            i = i + 2;
                        }
                        else if (0xDC00 <= curChar && curChar <= 0xDFFF) {
                            throw new Error("Low Surrogate not preceded by high surrogate");
                        }
                        else if (curChar < 0x10000) {
                            // 11100000 | (curchar >> 12)
                            bytes.push(0xE0 | (curChar >> 12));
                            // 10000000 | (curchar >> 6) & 00111111
                            bytes.push(0x80 | ((curChar >> 6) & 0x3F));
                            // 10000000 | curChar & 00111111
                            bytes.push(0x80 | (curChar & 0x3F));
                            i++;
                        }
                        else {
                            throw new Error('Illegal utf8 converter input');
                        }
                    }
                    return bytes;
                }
                ByteArray.stringToByteArray = stringToByteArray;
            })(ByteArray = Utils.ByteArray || (Utils.ByteArray = {}));
            /**
             * Base64 encoder for Unicode (UTF-16) strings
             *
             * @method encode - converts a Unicode (UTF-16) string to a base64-encoded string
             * @method decode - converts a base64-encoded string to a Unicode (UTF-16) string
             *
             * @example
             *
             *      var base64str = Base64().encode('Hello');
             *      var str = Base64().decode(base64str);
             *      assert(str == 'Hello');
             *
             * @blame sosobov
             */
            var Base64;
            (function (Base64) {
                /**
                 * Converts a Unicode string to a Base64-encoded string
                 */
                function encode(str) {
                    if (Utils.isNotEmptyString(str)) {
                        var strArray = ByteArray.stringToByteArray(str);
                        return encodeBytes(strArray);
                    }
                    else
                        return str;
                }
                Base64.encode = encode;
                /**
                 * Converts a Base64-encoded string to a Unicode (UTF-16) string
                 */
                function decode(str) {
                    if (Utils.isNotEmptyString(str)) {
                        var strArray = decodeBytes(str);
                        return ByteArray.byteArrayToString(strArray);
                    }
                    else
                        return str;
                }
                Base64.decode = decode;
                function encodeBytes(input) {
                    Utils.assert(Utils.isArray(input));
                    var output = '';
                    var chr1, chr2, chr3, encoding1, encoding2, encoding3, encoding4, i = 0;
                    while (i < input.length) {
                        chr1 = input[i++];
                        chr2 = i < input.length ? input[i++] : 0;
                        chr3 = i < input.length ? input[i++] : 0;
                        // first six bits of the first character
                        encoding1 = chr1 >> 2;
                        // last two bits of the first character and first four of the second
                        encoding2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                        // last four of the second and first two of the third
                        encoding3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                        // last six of the third character
                        encoding4 = chr3 & 63;
                        if (i == input.length) {
                            if (mod(input.length, 3) == 1) {
                                encoding3 = 64;
                                encoding4 = 64;
                            }
                            else if (mod(input.length, 3) == 2) {
                                encoding4 = 64;
                            }
                        }
                        output += keyString.charAt(encoding1) + keyString.charAt(encoding2) +
                            keyString.charAt(encoding3) + keyString.charAt(encoding4);
                    }
                    return output;
                }
                Base64.encodeBytes = encodeBytes;
                function decodeBytes(input) {
                    Utils.assert(Utils.isNotEmptyString(input));
                    var output = [];
                    var chr1, chr2, chr3, encoding1, encoding2, encoding3, encoding4, i = 0;
                    while (i < input.length) {
                        encoding1 = keyString.indexOf(input.charAt(i++));
                        encoding2 = keyString.indexOf(input.charAt(i++));
                        encoding3 = keyString.indexOf(input.charAt(i++));
                        encoding4 = keyString.indexOf(input.charAt(i++));
                        chr1 = (encoding1 << 2) | (encoding2 >> 4);
                        chr2 = ((encoding2 & 15) << 4) | (encoding3 >> 2);
                        chr3 = ((encoding3 & 3) << 6) | encoding4;
                        output.push(chr1);
                        if (encoding3 != 64)
                            output.push(chr2);
                        if (encoding4 != 64)
                            output.push(chr3);
                    }
                    return output;
                }
                Base64.decodeBytes = decodeBytes;
            })(Base64 = Utils.Base64 || (Utils.Base64 = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var Radix = (function () {
                function Radix(radix) {
                    this.radix = radix;
                }
                /** Least Significant Byte (LSB) first:
                    0xab45fc.3d -> [0xc.3d, 0xf, 0x5, 0x4, 0xb, 0xa] */
                Radix.prototype.digits = function (value) {
                    var radix = this.radix;
                    var digits = [];
                    // before you try to optimize this loop, take into account
                    // the fancy bitwise arithmetics behavior for numbers > 2 ^ 32
                    while (value > radix) {
                        var digit = value % radix;
                        value = (value - digit) / radix;
                        digits.push(digit);
                    }
                    digits.push(value);
                    return digits;
                };
                /** Least Significant Byte (LSB) first:
                    [0xc.3d, 0xf, 0x5, 0x4, 0xb, 0xa] -> 0xab45fc.3d */
                Radix.prototype.number = function (digits) {
                    var value = 0;
                    for (var i = digits.length - 1; i >= 0; i--)
                        value = value * this.radix + digits[i];
                    return value;
                };
                return Radix;
            })();
            Utils.Radix = Radix;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            /**
             * RFC 4122:
             *
             * The formal definition of the UUID string representation is
             * provided by the following ABNF [7]:
             *
             * UUID                   = time-low "-" time-mid "-"
             *                          time-high-and-version "-"
             *                          clock-seq-and-reserved
             *                          clock-seq-low "-" node
             * time-low               = 4hexOctet
             * time-mid               = 2hexOctet
             * time-high-and-version  = 2hexOctet
             * clock-seq-and-reserved = hexOctet
             * clock-seq-low          = hexOctet
             * node                   = 6hexOctet
             * hexOctet               = hexDigit hexDigit
             * hexDigit =
             *       "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" /
             *       "a" / "b" / "c" / "d" / "e" / "f" /
             *       "A" / "B" / "C" / "D" / "E" / "F"
             *
             * The following is an example of the string representation of a UUID as
             * a URN:
             *
             * urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6
             */
            function guid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    var r = Web.Math.random() * 16 | 0;
                    var v = c == 'x' ? r : r & 3 | 8;
                    return v.toString(16);
                });
            }
            Utils.guid = guid;
            /**
             * Section 4.1.2. Layout and Byte Order:
             *
             * The fields are encoded as 16 octets, with the sizes and order of the
             * fields defined above, and with each field encoded with the Most
             * Significant Byte first (known as network byte order).  Note that the
             * field names, particularly for multiplexed fields, follow historical
             * practice.
             *
             * 0                   1                   2                   3
             *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * |                          time_low                             |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * |       time_mid                |         time_hi_and_version   |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * |clk_seq_hi_res |  clk_seq_low  |         node (0-1)            |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             * |                         node (2-5)                            |
             * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             */
            var guid;
            (function (guid_1) {
                function bytes(guid) {
                    var bytes = [];
                    for (var _i = 0, _a = guid.split('-'); _i < _a.length; _i++) {
                        var seg = _a[_i];
                        for (var i = 0; i < seg.length; i += 2)
                            bytes.push(parseInt(seg.slice(i, i + 2), 16));
                    }
                    return bytes;
                }
                guid_1.bytes = bytes;
                function parse(bytes) {
                    return bytes.map(function (b, i) {
                        var s = (0x100 | b).toString(16).slice(1, 3);
                        return (i == 4 || i == 6 || i == 8 || i == 10) ? '-' + s : s;
                    }).join('');
                }
                guid_1.parse = parse;
            })(guid = Utils.guid || (Utils.guid = {}));
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            function padRight(str, num, char) {
                if (str.length >= num)
                    return str;
                else
                    return str + (new Array(num - str.length + 1).join(char));
            }
            /**
             * Returns a 128-bit message digest in the form of a GUID-like string.
             */
            function hash(str) {
                var state = [1578336022, 36261640, 872437806, 2915948275];
                str = padRight(str, str.length + 16 - str.length % 16, '0');
                for (var i = 0; i < str.length; i += 4) {
                    for (var j = 0; j < 4; j++) {
                        var h3 = str.charCodeAt(i) << 24;
                        var h2 = str.charCodeAt(i + 1) << 16;
                        var h1 = str.charCodeAt(i + 2) << 8;
                        var h0 = str.charCodeAt(i + 3);
                        var input = h3 + h2 + h1 + h0;
                        state[j] = ((state[j] << 5) + state[j]) ^ input; // (s*33) XOR input
                    }
                }
                var result = state.map(function (s) { return (0x100000000 + s).toString(16).slice(-8); });
                return [
                    result[0],
                    result[1].substr(0, 4),
                    result[1].substr(4, 4),
                    result[2].substr(0, 4),
                    result[2].substr(4, 4) + result[3]
                ].join('-');
            }
            Utils.hash = hash;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var Exception = Utils.Exception;
            var async = Utils.async;
            /**
             * This class synchronizes a series of tasks and allows only one task to complete successfully.
             * When a task is synchronized by an instance of SyncLock, it waits until the all the currently
             * pending tasks are completed. Once one task succeeds, all the remaining tasks that are waiting
             * will be rejected.
             *
             * @example
             *
             *   var syncLock = new SyncLock();
             *
             *   var result = [promise1, promise2, promise3, promise4].map(promise => {
             *     return Task.wait(promise)
             *       .then(syncLock.synchronized(res => {
             *         // do the work ...
             *         ...
             *       }))
             *       .then(res => {
             *         // continue to do other stuff
             *       });
             *   });
             *
             * @created Dec 2015
             * @blame wewa
             */
            var SyncLock = (function () {
                function SyncLock(code) {
                    this.code = code;
                }
                SyncLock.prototype.synchronized = function (fn) {
                    var afn = async(fn), self = this;
                    return (function sfn() {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i - 0] = arguments[_i];
                        }
                        if (self.dfd) {
                            return self.dfd.then(function (r) { throw Exception(self.code); }, function (e) {
                                if (e && e.code == 'Canceled')
                                    throw e;
                                return sfn.apply(void 0, args);
                            });
                        }
                        else {
                            var d = self.dfd = afn.apply(void 0, args);
                            d.finally(function () { return self.dfd = null; });
                            return d;
                        }
                    });
                };
                return SyncLock;
            })();
            Utils.SyncLock = SyncLock;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="pm/Model.ts" />
/// <reference path="utils/Pattern.ts" />
/// <reference path="utils/URI.ts" />
/// <reference path="utils/DataURI.ts" />
/// <reference path="utils/CSS.ts" />
/// <reference path="utils/XML.ts" />
/// <reference path="utils/HTML.ts" />
/// <reference path="utils/W3A.ts" />
/// <reference path="utils/WeakMap.ts" />
/// <reference path="utils/HTTP.ts" />
/// <reference path="utils/LINQ.ts" />
/// <reference path="utils/StateMachine.ts" />
/// <reference path="utils/repeat.ts" />
/// <reference path="utils/throttled.ts" />
/// <reference path="utils/debounced.ts" />
/// <reference path="utils/batched.ts" />
/// <reference path="utils/Base64.ts" />
/// <reference path="utils/Radix.ts" />
/// <reference path="utils/GUID.ts" />
/// <reference path="utils/hash.ts" />
/// <reference path="utils/SyncLock.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        // {{build}} number is injected from build system
        Web.version = '{{build}}'.replace(/[{}]/g, ''); // major.minor.patch+build (see semver.org)
        /** This simple pattern is known as "monad" and it's useful
            to chain dependent objects in a type safe manner. */
        var Identity = (function () {
            function Identity(value) {
                this.value = value;
            }
            Identity.prototype.map = function (fn) {
                return new Identity(fn(this.value));
            };
            return Identity;
        })();
        Web.Identity = Identity;
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Utils;
        (function (Utils) {
            'use strict';
            var debug;
            (function (debug) {
                function log() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    /* istanbul ignore next */
                    if (!Web.isUnitTested && Web.Settings.dbgBreak) {
                        try {
                            console.log.apply(console, args);
                        }
                        catch (err) {
                        }
                    }
                }
                debug.log = log;
                function watch(description, p) {
                    p.changed(function (val, reason, old) {
                        if (old === void 0)
                            return;
                        var args = [
                            (description + ": %c " + old + " -> " + val),
                            'color:green;font-weight:bold'];
                        if (reason) {
                            args.push('Reason:');
                            args.push(reason);
                        }
                        debug.log.apply(null, args);
                    });
                }
                debug.watch = watch;
            })(debug = Utils.debug || (Utils.debug = {}));
            var SipUri;
            (function (SipUri) {
                /** Checks if a string is a valid SIP URI. */
                SipUri.test = function (s) { return /\^sips?:/i; };
            })(SipUri = Utils.SipUri || (Utils.SipUri = {}));
            Utils.cleanwsp = function (s) { return s.replace(/\s*\n\s*/gm, ''); };
            /** Tag functions for ES6 template strings. */
            var TSTags;
            (function (TSTags) {
                /** Removes indentation and line breaks from simple multiline strings. */
                function merge() {
                    var strings = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        strings[_i - 0] = arguments[_i];
                    }
                    return Utils.cleanwsp(strings.join(''));
                }
                TSTags.merge = merge;
            })(TSTags = Utils.TSTags || (Utils.TSTags = {}));
            //#region various utils
            //#region sleep
            /**
             * Returns a promise that gets resolved after the given delay.
             *
             * @param {Number} delay - The delay in seconds, e.g. 1.5 means 1500 milliseconds.
             * @returns {Promise}
             * @example
             *
             *      sleep(1.5).then(function () {
             *          alert("1.5 seconds has left.");
             *      });
             */
            function sleep(delay) {
                Utils.assert(delay >= 0);
                var task = new Utils.Task(delay + ' sec timeout', {
                    cancel: function (reason) {
                        Web.clearTimeout(id);
                        task.reject(reason);
                    }
                });
                var id = Web.setTimeout(function () { return task.resolve(); }, (delay * 1000) | 0);
                return task.promise;
            }
            Utils.sleep = sleep;
            //#endregion
            //#region trim
            function trim(s) {
                return s.trim ? s.trim() : s.replace(/^\s+|\s+$/gm, '');
            }
            Utils.trim = trim;
            //#endregion
            //#region freeze
            /**
             * Freezes the object (makes the object immutable)
             *
             * @param {Object} obj - an object to freeze
             * @returns {Object} obj - the object passed to this function
             */
            function freeze(obj) {
                return Object.freeze ? Object.freeze(obj) : obj;
            }
            Utils.freeze = freeze;
            //#endregion
            //#region enums
            /**
             * Creates a string enumeration.
             *
             * @param {arguments} - a collection of strings.
             * @returns {object} -  an object which has property names-values equal to each string
             *                      in the arguments collection
             *
             * @example
             *      var se = StringEnum('red', 'green', 'blue');
             *      assert(se.red === 'red');
             *      var yellow = se.yellow; will throw
             */
            function StringEnum() {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i - 0] = arguments[_i];
                }
                var obj = {}, name, i;
                for (i = 0; i < values.length; i++) {
                    name = values[i];
                    obj[name] = name;
                }
                return freeze(obj);
            }
            Utils.StringEnum = StringEnum;
            /**
             * Creates an enumeration.
             *
             * @param {arguments} - a collection of strings.
             * @returns {object} - an object which has property names equal to argument strings
             *      and property values equal to argument string positions
             *
             * @example
             *      var se = Enum('red', 'green', 'blue');
             *      assert(se.red === 0);
             *      var yellow = se.yellow; will throw
             *
             * or an enumeration can be set explicitly by using
             * @param {object} - a dictionary of name-value pairs
             * @returns {object} - the frozen parameter object
             *
             * @example
             *   var se = Enum({red: 1, green: 5, blue: 8});
             *   assert(se.green == 5);
             *
             * @remark use the companion function enumName to get the enum name from its value
             */
            function Enum() {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i - 0] = arguments[_i];
                }
                var obj, i;
                if (values.length == 1 && Utils.isDictionary(values[0])) {
                    obj = arguments[0];
                }
                else {
                    obj = {};
                    for (i = 0; i < values.length; i++)
                        obj[values[i]] = i;
                }
                return freeze(obj);
            }
            Utils.Enum = Enum;
            /**
             * Returns enum name from its value
             */
            function enumName(enumObj, enumVal) {
                for (var name in enumObj) {
                    if (enumObj[name] == enumVal)
                        return name;
                }
                return '';
            }
            Utils.enumName = enumName;
            //#endregion
            //#region clone
            /**
             * Returns an exact copy of the given object.
             * The copy has no relationships with the original
             * object, so if the original object gets modified,
             * the copy doesn't change.
             *
             * @created antonkh, Feb 2014
             */
            function clone(object) {
                return object && JSON.parse(JSON.stringify(object));
            }
            Utils.clone = clone;
            //#endregion
            //#endregion various utils          
            //#region singleton
            /**
             * Returns a single instance of an object constructed by the argument function
             *
             * @example
             *      var s = singleton(function() {
             *                  return { ticks: (new Date).getTime() };
             *              });
             *      var t0 = s().ticks, t1 = s().ticks;
             *      assert(t0 == t1);
             */
            function singleton(ctor) {
                Utils.assert(Utils.isFunction(ctor));
                var instance = null;
                return function () {
                    return instance || (instance = ctor());
                };
            }
            Utils.singleton = singleton;
            //#endregion
            //#region timeStampToDate
            /**
             * Converts a UCWA-style text representation of a timestamp
             * into a Date object: "/Date(11111111111)/" => new Date(11111111111)
             */
            function timeStampToDate(ts) {
                if (!ts) {
                    return ts;
                }
                // "/Date(11111111111)/" => new Date(11111111111)
                var p = /\d+/.exec(ts);
                return new Web.Date(p && +p[0]);
            }
            Utils.timeStampToDate = timeStampToDate;
            //#endregion
            //#region dateToTimeStamp
            /**
             * Converts a Date object into a formatted string
             *
             * @param {Date} date
             *
             * @returns {string} - in the form of '/Date(123)/'
             */
            function dateToTimeStamp(date) {
                if (!date) {
                    return date;
                }
                // Date(11111111111) => "/Date(11111111111)/"
                return '\/Date(' + (+date) + ')\/';
            }
            Utils.dateToTimeStamp = dateToTimeStamp;
            //#region currentUTCms
            /**
             * Returns current UTC time as the number of milliseconds from epoch (UTC).
             * Note: Calculation is current local computer time plus the timezone offset from UTC
             *
             * @returns {number} - the sum of current local computer time and the timezone offset from UTC
             */
            function currentUTCms() {
                return Web.Date.now() + (new Web.Date()).getTimezoneOffset() * 60 * 1000;
            }
            Utils.currentUTCms = currentUTCms;
        })(Utils = Web.Utils || (Web.Utils = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="utils.ts"/>
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        'use strict';
        var guid = Web.Utils.guid;
        var clone = Web.Utils.clone;
        var extend = Web.Utils.extend;
        var nothrow = Web.Utils.nothrow;
        var defaultTenantToken = 'afe05df65cc74b958837195cd87d2ff0-e0f88ee6-25f5-49b5-ae35-25c6b40faa7f-7176';
        var TelemetryRecorder = (function () {
            function TelemetryRecorder(telemetryManager, tenantToken) {
                if (tenantToken === void 0) { tenantToken = defaultTenantToken; }
                this.telemetryManager = telemetryManager;
                this.tenantToken = tenantToken;
                /** These props are attached to every telemetry record. */
                this.defaults = {
                    sdkVersion: Web.version
                };
            }
            /**
             * record method simply sends a data point to the telemetry backend.
             *
             * It is a no-op if the telemetryManager is null or undefined.
             */
            TelemetryRecorder.prototype.record = function (eventName, properties) {
                if (properties === void 0) { properties = {}; }
                if (!this.telemetryManager)
                    this.telemetryManager = new TelemetryManager();
                var p = clone(properties);
                if (properties.reason && properties.reason.stack) {
                    p.reason.stack = properties.reason.stack;
                    p.reason = JSON.stringify(p.reason);
                }
                this.telemetryManager.sendEvent(this.tenantToken, eventName, extend({}, this.defaults, p));
            };
            TelemetryRecorder.prototype.timeout = function (timeout, event, props) {
                var _this = this;
                if (props === void 0) { props = {}; }
                props.timeout = timeout;
                var timer = Web.setTimeout(function () {
                    _this.record(event, props);
                }, timeout);
                return {
                    cancel: function () {
                        Web.clearTimeout(timer);
                    }
                };
            };
            /**
             * monitored wraps an asnc function and monitors the state of the promise returned from the async function.
             *
             * It sends a telemetry data of specified event name with a particular traceId. When the promise is resolved,
             * it sends a matching telemetry data point with a `succeeded` result. If the promise is rejected, it sends
             * a matching telemetry data point with a `failed` result, along with a reason property.
             *
             */
            TelemetryRecorder.prototype.monitored = function (fn, eventName, properties) {
                var _this = this;
                if (properties === void 0) { properties = {}; }
                return (function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    return _this.monitor(fn.apply(void 0, args), eventName, properties);
                });
            };
            /**
             * the monitor function monitors the state of the promise.
             *
             * It sends a telemetry data of specified event name with a particular traceId. When the promise is resolved,
             * it sends a matching telemetry data point with a `succeeded` result. If the promise is rejected, it sends
             * a matching telemetry data point with a `failed` result, along with a reason property.
             *
             * If an optional timeout value is set, it also sends out a timeout data with the current promise status if
             * the promise is still pending at the moment when timeout occurs.
             */
            TelemetryRecorder.prototype.monitor = function (promise, eventName, properties, timeout) {
                if (properties === void 0) { properties = {}; }
                if (timeout === void 0) { timeout = 0; }
                if (promise) {
                    var status;
                    var tmEnd = this.begin(eventName, properties);
                    var timer = timeout && Web.setTimeout(function () {
                        tmEnd('timeout', { timeout: timeout, status: status });
                    }, timeout);
                    promise.then(function (res) { return tmEnd('succeeded'); }, function (err) { return tmEnd('failed', { reason: err }); }, function (sts) { status = sts; }).finally(function () {
                        timer && Web.clearTimeout(timer);
                    });
                }
                return promise;
            };
            /**
             * begin() method sends a data point to the telemetry backend and returns a function that can be used
             * to send a data point with a matching traceId and a duration property as well.
             *
             * For example:
             *   const tm = new TelemetryRecorder(telemetryManager, tenantToken);
             *
             *   const end = tm.begin('actionStart');
             *   ...
             *   end('actionEndSucceeded');
             *   // or
             *   end('actionEndFailed', { reason: error });
             *
             */
            TelemetryRecorder.prototype.begin = function (eventName, properties) {
                var _this = this;
                if (properties === void 0) { properties = {}; }
                var traceId = guid();
                var beginTS = Web.Date.now();
                var beginProperties = extend(properties, { traceId: traceId });
                this.record(eventName, beginProperties);
                return function (result, properties) {
                    if (properties === void 0) { properties = {}; }
                    var endTS = Web.Date.now();
                    var endProperties = extend(properties, {
                        traceId: traceId,
                        result: result,
                        duration: endTS - beginTS
                    });
                    _this.record(eventName, extend(beginProperties, endProperties));
                };
            };
            __decorate([
                nothrow
            ], TelemetryRecorder.prototype, "record", null);
            __decorate([
                nothrow
            ], TelemetryRecorder.prototype, "timeout", null);
            __decorate([
                nothrow
            ], TelemetryRecorder.prototype, "monitored", null);
            __decorate([
                nothrow
            ], TelemetryRecorder.prototype, "monitor", null);
            __decorate([
                nothrow
            ], TelemetryRecorder.prototype, "begin", null);
            return TelemetryRecorder;
        })();
        Web.TelemetryRecorder = TelemetryRecorder;
        /**
         * Expose the Aria Telemetry PII enum
         */
        var TelemetryRecorder;
        (function (TelemetryRecorder) {
            TelemetryRecorder.PIIType = {
                NotSet: 0,
                DistinguishedName: 1,
                GenericData: 2,
                IPV4Address: 3,
                IPv6Address: 4,
                MailSubject: 5,
                PhoneNumber: 6,
                QueryString: 7,
                SipAddress: 8,
                SmtpAddress: 9,
                Identity: 10,
                Uri: 11,
                Fqdn: 12
            };
        })(TelemetryRecorder = Web.TelemetryRecorder || (Web.TelemetryRecorder = {}));
        /**
         * TelemetryManager - wrapper of the Aria telemetry logger (aria.microsoft.com).
         *
         * Initialize:
         *     microsoft.applications.telemetry.LogManager.initialize('tenant-token');
         *
         *  Create a logger instance:
         *     defaultLogger = new microsoft.applications.telemetry.Logger();
         *
         * Log an event:
         *     defaultLogger.logEvent({
         *         name: 'my_event_name',
         *         properties: [{
         *             key: 'key1',
         *             value: 'value1'
         *         }, {
         *             key: 'key2',
         *             value: 'value2',
         *             pii: microsoft.applications.telemetry.datamodels.PIIKind.GenericData
         *         }]
         *     });
         */
        var TelemetryManager = (function () {
            function TelemetryManager() {
                this.env = {};
                this.logger = {};
                this.versionString = 'sdk_tm_v0.1';
                this.hostname = '';
                this.browserName = EnvInfo.getBrowserName();
                this.browserVersion = EnvInfo.getBrowserVersion();
                this.osName = EnvInfo.getOSName();
                this.osVersion = EnvInfo.getOSVersion();
                this.env['telemetryManager'] = this.versionString;
                this.env['browserName'] = this.browserName;
                this.env['browserVersion'] = this.browserVersion;
                this.env['osName'] = this.osName;
                this.env['osVersion'] = this.osVersion;
                this.hostname = EnvInfo.getHostname();
            }
            /**
             * Send an event to Aria with a specified tenantToken.
             *
             * @properties {Object} is a property bag that contains event properties. THe property
             *                      should be like the follow format:
             *     {
             *         key1: 'value1',   // string value
             *         key2: true,       // boolean value
             *         key3: 123.456,    // number value
             *         key4: { k: 'v' }, // object value
             *         key5: ['value5', 2], // a value with PII setting (2)
             *     }
             */
            TelemetryManager.prototype.sendEvent = function (tenantToken, eventName, properties) {
                try {
                    if (!this.logger[tenantToken]) {
                        Web.window['microsoft'].applications.telemetry.LogManager.initialize(tenantToken);
                        this.logger[tenantToken] = new Web.window['microsoft'].applications.telemetry.Logger();
                    }
                    var event_1 = {};
                    event_1.name = eventName;
                    event_1.properties = [];
                    for (var propertyName in this.env)
                        event_1.properties.push({ key: propertyName, value: this.env[propertyName] });
                    this.addProperties(event_1.properties, properties);
                    this.logger[tenantToken].logEvent(event_1);
                }
                catch (ex) {
                }
            };
            TelemetryManager.prototype.addProperties = function (eventProperties, properties) {
                for (var propertyName in properties) {
                    var propertyValue = properties[propertyName];
                    if (Array.isArray(propertyValue)) {
                        if (propertyValue[1] && typeof propertyValue[1] !== 'number') {
                            throw new Error('PIIType should be number');
                        }
                        eventProperties.push({ key: propertyName, value: propertyValue[0], pii: propertyValue[1] });
                    }
                    else {
                        eventProperties.push({ key: propertyName, value: propertyValue });
                    }
                }
            };
            return TelemetryManager;
        })();
        var EnvInfo = (function () {
            function EnvInfo() {
            }
            EnvInfo.getHostname = function () {
                return location.hostname;
            };
            EnvInfo.getBrowserName = function () {
                if (EnvInfo.getUserAgent().indexOf('Trident') > -1 || EnvInfo.getUserAgent().indexOf('MSIE') > -1)
                    return EnvInfo.browserNameIE;
                if (EnvInfo.getUserAgent().indexOf('Edge') > -1)
                    return EnvInfo.browserNameEdge;
                if (EnvInfo.getUserAgent().indexOf('Chrome') > -1)
                    return EnvInfo.browserNameChrome;
                if (EnvInfo.getUserAgent().indexOf('Safari') > -1)
                    return EnvInfo.browserNameSafari;
                if (EnvInfo.getUserAgent().indexOf('Firefox') > -1)
                    return EnvInfo.browserNameFirefox;
                return EnvInfo.unknown;
            };
            EnvInfo.getBrowserVersion = function () {
                var browserName = EnvInfo.getBrowserName();
                var matches, matches2;
                switch (browserName) {
                    case EnvInfo.browserNameIE:
                        matches = EnvInfo.getUserAgent().match(/MSIE ([\d,.]+)/);
                        if (matches) {
                            return matches[1];
                        }
                        else {
                            matches2 = EnvInfo.getUserAgent().match(/rv:\s?([\d,.]+)/);
                            return matches2 ? matches2[1] : EnvInfo.unknown;
                        }
                        break;
                    case EnvInfo.browserNameChrome:
                        matches = EnvInfo.getUserAgent().match(/Chrome\/([\d,.]+)/);
                        return matches ? matches[1] : EnvInfo.unknown;
                    case EnvInfo.browserNameEdge:
                        matches = EnvInfo.getUserAgent().match(/Edge\/([\d,.]+)/);
                        return matches ? matches[1] : EnvInfo.unknown;
                    case EnvInfo.browserNameFirefox:
                        matches = EnvInfo.getUserAgent().match(/Firefox\/([\d,.]+)/);
                        return matches ? matches[1] : EnvInfo.unknown;
                    case EnvInfo.browserNameSafari:
                        matches = EnvInfo.getUserAgent().match(/Safari\/([\d,.]+)/);
                        return matches ? matches[1] : EnvInfo.unknown;
                    default:
                        return EnvInfo.unknown;
                }
            };
            EnvInfo.getOSName = function () {
                var winPattern = /(windows|win32)/i, linuxPattern = /(linux|joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|redhat)/i, osxPattern = /(macintosh|mac os x)/i;
                if (EnvInfo.getUserAgent().match(winPattern))
                    return EnvInfo.osNameWindows;
                if (EnvInfo.getUserAgent().match(linuxPattern))
                    return EnvInfo.osNameLinux;
                if (EnvInfo.getUserAgent().match(osxPattern))
                    return EnvInfo.osNameMacOSX;
                // TODO: need to consider other OS: winphone, iOS, android, etc.
                return EnvInfo.unknown;
            };
            EnvInfo.getOSVersion = function () {
                var osName = EnvInfo.getOSName();
                if (osName == EnvInfo.osNameWindows)
                    return EnvInfo.getWindowsVersion();
                else if (osName == EnvInfo.osNameMacOSX)
                    return EnvInfo.getMacOsxVersion();
                else if (osName == EnvInfo.osNameLinux)
                    return EnvInfo.getLinuxVersion();
                return EnvInfo.unknown;
            };
            EnvInfo.getUserAgent = function () {
                return Web.window.navigator.userAgent;
            };
            EnvInfo.getWindowsVersion = function () {
                var matches = EnvInfo.getUserAgent().match(/Windows NT ([\d,.]+)/);
                return matches ? matches[1] : EnvInfo.unknown;
            };
            EnvInfo.getMacOsxVersion = function () {
                var matches = EnvInfo.getUserAgent().match(/Mac OS X ([\d,.]+)/);
                return matches ? matches[1] : EnvInfo.unknown;
            };
            EnvInfo.getLinuxVersion = function () {
                var matches = EnvInfo.getUserAgent().match(/rv:\s*([\d,.]+)/);
                return matches ? matches[1] : EnvInfo.unknown;
            };
            EnvInfo.unknown = 'Unknown';
            EnvInfo.osNameWindows = 'Windows';
            EnvInfo.osNameLinux = 'Linux';
            EnvInfo.osNameMacOSX = 'Mac OSX';
            EnvInfo.browserNameIE = 'IExplorer';
            EnvInfo.browserNameEdge = 'Microsoft Edge'; // has to be Microsoft Edge for policheck reasons
            EnvInfo.browserNameChrome = 'Chrome';
            EnvInfo.browserNameFirefox = 'Firefox';
            EnvInfo.browserNameSafari = 'Safari';
            return EnvInfo;
        })();
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            Stack.AutoD = {
                'O365-Public-MT': function (fqdn) { return [
                    'https://webdir.online.lync.com/autodiscover/autodiscoverservice.svc/root?originalDomain=' + fqdn,
                    'https://lyncdiscover.' + fqdn,
                    'https://lyncdiscoverinternal.' + fqdn
                ]; },
                'O365-Public-MT-Pilot': function (fqdn) { return [
                    'https://webdir.online.lync.com/autodiscover/autodiscoverservice.svc/root?originalDomain=' + fqdn,
                    'https://webdir.tip.lync.com/autodiscover/autodiscoverservice.svc/root?originalDomain=' + fqdn,
                    'https://lyncdiscover.' + fqdn,
                    'https://lyncdiscoverinternal.' + fqdn
                ]; },
                'O365-Public-Gallatin': function (fqdn) { return [
                    'https://webdir.lync.partners.cn/autodiscover/autodiscoverservice.svc/root?originalDomain=' + fqdn,
                    'https://lyncdiscover.' + fqdn
                ]; }
            };
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var Http = Web.Utils.Http;
            var URI = Web.Utils.URI;
            var guid = Web.Utils.guid;
            var cleanwsp = Web.Utils.cleanwsp;
            var Exception = Web.Utils.Exception;
            var XmlDoc = Web.Utils.XmlDoc;
            var HttpHeaders = Web.Utils.HttpHeaders;
            var btoa = Web.Utils.Base64.encode;
            var xmlUserTokenRequest = function (_a) {
                var context = _a.context, scope = _a.scope;
                return cleanwsp("\n        <s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\">\n            <s:Body>\n                <RequestSecurityToken xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" Context=\"" + context + "\" xmlns=\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\">\n                    <TokenType>urn:component:Microsoft.Rtc.WebAuthentication.2010:user-cwt-1</TokenType>\n                    <RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</RequestType>\n                    <AppliesTo xmlns=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n                        <EndpointReference xmlns=\"http://www.w3.org/2005/08/addressing\">\n                            <Address>" + scope + "</Address>\n                        </EndpointReference>\n                    </AppliesTo>\n                </RequestSecurityToken>\n            </s:Body>\n        </s:Envelope>");
            };
            var xmlAnonTokenRequest = function (_a) {
                var context = _a.context, scope = _a.scope, conf_uri = _a.conf_uri, conf_key = _a.conf_key;
                return cleanwsp("\n        <s:Envelope xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\">\n          <s:Header>\n            <Security s:mustUnderstand=\"1\" xmlns:u=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\" xmlns=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">\n              <UsernameToken>\n                <Username>" + btoa(conf_uri) + "</Username>\n                <Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText\">" + btoa(conf_key) + "</Password>\n              </UsernameToken>\n            </Security>\n          </s:Header>\n          <s:Body>\n            <RequestSecurityToken xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" Context=\"" + context + "\" xmlns=\"http://docs.oasis-open.org/ws-sx/ws-trust/200512\">\n              <TokenType>urn:component:Microsoft.Rtc.WebAuthentication.2010:user-cwt-1</TokenType>\n              <RequestType>http://schemas.xmlsoap.org/ws/2005/02/trust/Issue</RequestType>\n              <AppliesTo xmlns=\"http://schemas.xmlsoap.org/ws/2004/09/policy\">\n                <EndpointReference xmlns=\"http://www.w3.org/2005/08/addressing\">\n                  <Address>" + scope + "</Address>\n                </EndpointReference>\n              </AppliesTo>\n              <Claims Dialect=\"urn:component:Microsoft.Rtc.WebAuthentication.2010:authclaims\">\n                <ClaimType Uri=\"http://schemas.microsoft.com/ws/2005/05/identity/claims/conferenceuri\" Optional=\"false\" xmlns=\"http://schemas.xmlsoap.org/ws/2006/12/authorization\">\n                  <Value>" + conf_uri + "</Value>\n                </ClaimType>\n              </Claims>\n              <KeyType>http://docs.oasis-open.org/ws-sx/ws-trust/200512/SymmetricKey</KeyType>\n            </RequestSecurityToken>\n          </s:Body>\n        </s:Envelope>");
            };
            /**
             * Encapsulates /WebTicket/WebTicketService.svc and offers
             * API to get web tickets from the server either by exchanging
             * the RPSAuth cookie or by exchanging the OAuth token.
             *
             * @created Mar 2015
             * @blame antonkh
             */
            var WebTicketService = (function () {
                function WebTicketService(root, send, context) {
                    this.root = root;
                    this.send = send;
                    this.context = context;
                }
                /** this must return a full URL because it'll be used
                    as the source of an iframe element */
                WebTicketService.prototype.getPassiveAuthUrl = function () {
                    var _this = this;
                    return this.getConfigXml().then(function (xml) {
                        // <af:WsFederationPassive af:passiveauthpage=".../PassiveAuth/PassiveAuth.aspx" /> 
                        return /\bpassiveauthpage="(.+?)"/i.exec(xml)[1];
                    }).catch(function (err) {
                        return _this.root + '/PassiveAuth/PassiveAuth.aspx';
                    });
                };
                /** this must return a full URL because it'll be used
                    as the source of an iframe element */
                WebTicketService.prototype.getOAuthUrl = function () {
                    return this.getConfigXml().then(function (xml) {
                        // <af:OAuth af:authorizationUri="https://login.windows.net/common/oauth2/authorize"/> 
                        return /\bauthorizationUri="(.+?)"/i.exec(xml)[1];
                    });
                };
                /** this must return only a path because it'll be used as
                    the target for an XHR request and XHR requests cannot
                    be sent to other domains because of the same-origin policy */
                WebTicketService.prototype.getWsFedPassivePath = function () {
                    var _this = this;
                    return this.getConfigXml().then(function (xml) {
                        // a regular expression cannot extract this URL, so using an XML parser
                        var node = XmlDoc(xml).root
                            .selectOne('wsdl:service', { name: 'WebTicketService' })
                            .selectOne('wsdl:port', { name: 'WsFedPassive' })
                            .selectOne('soap:address');
                        return new URI(node.attr('location')).path();
                    }).catch(function (err) {
                        return _this.svc + '/WsFed_passive';
                    });
                };
                /** this must return only a path because it'll be used as
                    the target for an XHR request and XHR requests cannot
                    be sent to other domains because of the same-origin policy */
                WebTicketService.prototype.getOAuthPath = function () {
                    var _this = this;
                    return this.getConfigXml().then(function (xml) {
                        // a regular expression cannot extract this URL, so using an XML parser
                        var node = XmlDoc(xml).root
                            .selectOne('wsdl:service', { name: 'WebTicketService' })
                            .selectOne('wsdl:port', { name: 'OAuth' })
                            .selectOne('soap:address');
                        return new URI(node.attr('location')).path();
                    }).catch(function (err) {
                        return _this.svc + '/OAuth';
                    });
                };
                /** The /Anon service gives anon meeting web tickets. */
                WebTicketService.prototype.getAnonPath = function () {
                    var _this = this;
                    return this.getConfigXml().then(function (xml) {
                        // a regular expression cannot extract this URL, so using an XML parser
                        var node = XmlDoc(xml).root
                            .selectOne('wsdl:service', { name: 'WebTicketService' })
                            .selectOne('wsdl:port', { name: 'WebTicketServiceAnon' })
                            .selectOne('soap:address');
                        return new URI(node.attr('location')).path();
                    }).catch(function (err) {
                        return _this.svc + '/Anon';
                    });
                };
                /** The last step is to exchange the RPSAuth/LyncWif cookie for a web ticket.
                    The client doesn't have access to these cookies and thus it cannot know whether
                    they exist or not, so it blindly sends a request in assumption that these cookies
                    exist. If they don't, the server will reply with an error message.
                    
                    There are two ways to get the web ticket: the old way to send an XML request
                    to /WsFed_Passive and the modern way to send a request to /oauthtoken. The second
                    approach is JS-friendly and is easier to use, but it gives web tickets with
                    invalid audience if the sign in user is homed on a pool different from the one
                    to which this request is sent.
                    
                    The same API can be used to exchange an OAuth token for a web ticket. In this case
                    the token is kept inside the iframe and is unavailable to the client, but the client
                    can send a POST to /OAuth to get a web ticket: the iframe will attach the OAuth token,
                    the web ticket service will check the token and return a web ticket. The created
                    web ticket has about the same lifetime as the OAuth token. */
                WebTicketService.prototype.getWebTicket = function (path, data) {
                    return this.send({
                        type: 'POST',
                        url: path,
                        headers: {
                            'SOAPAction': 'http://docs.oasis-open.org/ws-sx/ws-trust/200512/RST/Issue',
                            'Content-Type': 'text/xml; charset=utf-8'
                        },
                        data: data || xmlUserTokenRequest({
                            scope: this.root,
                            context: this.context || guid() // this must be a GUID - random values in other forms are rejected
                        })
                    }).then(function (rsp) {
                        // <RequestedSecurityToken>
                        //  <a:UserToken>cwt=...</a:UserToken>
                        // </RequestedSecurityToken>
                        if (Http.isSuccess(rsp.status))
                            return /<(?:a:)?UserToken.*?>(.+?)<\/(?:a:)?UserToken>/i.exec(rsp.responseText)[1];
                        else
                            throw Exception('WsFedRequestFailed', { response: rsp });
                    });
                };
                /** The web ticket must be then sent in the X-MS-WebTicket header. */
                WebTicketService.prototype.getAnonWebTicket = function (conf_uri, conf_key) {
                    var _this = this;
                    return this.getAnonPath().then(function (path) {
                        var data = xmlAnonTokenRequest({
                            conf_uri: conf_uri,
                            conf_key: conf_key,
                            scope: _this.root,
                            context: _this.context || guid() // this must be a GUID - random values in other forms are rejected
                        });
                        return _this.getWebTicket(path, data);
                    });
                };
                /** the web ticket service URL can be discovered
                    by looking at (GET /ucwa).X-MS-WebTicketURL */
                WebTicketService.prototype.getWebTicketServicePath = function () {
                    var _this = this;
                    var defaultPath = '/WebTicket/WebTicketService.svc';
                    return this.send({
                        type: 'GET',
                        url: '/ucwa'
                    }).then(function (rsp) {
                        var hdr = HttpHeaders(rsp.headers).get('X-MS-WebTicketURL');
                        _this.svc = new URI(hdr).path() || defaultPath;
                    }).catch(function (err) {
                        _this.svc = defaultPath;
                    });
                };
                /** The first step is to discover the URLs of the web ticket service.
                    There are two ways to do this: the old way to inspect the mex XML
                    and the modern way to inspect a 400 response from a POST to
                    the /WebTicket/oauthtoken handler. The second approach is JS-friendly,
                    but not reliable because instead of a 400 with the URL it may
                    return some random error. */
                WebTicketService.prototype.getConfigXml = function () {
                    var _this = this;
                    return this.mex = this.mex || this.getWebTicketServicePath().then(function () {
                        return _this.send({
                            type: 'GET',
                            url: _this.svc + '/mex'
                        });
                    }).then(function (rsp) {
                        if (Http.isSuccess(rsp.status))
                            return rsp.responseText;
                        else
                            throw Exception('MexRequestFailed', { response: rsp });
                    });
                };
                return WebTicketService;
            })();
            Auth.WebTicketService = WebTicketService;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var Http = Web.Utils.Http;
            var bind = Web.Utils.bind;
            var async = Web.Utils.async;
            var check = Web.Utils.check;
            var Exception = Web.Utils.Exception;
            var W3A = Web.Utils.WWWAuthenticateHeader;
            var HttpHeaders = Web.Utils.HttpHeaders;
            Auth.sW3A = 'WWW-Authenticate';
            Auth.sMSD = 'X-MS-Diagnostics';
            function EGrantTypeNotSupported(type, msra) {
                var text = 'grant_type=' + type + ' is not in the list: [' + msra.grant_type + ']';
                return Exception.call(text, 'GrantTypeNotSupported', { grant_type: type, msra: msra });
            }
            /**
             * It basically finds the "WWW-Authenticate" header in the
             * HTTP 401 response, extracts the URL of the auth service and
             * sends user name and password (if given) to that service.
             * The service responds with the token string.
             *
             * @param {Object|Function} params - An async function that gets a web ticket.
             *
             *  `params` can be an async function that is called whenever a new web ticket
             *  is needed. That function takes two parameters (another async function
             *  that sends HTTP requests and a parsed MsRtcOAuth section from the WWW-Authenticate
             *  headers) and returns a promise that resolves to a string with the
             *  compact web ticket. Thus this function can look like this:
             *
             *      function (send, msra) {
             *          msra.href == "https://lyncweb.com/WebTicket/oauthtoken";
             *          msra.grant_type == "password;urn:microsoft.rtc:windows";
             *          return sleep(1000).then(function () {
             *              return "Bearer cwt=ABCDEF";
             *          });
             *      }
             *
             *  This function only needs to get a new web ticket. All the logic of
             *  caching the web ticket, deciding when to renew it, when to give up
             *  renewing and so on is outside this function and is implemented in
             *  the MsRtcOAuth class.
             *
             *  `params` can be an object with a few parameters for the default
             *  procedure to get a web ticket: this procedure basically sends
             *  a POST request to MsRtcOAuth.href URL and parses the JSON response.
             *  This default procedure is implemented in MsRtcOAuth.get.
             *
             * @returns {Function} - An async function that acts as a layer in the HTTP stack.
             *
             *  This function is responsible to seamlessly authenticate all requests
             *  going thru it. It takes two parameters (a request object and another
             *  async function that sends a request and returns a response) and returns
             *  a response. Thus it may look like this:
             *
             *      function (req, send) {
             *          return sleep(1000).then(function () {
             *              req.headers['Authorization'] = "Bearer cwt=ABCDEF";
             *              return send(req);
             *          });
             *      }
             *
             * @created Jun 2013
             * @blame antonkh
             */
            function MsRtcOAuth(params, header) {
                if (header === void 0) { header = 'Authorization'; }
                var renew = async(params instanceof Function ? params : bind(MsRtcOAuth.get, params));
                var token = '';
                var dfd;
                var isNew = false;
                return function sendRequest(request, send) {
                    if (token) {
                        if (!request.headers)
                            request.headers = {};
                        request.headers[header] = token;
                    }
                    // Handles all HTTP responses and checks whether they indicate an
                    // authorization failure. If they do, it tries to obtain an auth
                    // token and resend the original request.
                    // 
                    // In theory, the server may keep responding with HTTP 401 or with HTTP 500
                    // and the client will thus keep trying to get the auth token. However
                    // this situation doesn't seem likely to happen and if it does happen,
                    // it should be handled by invoking the Task::cancel method.
                    return send(request).then(function processResponse(response, w3test) {
                        if (w3test === void 0) { w3test = false; }
                        var hdrs = HttpHeaders(response.headers);
                        var w3ah = hdrs.get(Auth.sW3A);
                        var msdh = hdrs.get(Auth.sMSD);
                        var code = msdh && msdh.split(';')[0];
                        var w3a;
                        try {
                            w3a = w3ah && W3A(w3ah);
                        }
                        catch (error) {
                            w3a = null;
                        }
                        // HTTP 401 Unauthorized
                        // WWW-Authenticate: MsRtcOAuth href="contoso.com/oauthtoken",grant_type="password"
                        if (response.status == 401 /* Unauthorized */ && w3a && w3a.MsRtcOAuth) {
                            // if the server rejects a new web ticket, no need to get another one -
                            // it will be rejected anyway
                            if (isNew)
                                return response;
                            // if renewing the token is taking too long, subsequent requests shouldn't
                            // start getting more tokens; otherwise in the passive auth after the rpsauth
                            // cookie expires, every subsequent request will result in a 401 and will
                            // create a new <iframe> to get a new token: in a few hours there will be hundreds
                            // of <iframe> elements that don't do anything
                            dfd = dfd || renew(send, w3a.MsRtcOAuth).then(function (cwt) {
                                token = cwt;
                                isNew = true;
                            }).finally(function () {
                                dfd = null;
                            });
                            return dfd.then(function () {
                                return sendRequest(request, send);
                            }).then(function (response) {
                                response.webTicketRenewed = true;
                                return response;
                            });
                        }
                        // 500 X-MS-Diagnostics: 28032;reason="The web ticket is invalid."
                        // 500 X-MS-Diagnostics: 28072;reason="The ticket presented could not be verified, a new ticket is required."
                        // 403 X-MS-Diagnostics: 28077;reason="Invalid Audience in the web ticket"
                        if (response.status == 401 /* Unauthorized */ || /^(28032|28072|28077)$/.test(code)) {
                            // if GET /ucwa/oauth didn't return the auth config,
                            // there is no need to send another such GET
                            if (w3test)
                                return response;
                            // if the server rejects a new web ticket, no need to get another one -
                            // it will be rejected anyway
                            if (isNew)
                                return response;
                            return send({
                                type: 'GET',
                                url: '/ucwa/oauth'
                            }).then(function (response) {
                                if (request.headers)
                                    delete request.headers[header];
                                // if this GET results in the same response, there is 
                                // no point to repeat the GET again: just fail the auth
                                return processResponse(response, true);
                            });
                        }
                        // HTTP 2xx
                        isNew = false;
                        return response;
                    });
                };
            }
            Auth.MsRtcOAuth = MsRtcOAuth;
            var MsRtcOAuth;
            (function (MsRtcOAuth) {
                /**
                 * Handles a response of the following form:
                 *
                 *      HTTP 401 Unauthorized
                 *      WWW-Authenticate: MsRtcOAuth ...
                 *
                 * @param {Object} msra - MsRtcOAuth from WWW-Authenticate header.
                 * @param {Object} data - Params that need to be sent in a POST in order to get a token.
                 * @param {Function} send - A function that sends a request and eventually returns a response:
                 *
                 *      send("GET", "/some/url").then(function (rsp) {
                 *          console.log(rsp.status);
                 *      });
                 *
                 * @returns {Promise<String>} - A promise object that resolves to the compact web ticket.
                 * @created antonkh, Jun 2013
                 */
                function get(data, send, msra) {
                    if (msra.grant_type.indexOf(data.grant_type) < 0)
                        throw EGrantTypeNotSupported(data.grant_type, msra);
                    return send({
                        type: 'POST',
                        url: msra.href,
                        data: data
                    }).then(function (response) {
                        if (!Http.isSuccess(response.status))
                            throw Exception('InvalidCreds', { response: response });
                        var parsed = JSON.parse(response.responseText);
                        check.belongs('token_type', parsed);
                        check.belongs('access_token', parsed);
                        return parsed.token_type + ' ' + parsed.access_token;
                    });
                }
                MsRtcOAuth.get = get;
                ;
            })(MsRtcOAuth = Auth.MsRtcOAuth || (Auth.MsRtcOAuth = {}));
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var random = Web.Utils.random;
            var URI = Web.Utils.URI;
            var W3A = Web.Utils.WWWAuthenticateHeader;
            var Task = Web.Utils.Task;
            var Promise = Web.Utils.Promise;
            var Exception = Web.Utils.Exception;
            var HttpHeaders = Web.Utils.HttpHeaders;
            function EOAuthFailed(args) {
                return Exception('OAuthFailed', args);
            }
            Auth.EOAuthFailed = EOAuthFailed;
            /**
             * Parses the X-Ms-Diagnostics header.
             *
             * X-MS-Diagnostics: 28032;source="contoso.com";reason="The web ticket is invalid."
             * X-MS-Diagnostics: 28072;source="contoso.com";reason="The ticket presented could not be verified, a new ticket is required."
             */
            function XMsDiagnostics(header) {
                var parts = (header || '').split(';');
                return {
                    code: +parts[0]
                };
            }
            /**
             * The OAuth2 implicit grant flow (RFC 6749, section 4.2).
             *
             * In the implicit auth flow the client creates a new <iframe> to get
             * a new access token. Let's say the client has sent a request to UCWA
             * and got a 401 in response:
             *
             *      GET /contacts
             *      Host: webdir.tip.lync.com
             *
             *      HTTP 401
             *      WWW-Authenticate: Bearer authorization_uri="https://login.windows.net/authorize"
             *
             * The client needs an access token for the webdir.tip.lync.com resource.
             * This can be achieved by sending a GET to the OAuth URI:
             *
             *      GET login.windows.net/authorize?response_type=token
             *          &client_id=...
             *          &state=...
             *          &resource=https://webdir.tip.lync.com
             *          &redirect_uri=https://webdir.tip.lync.com/xframe
             *
             *      HTTP 302
             *      Location: https://webdir.tip.lync.com/xframe#access_token=...
             *          &token_type=Bearer
             *          &state=...
             *          &expires_in=3599
             *
             * Since 302 responses cannot be inspected with XHR, the client has to implement
             * an HTML page and specify the URL of this page in the redirect_uri parameter.
             * Then this page will be loaded with the access token in its URL.
             *
             * To prevent malicious scripts from stealing the token, it's kept securely
             * inside that page. At the same time this token must be sent to UCWA in every
             * request in the Authorization header. To meet the two requirements the xframe
             * also serves as the landing page for the access token: this is a so called
             * private OAuth flow.
             *
             * Thus when the client sees a 401 response, it redirects the xframe to the OAuth URI
             * and the xframe object takes into account that there could be pending requests
             * with the old access token sent to UCWA before the 401 response. To handle this case
             * the xframe object creates a new iframe for new requests and keeps the old iframe
             * until all pending requests complete.
             *
             * In the public OAuth flow we are not trying to protect the token against malicious
             * scripts, justifying this by the fact that if such a script has managed to run in
             * current page (XSS) then it can do more harm than just stealing a *.lync.com
             * bounded token. This allows us to create an <iframe> and set redirect_uri to a non
             * existent page on the current site's domain: despite the host will reply with a 404,
             * it will still be possible to read the URL and extract #access_token=... from it.
             *
             * @created Aug 2014
             * @blame antonkh
             */
            function Implicit(_a) {
                var xframe = _a.xframe, client_id = _a.client_id, oauth_uri = _a.oauth_uri, _b = _a.state, state = _b === void 0 ? random() : _b, context = _a.context, _c = _a.use_cwt, use_cwt = _c === void 0 ? true : _c, redirect_uri = _a.redirect_uri, tm = _a.tm, _d = _a.document, document = _d === void 0 ? Web.window.document : _d, _e = _a.location, location = _e === void 0 ? Web.window.location : _e;
                // targets["login.windows.net/.../?...&redirect_uri=lync.com/xframe"] = "lync.com/xframe"
                var ready, targets = {}, ticket, nonce, attempt = 1;
                function isAuthRequired(rsp) {
                    // the impicit auth implementation needs to handle web ticket related error codes
                    // because it always exchanges the OAuth token for a web ticket to reduce load on the server
                    if (rsp.status == 401)
                        return true;
                    // sometimes the server doesn't send a 401 with the WWW-Authenticate header,
                    // but sends some random errors with the X-MS-Diagnostics header with a certain code:
                    // if this happens, the client can send a GET to /ucwa/oauth to get a proper 401 response
                    if (rsp.status == 500 || rsp.status == 403) {
                        var headers = HttpHeaders(rsp.headers);
                        var xmsdiag = XMsDiagnostics(headers.get(Auth.sMSD));
                        var code = xmsdiag.code;
                        // 500 X-MS-Diagnostics: 28032;reason="The web ticket is invalid."
                        // 500 X-MS-diagnostics: 28033;reason="The web ticket has expired."
                        // 500 X-MS-Diagnostics: 28072;reason="The ticket presented could not be verified, a new ticket is required."
                        // 403 X-MS-diagnostics: 28077;reason="Invalid Audience in the web ticket"
                        // 403 X-Ms-diagnostics: 28055;reason="The OAuth token is invalid.";faultcode="wsse:FailedAuthentication"
                        return code == 28032 || code == 28033 || code == 28072 || code == 28077 || code == 28055;
                    }
                    return false;
                }
                function getOAuthURI(rsp) {
                    // Currently the OAuth URI is given by the server in a WWW-Authenticate header.
                    // There is, however, a more general way of discovering this URI, known as OAuth URI discovery.
                    // At the moment this mechanism isn't implemented on the server.
                    var headers = HttpHeaders(rsp.headers);
                    var bearer = W3A(headers.get(Auth.sW3A))['Bearer'];
                    return bearer && bearer.authorization_uri;
                }
                return function sendRequest(req, send) {
                    function setAuthAndSend(req, refreshed) {
                        if (refreshed === void 0) { refreshed = false; }
                        // nonce is needed to use the token in the iframe
                        if (nonce)
                            req.nonce = nonce;
                        // if web ticket is available, it can be used directly
                        if (ticket) {
                            req.headers = req.headers || {};
                            req.headers['Authorization'] = ticket;
                        }
                        return send(req).then(function (rsp) {
                            if (refreshed)
                                rsp['webTicketRenewed'] = refreshed;
                            return rsp;
                        });
                    }
                    // if the iframe is getting a new access token, wait for it
                    return Task.wait(ready).then(function () {
                        return setAuthAndSend(req);
                    }).then(function (rsp) {
                        var wtsvc, src;
                        if (!isAuthRequired(rsp))
                            return rsp;
                        // TODO: Ideally, if the request was sent when the attempt value
                        //       when we got 401 was smaller than the current value, we may
                        //       try to resend the request since it may succeed with the new ticket.
                        if (ready)
                            return sendRequest(req, send);
                        ticket = null;
                        src = xframe.src();
                        // xframe.src serves as a URL of the resource which the client needs to get an access token for.
                        // However after receiving the first access token from AAD, xframe.src points to a URL on AAD and
                        // thus the next time the client might mistakenly assume that it needs an access token for AAD itself.
                        // The client needs to know that the URL on AAD indirectly refers to UCWA and to solve this problem
                        // the client has a mapping from xframe.src values to actual URLs of UCWA.                    
                        if (targets[src])
                            src = targets[src];
                        // to get the access token, the client needs to discover first the OAuth URI
                        // and the primary source of this URI is the web ticket service's mex config
                        wtsvc = new Auth.WebTicketService(new URI(src).path('').query('').hash('') + '', setAuthAndSend, context);
                        // 1. The URI given by UI takes precedence over any URI found elsewhere.
                        // 2. If authorization_uri can be found in the 401 response, get it from there.
                        // 3. Otherwise get the OAuth URI from the mex config.
                        ready = Task.wait(oauth_uri || getOAuthURI(rsp) || wtsvc.getOAuthUrl()).catch(function () {
                            // if the URI couldn't be found in mex, use an
                            // alternate route: the WWW-Authenticate header
                            return setAuthAndSend({
                                type: 'GET',
                                url: '/ucwa/oauth'
                            }).then(function (rsp) {
                                return getOAuthURI(rsp);
                            });
                        }).then(function (url) {
                            if (!url)
                                throw Exception('OAuthUriMissing', { response: rsp });
                            var uri = new URI(url);
                            var query = URI.Query(uri.query());
                            // to get a new token, the iframe needs to be redirected to a special URL;
                            // this URL is better to be unique every time, as otherwise the xframe may do nothing
                            nonce = state + '.' + attempt++;
                            query.response_type = 'token';
                            query.client_id = client_id;
                            query.redirect_uri = redirect_uri || src;
                            query.resource = new URI(src).path('').query('').hash('') + '';
                            query.state = nonce;
                            // The prompt=none parameter is supposed to replace the "X-Frame-Options: Deny" header with
                            // a meaningful error message. However due to a bug in the common AAD endpoint this parameter broke
                            // the auth flow. The workaround was to use the tenant-specific endpoint, i.e. to replace /common/ with,
                            // let's say, /microsoft.com/ in the AAD URL. By now, the bug should've been fixed. With this parameter,
                            // if AAD refuses to give a token, it returns an error message to the redirect_uri and thus the SDK
                            // can report an error to the UI. Without the parameter, the sign in never ends in this case.
                            query.prompt = 'none';
                            uri.query(query + '');
                            targets[uri + ''] = src;
                            return Task.run(function () {
                                // after xframe.src.set is done, an OAuth token will be in the iframe
                                return !redirect_uri ?
                                    xframe.src.set(uri + '') :
                                    Implicit.getToken(uri, location, document).then(function (t) { return ticket = t; }).then(function () { return null; });
                            }).then(function () {
                                // to reduce load on the server, the token can be exchanged for a web ticket;
                                // if something goes wrong during the exchange, the client should use the token
                                return use_cwt && wtsvc.getOAuthPath().then(function (path) {
                                    // the iframe checks the nonce of every request
                                    return wtsvc.getWebTicket(path);
                                }).then(function (cwt) {
                                    ticket = 'Bearer ' + cwt;
                                }).catch(function (err) {
                                    tm && tm.record('oauth_cwt_failed', { reason: err });
                                    ticket = null;
                                });
                            });
                        }).finally(function () {
                            ready = null;
                        });
                        // wait for an access token from AAD and resend the request:
                        // if it fails again, let the caller get the error response,
                        // as getting a yet another access token won't help
                        return Task.wait(ready).then(function () { return setAuthAndSend(req, true); });
                    });
                };
            }
            Auth.Implicit = Implicit;
            var Implicit;
            (function (Implicit) {
                /**
                 * Sends a GET to the given URL by creating a hidden <iframe>
                 * and extracts #access_token from the response.
                 *
                 * The URL must contain prompt=none in the query. Otherwise if
                 * AAD refuses to give a token, it will return a consent page
                 * with X-Frame-Options: Deny and the returned promise will never
                 * complete.
                 */
                function getToken(uri, location, document, tm) {
                    if (location === void 0) { location = Web.window.location; }
                    if (document === void 0) { document = Web.window.document; }
                    return new Promise(function (resolve, reject, progress) {
                        var redirect_uri = new URI(uri.query.get('redirect_uri'));
                        if (!redirect_uri.host())
                            uri.query.set('redirect_uri', new URI(location.href).path(redirect_uri.path()).query('').hash('') + '');
                        // another way to get a token is to create an iframe and use it to make
                        // the OAuth request with redirect_uri pointing to the current site:
                        // this will allow to read the actual iframe's URL with #access_token in it
                        var iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.src = uri + '';
                        document.body.appendChild(iframe);
                        var timer = tm && tm.timeout(5000, 'oauth_timeout', {
                            url: uri + ''
                        });
                        iframe.onload = function () {
                            try {
                                // the same origin policy allows to read the iframe's URL if that
                                // URL and the current page's URL belong to the same domain: this
                                // trick allows to read the access token and discard the <iframe>
                                var args = URI.Query(iframe.contentWindow.location.hash.slice(1));
                                document.body.removeChild(iframe);
                                timer && timer.cancel();
                                if (args.error) {
                                    // ...#error=invalid_resource&error_description=...
                                    reject(EOAuthFailed(args));
                                }
                                else {
                                    // ...#access_token=ABC&token_type=Bearer&state=123
                                    resolve(args.token_type + ' ' + args.access_token);
                                }
                            }
                            catch (err) {
                            }
                        };
                        progress('GET ' + uri);
                    });
                }
                Implicit.getToken = getToken;
            })(Implicit = Auth.Implicit || (Auth.Implicit = {}));
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var URI = Web.Utils.URI;
            var Task = Web.Utils.Task;
            var Exception = Web.Utils.Exception;
            /**
             * The passive auth is about exchanging a cookie set for the Lync server FQDN
             * for an access token for that FQDN. The full authentication flow consists of
             * three steps:
             *
             *  1. Redirect the user to the login page and let him sign in.
             *  2. Discover the Lync's passive auth URL and use it to get the cookie.
             *  3. Exchange the cookie for an access token.
             *
             * The first step requires the full page redirect and involves UI, so it's beyond
             * the scope of this library.
             *
             * The second step is meant to be done via a POST request to /oauthtoken which is
             * designed for JS web apps, but because of several bugs in /oauthtoken that do not
             * have workarounds, this library reads XML from /mex and finds there the passive
             * auth URL that usually ends with /PassiveAuth.aspx This URL is then used as the
             * source of a hidden iframe that loads the page, follows redirects if any and executes
             * JS code downloaded from a trusted site. The JS code sends a request to the Lync
             * server and in a response the server sends the RPSAuth or LyncWif cookie.
             *
             * The third step is meant to be done via the very same POST to /oauthtoken which is
             * designed for JS web apps, but because of another bug on the server, the library has
             * to send a SOAP request to /WsFed_Passive and extract the access token from a SOAP
             * response.
             *
             * @created May 2014
             * @blame antonkh
             */
            function Passive(doc) {
                // to simplify writing unit tests
                var document = doc || Web.window.document;
                // The function given to MsRtcOAuth is invoked every time a new web ticket
                // is needed. That function takes two parameters: 
                //
                //  1. A function to send HTTP requests on behalf of the Lync pool for which the web ticket is needed.
                //  2. The parsed MsRtcOAuth section from the WWW-Authenticate header.
                //
                // The function returns a promise that resolves to the web ticket.
                return Auth.MsRtcOAuth(function (send, msra) {
                    // The scope of the required web ticket can be extracted from MsRtcOAuth.
                    var aspx, cwts, root = new URI(msra.href).path('') + '', wtsvc = new Auth.WebTicketService(root, send);
                    return Task.wait(0).then(function () {
                        // The Task.waitAll below handles three possible error cases:
                        //
                        //  1. If the GET fails, the two default URLs must be taken.
                        //  2. If the GET succeeds but the regexp fails, only the default aspx URL must be taken.
                        //  3. If the GET succeeds but XmlDoc fails, only the default WsFed URL must be taken.
                        // 
                        return Task.waitAll([
                            wtsvc.getPassiveAuthUrl().then(function (url) {
                                aspx = url;
                            }),
                            wtsvc.getWsFedPassivePath().then(function (url) {
                                cwts = url;
                            }),
                        ]);
                    }).then(function () {
                        // The second step is to use the OrgID service URL to get the RPSAuth or LyncWif
                        // cookie for the Lync server FQDN. This can be done implicitly, without prompting
                        // for user credentials, because the user has already signed in to OrgID and the
                        // client browser has remembered auth cookies for the OrgID FQDNs.
                        //
                        // In order to get the RPSAuth/LyncWif cookie the client needs to download the HTML
                        // page located at the passive auth URL and process it as any other regular HTML page.
                        // This can be done with a hidden iframe.
                        var n = 0, tasks = [];
                        function awaitLoad(i) {
                            tasks[i] = new Task('waiting for the ' + i + '-th onload event from iframe at ' + aspx);
                            return tasks[i].promise;
                        }
                        var iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.src = aspx;
                        // The onload event may be fired multiple times:
                        //
                        //  - once if the RPSAuth/LyncWif cookie already exists
                        //  - twice if the OrgID cookies exist, but RPSAuth/LyncWif doesn't
                        //  - three times if the signed in user is federated and doesn't have OrgID cookies
                        //
                        iframe.onload = function () {
                            tasks[++n].resolve();
                        };
                        document.body.appendChild(iframe);
                        // Federated users aren't supported, so this implementation expects
                        // up to two onload events.
                        return Task.waitAny([
                            // one request to be sent immediately in case the RPSAuth cookie already exists
                            Task.wait(0).then(function () { return wtsvc.getWebTicket(cwts); }),
                            // one request to be sent after the frame loads one time in case Lync server doesn't redirect to OrgID
                            awaitLoad(1).then(function () { return wtsvc.getWebTicket(cwts); }),
                            // one request to be sent after the frame loads twice in case Lync server redirects to OrgID
                            awaitLoad(2).then(function () { return wtsvc.getWebTicket(cwts); })
                        ]).then(function (cwt) {
                            return 'Bearer ' + cwt;
                        }).finally(function () {
                            // No matter whether the web ticket received,
                            // the iframe needs to be removed. Notice, how
                            // this clean-up code doesn't alter the result
                            // and doesn't modify the exception.
                            document.body.removeChild(iframe);
                        });
                    }).catch(function (err) {
                        // If the web ticket cannot be obtained, provide the URL
                        // that needs to be followed to sign the user in.
                        throw aspx ? Exception('NotSignedIn', { aspx: aspx, reason: err }) : err;
                    });
                });
            }
            Auth.Passive = Passive;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            /**
             * It sends the credentials in plain text with grant_type=password
             * to get the auth token. Note, that the user name may differ from
             * the sign in address (which is used for auto discovery). For instance
             * auto discovery starts from "user1@contoso.com" but when asked
             * for credentials, the client is supposed to provide "group1\user1"
             * as the user name.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            function Basic(username, password) {
                return Auth.MsRtcOAuth({
                    grant_type: 'password',
                    username: username,
                    password: password
                });
            }
            Auth.Basic = Basic;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            /**
             * It sends grant_type=urn:microsoft.rtc:windows to the auth service, the latter
             * sends a special reply that is handled by the browser (it shows a popup window
             * to prompt for credentials) and then the browser sends a reply with the token
             * as though there was no NTLM negotiation between the first request and the last
             * response.
             *
             * Note, that not all browsers support this authentication.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            function Integrated() {
                return Auth.MsRtcOAuth({
                    grant_type: 'urn:microsoft.rtc:windows'
                });
            }
            Auth.Integrated = Integrated;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            /**
             * This kind of authentication is used to join an online meeting anonymously.
             * The client must know the URI of the meeting to sign in.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            function Anonymous(uri, key) {
                // this is how an online meeting uri looks like:
                // sip:user5@contoso.com;gruu;opaque=app:conf:focus:id:QHJ72TKK
                return Auth.MsRtcOAuth({
                    grant_type: 'urn:microsoft.rtc:anonmeeting',
                    ms_rtc_conferenceuri: uri,
                    password: key || uri.match(/:(\w+)$/)[1]
                });
            }
            Auth.Anonymous = Anonymous;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            var URI = Web.Utils.URI;
            /**
             * For most conferences the anon cwt must be issued by /WebTicket/oauthtoken,
             * while for some conferences the token must be issued by /WebTicket/WebTicketService.svc/Anon:
             *
             *      GET /WebTicket/WebTicketService.svc/mex
             *      POST /WebTicket/WebTicketService.svc/Anon + base64-encoded conference URI
             *      POST /ucwa/v1/applications + X-MS-WebTicket: cwt=...
             *
             * @created Dec 2015
             * @blame antonkh
             */
            function AnonMeetingInternal(conf_uri, conf_key) {
                if (conf_key === void 0) { conf_key = conf_uri.match(/:(\w+)$/)[1]; }
                return Auth.MsRtcOAuth(function (send, msra) {
                    var root = new URI(msra.href).path('') + '';
                    var wtsvc = new Auth.WebTicketService(root, send);
                    return wtsvc.getAnonWebTicket(conf_uri, conf_key);
                }, 'X-MS-WebTicket');
            }
            Auth.AnonMeetingInternal = AnonMeetingInternal;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Auth;
        (function (Auth) {
            'use strict';
            /**
             * Adds a token to every request:
             *
             *      Authorization: Bearer cwt=AAB...
             *
             * Once the token is given, it cannot be renewed.
             * The token is generated by the calling app and
             * is usually valid for 8 hours.
             */
            function Token(token) {
                return function (req, send) {
                    req.headers['Authorization'] = token;
                    return send(req);
                };
            }
            Auth.Token = Token;
        })(Auth = Web.Auth || (Web.Auth = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="utils.ts" />
/// <reference path="auth/WebTicketService.ts" />
/// <reference path="auth/MsRtcOAuth.ts" />
/// <reference path="auth/Implicit.ts" />
/// <reference path="auth/Passive.ts" />
/// <reference path="auth/Password.ts" />
/// <reference path="auth/Integrated.ts" />
/// <reference path="auth/Anonymous.ts" />
/// <reference path="auth/AnonMeetingInternal.ts" />
/// <reference path="auth/Token.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var clone = Web.Utils.clone;
            var assert = Web.Utils.assert;
            var extend = Web.Utils.extend;
            var values = Web.Utils.values;
            var filter = Web.Utils.filter;
            var foreach = Web.Utils.foreach;
            var isArray = Web.Utils.isArray;
            var isEmptyObject = Web.Utils.isEmptyObject;
            var Event = Web.Utils.Event;
            var Exception = Web.Utils.Exception;
            var Collection = Web.Utils.Collection;
            var BoolProperty = Web.Utils.BoolProperty;
            function ELinkMissing(resource, rel) {
                var text = resource.rel + '/' + rel + ' link does not exist';
                return Exception.call(text, 'LinkMissing', { resource: resource, rel: rel });
            }
            function ESingleLinkExpected(resource, rel) {
                var text = 'one ' + resource.rel + '/' + rel + ' link expected, ' + resource.links(rel).length + ' found';
                return Exception.call(text, 'SingleLinkExpected', { resource: resource, rel: rel });
            }
            function EAttrMissing(resource, name) {
                var text = resource.rel + '.' + name + ' property does not exist';
                return Exception.call(text, 'AttrMissing', { resource: resource, name: name });
            }
            /**
             * Resource is what UCWA server normally returns.
             *
             * The Resource concept was introduced by "Hypertext Application Language"
             * or "HAL" specification draft in
             *
             *      http://tools.ietf.org/html/draft-kelly-json-hal-05
             *
             * A resource has four aspects:
             *
             *      - it has a unique id (its "_links.self.href" attribute)
             *      - it has a type (its "rel" attribute)
             *      - it contains named properties (key-value pairs)
             *      - it points to other related resources
             *
             * It's noteworthy, that the related resources to which a resource
             * points, do not belong to the resource and are not embedded into
             * it - they are just somehow related. For example the "people" resource
             * is related to the "me" resource, a "contact" resource is related to
             * the "people" resource and at the same time the "me" resource
             * is related to the "contact" resource: the resource relations may
             * form loops with one or many nodes. In the implementation this
             * means that given a link to some related resource, this resource
             * can be loaded from the server and the loaded resource will have
             * links to other related resources, that can be also loaded and so on.
             *
             * @method get() - Returns a copy of all properties as a dictionary.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            var Resource = (function () {
                function Resource(raw) {
                    var self = { toString: toString };
                    var dirty = BoolProperty(false);
                    var isRemoved = false;
                    var rel, href, revision;
                    var related = {};
                    var embedded = {};
                    var properties = {};
                    var memberships = Collection(); // resource objects
                    var updated = new Event({
                        added: function (listener) {
                            listener();
                        }
                    });
                    var deleted = new Event({
                        added: function (listener) {
                            if (isRemoved)
                                listener();
                        }
                    });
                    //#region initialization
                    // Resource(href, rel) creates an empty resource with a given href and rel
                    if (arguments.length > 1) {
                        raw = {
                            rel: arguments[1],
                            _links: {
                                self: { href: arguments[0] }
                            }
                        };
                        // the default value is revision=1, so if it's 1, it can be omitted
                        if (arguments[2] > 1) {
                            revision = arguments[2];
                            raw._links.self.revision = revision;
                        }
                    }
                    init();
                    // the server does not always provide the "rel" attribute
                    rel = raw.rel || null;
                    revision = raw._links.self.revision;
                    //#endregion
                    //#region internal methods
                    function init() {
                        var links, resources, r, i, rel;
                        // the "href" attribute is mandatory, because this is the
                        // unique id of the resource
                        try {
                            href = raw._links.self.href;
                        }
                        catch (err) {
                            throw ELinkMissing(raw, 'self');
                        }
                        // extract related resources from _links in which
                        // _links[rel] is a link or an array of links to
                        // related resources
                        for (rel in raw._links) {
                            links = raw._links[rel];
                            if (!isArray(links))
                                links = [links];
                            related[rel] = links;
                        }
                        // extract related resources from _embedded in which
                        // _embedded[rel] is a resource or an array of related
                        // resources
                        if (raw._embedded) {
                            for (rel in raw._embedded) {
                                resources = raw._embedded[rel];
                                if (!isArray(resources))
                                    resources = [resources];
                                for (i = 0; i < resources.length; i++) {
                                    r = new Resource(resources[i]);
                                    // even if there is no property raw._embedded[rel].rel,
                                    // we know the type of the embedded resource
                                    r.rel = r.rel || rel;
                                    // Embedded mediaRelay resources of communication/mediaRelayAccessToken resource 
                                    // have the same href as the parent resource, so we fake the unique href:
                                    if (r.rel == 'mediaRelay' && r.href == href)
                                        r.href += '/' + r.properties.host + '/' + r.properties.location;
                                    embedded[r.href] = r;
                                    if (!related[rel])
                                        related[rel] = [];
                                    // the href entry may have already been added to related[rel] from raw._links
                                    if (!hasLink(rel, r.href))
                                        related[rel].push({ href: r.href });
                                }
                            }
                        }
                        // copy properties of the resource from its
                        // raw representation
                        for (i in raw)
                            properties[i] = raw[i];
                        // "rel" is the type name;
                        // "_links" and "_embedded" are not properties and
                        // just point to other related resources
                        delete properties.rel;
                        delete properties._links;
                        delete properties._embedded;
                    }
                    //#endregion
                    //#region public methods
                    //#region remove
                    function remove(reason) {
                        if (!isRemoved) {
                            isRemoved = true;
                            deleted.fire(reason);
                        }
                    }
                    //#endregion
                    //#region updateFrom
                    /**
                     * The server may return many incomplete representations of the same resource.
                     * The client must collect all properties from all representations of the same
                     * resource and put them into one resource object.
                     *
                     * This method takes another representation of the same resource and reads from it
                     * properties that this resource object is missing or have outdated.
                     *
                     * @param {Resource} source
                     */
                    function updateFrom(source) {
                        assert(self.href == source.href);
                        // override all properties and links of this resource
                        // with properties and links of the given resource
                        self.related = related = clone(source.related);
                        self.properties = properties = clone(source.properties);
                        embedded = {};
                        foreach(source.embedded, function (val, key) {
                            embedded[key] = new Resource(val.getSnapshot());
                        });
                        self.embedded = embedded;
                        dirty(false);
                        updated.fire();
                    }
                    //#endregion
                    //#region relatedHref
                    /**
                     * Returns the URL of a linked resource
                     *
                     * @param {string} rel - linked resource name
                     * @returns {string} - the URL of a linked resource if found, undefined otherwise
                     *
                     * @example
                     *      if resource has following links
                     *          "_links": { "photo": { "href": "/ucwa/photo" } }
                     *          then relatedHref('photo') == '/ucwa/photo';
                     */
                    function relatedHref(rel) {
                        var link = related[rel];
                        if (link)
                            return link[0].href;
                    }
                    //#endregion
                    //#region getSnapshot
                    function getSnapshot() {
                        var i, links, snapshot = { rel: rel };
                        for (i in properties)
                            snapshot[i] = properties[i];
                        snapshot._links = {
                            self: { href: href }
                        };
                        for (i in related) {
                            links = related[i];
                            if (links.length > 0)
                                snapshot._links[i] = links.length > 1 ? links : links[0];
                        }
                        return snapshot;
                    }
                    //#endregion
                    //#region toString
                    function toString(indent) {
                        if (indent === void 0) { indent = 4; }
                        var snapshot = getSnapshot();
                        if (!isEmptyObject(embedded))
                            snapshot._embedded = {};
                        // reconstruct _embedded: if the original resource was 
                        //   { rel: 'contact', 
                        //     _links: {'self': {href: '\contacts\john'}, 
                        //     _embedded: {'contactGroup': {rel: 'group', _links: {self: '\groups\friends'}} } }
                        // its internal representation in Resource is
                        //   related = { 'self': {href: '\contacts\john'},
                        //               'contactGroup' : {href: '\groups\friends'} };
                        //   embedded = {'\groups\friends': Resource({rel: 'group', _links: {self: '\groups\friends'}})}; 
                        //
                        foreach(snapshot._links, function (lnkVal, lnkKey) {
                            var v = values(filter(embedded, function (embVal, embKey) {
                                return embKey == lnkVal.href;
                            }));
                            if (v.length > 0) {
                                assert(v.length == 1);
                                snapshot._embedded[lnkKey] = v[0].getSnapshot();
                                delete snapshot._links[lnkKey];
                            }
                        });
                        return JSON.stringify(snapshot, null, indent)
                            .replace(/{\s*\n\s*("href"):\s*(".+?")\s*\n\s*}/gm, '{ $1: $2 }');
                    }
                    //#endregion
                    //#region forEachLink
                    /**
                     * Invokes a given callback for every link in the resource
                     * and all embedded resources. Every link has at least the "href"
                     * property.
                     *
                     * @param {Function} callback
                     */
                    function forEachLink(callback) {
                        foreach(related, function (links, rel) {
                            foreach(links, function (link) {
                                if (!embedded[link.href])
                                    callback(link, rel);
                            });
                        });
                        foreach(embedded, function (resource) {
                            resource.forEachLink(callback);
                        });
                    }
                    //#endregion
                    //#region addLink
                    function addLink(rel, href) {
                        if (!hasLink(rel, href)) {
                            if (!related[rel])
                                related[rel] = [];
                            related[rel].push({ href: href });
                            updated.fire();
                        }
                        return self;
                    }
                    //#endregion
                    //#region removeLink
                    function removeLink(rel, href) {
                        var i, links = related[rel];
                        if (links) {
                            for (i = 0; i < links.length; i++) {
                                if (links[i].href == href) {
                                    links.splice(i, 1);
                                    updated.fire();
                                    break;
                                }
                            }
                        }
                        return self;
                    }
                    //#endregion
                    //#region link
                    function link(rel) {
                        var links = related[rel];
                        if (!links || links.length == 0)
                            throw ELinkMissing(self, rel);
                        if (links.length > 1)
                            throw ESingleLinkExpected(self, rel);
                        return links[0];
                    }
                    //#endregion
                    //#region links
                    function links(rel) {
                        return related[rel] || [];
                    }
                    //#endregion
                    //#region hasLink
                    function hasLink(rel, href) {
                        var i, links = related[rel] || [];
                        if (!href)
                            return links.length > 0;
                        for (i = 0; i < links.length; i++)
                            if (links[i].href == href)
                                return true;
                        return false;
                    }
                    //#endregion
                    //#region set
                    function set(name, value) {
                        properties[name] = value;
                        updated.fire();
                        return self;
                    }
                    //#endregion
                    //#region get
                    function get(name, defaultValue) {
                        if (!name)
                            return clone(properties);
                        if (name == 'href')
                            return href;
                        if (name in properties)
                            return properties[name];
                        if (arguments.length == 1)
                            throw EAttrMissing(self, name);
                        return defaultValue;
                    }
                    //#endregion
                    //#region has
                    function has(name) {
                        return name == 'href' || name in properties;
                    }
                    //#endregion
                    //#endregion public methods
                    // TODO: The interface of this class desperately needs refactoring.
                    // In fact, Resource needs two interfaces: one with RW access for
                    // internal use in the stack layer and one RO for external use
                    // in the model layer. Currently both the stack and the model layer
                    // have RW access to every resource object.
                    return extend(self, {
                        href: href,
                        rel: rel,
                        revision: revision,
                        memberships: memberships,
                        properties: properties,
                        related: related,
                        embedded: embedded,
                        remove: remove,
                        updateFrom: updateFrom,
                        relatedHref: relatedHref,
                        updated: updated.observer,
                        deleted: deleted.observer,
                        forEachLink: forEachLink,
                        getSnapshot: getSnapshot,
                        dirty: dirty,
                        addLink: addLink,
                        removeLink: removeLink,
                        hasLink: hasLink,
                        link: link,
                        links: links,
                        has: has,
                        set: set,
                        get: get
                    });
                }
                return Resource;
            })();
            Stack.Resource = Resource;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var extend = Web.Utils.extend;
            var foreach = Web.Utils.foreach;
            var isFunction = Web.Utils.isFunction;
            /** Represents an event received from UCWA. */
            var ResourceEvent = (function () {
                function ResourceEvent(options) {
                    if (options === void 0) { options = {}; }
                    if (!(this instanceof ResourceEvent))
                        return new ResourceEvent(options);
                    extend(this, options);
                }
                /**
                 * This method is used for writing unit tests and debugging only.
                 * When the stack receives an event, it stringifies it and prints
                 * to the browser's console as a plain string. Because this string
                 * is a valid JS expression that constructs an event, it can be
                 * copied into a JS file with unit tests.
                 */
                ResourceEvent.prototype.toString = function () {
                    var pairs = [];
                    foreach(this, function (value, key) {
                        if (key == 'resource') {
                            if (value)
                                pairs.push('    "resource": ' + value);
                        }
                        else if (!isFunction(value))
                            pairs.push('    "' + key + '": ' + JSON.stringify(value));
                    });
                    return '{\n' + pairs.reverse().join(',\n') + '\n}';
                };
                return ResourceEvent;
            })();
            Stack.ResourceEvent = ResourceEvent;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var map = Web.Utils.map;
            var clone = Web.Utils.clone;
            var assert = Web.Utils.assert;
            var extend = Web.Utils.extend;
            var values = Web.Utils.values;
            var filter = Web.Utils.filter;
            var foreach = Web.Utils.foreach;
            var indexOf = Web.Utils.indexOf;
            var isArray = Web.Utils.isArray;
            var isString = Web.Utils.isString;
            var isFunction = Web.Utils.isFunction;
            var isNotEmptyString = Web.Utils.isNotEmptyString;
            var Event = Web.Utils.Event;
            /**
             * Repository keeps all resources available to the transport layer.
             * It provides functionality to search for existing resources.
             *
             * In UCWA terms, Repository acts as the Cache.
             *
             * @param [snapshot] - The initial state of the repository.
             * @param [connection] - The source of UCWA events.
             *
             *  This is what Repository::getSnapshot returns.
             *
             * @method put(resource) - Adds or updates a resource in the repository.
             * @method remove(href) - Removes a resource from the repository.
             * @method {Resource[]} get(selector) - Finds all resources matching the selector.
             *
             *     - get({ rel: 'me' }) - finds all resources with rel="me"
             *     - get('/me/car') - finds all resources with href="/me/car"
             *
             * @method getSnapshot - Returns a snapshot of the repository.
             *
             *  The snapshot is a mapping from resource rel to array of resource snapshots
             *  with the given rel. This is how a snapshot can be used:
             *
             *      var snapshot = repository.getSnapshot();
             *      var resource = Resource(snapshot.contact[0]);
             *
             * @created Jun 2013
             * @blame antonkh
             */
            var Repository = (function () {
                function Repository(_a) {
                    var _b = _a === void 0 ? {} : _a, connection = _b.connection, snapshot = _b.snapshot;
                    var self = { toString: toString };
                    var updated = new Event({
                        added: function (listener) { return listener(); }
                    });
                    // Every resource has a unique "href" value that is written in "r._links.self.href"
                    // if "r" refers to a resource returned by the server, then resources[href] is
                    // a Resource object which id is "href"
                    var resources = {};
                    // cache[rel] is an array of href values of all resources with the given "rel" attribute.
                    var cache = {};
                    //#region initialization
                    if (connection) {
                        connection.event(processEvent);
                        // Remove all resources from repository when disconnected
                        // from UCWA server to reset all properties.
                        connection.connected.when(false, function () {
                            foreach(resources, function (r) {
                                // TODO: if statement must be removed when comprehensive fix is done for all properties. 
                                // Its there to prevent breaking two unit tests.
                                if (r.rel == 'me')
                                    remove(r.href);
                            });
                        });
                    }
                    if (snapshot) {
                        foreach(snapshot, function (rs, rel) {
                            foreach(rs, function (r) {
                                r = clone(r);
                                r.rel = rel;
                                put(new Stack.Resource(r));
                            });
                        });
                    }
                    //#endregion
                    //#region private methods
                    /**
                     * Handles a UCWA event and updates resource objects in the repository.
                     * This method must be the very first handler among all handlers of UCWA
                     * events because it may need to modify the original event object to make
                     * it refer to resource objects in the repository.
                     */
                    function processEvent(event) {
                        var type = event.type;
                        var sender = event.sender;
                        var target = event.target;
                        var context = event['in'];
                        // the resource object is added to the repository even for
                        // "deleted" and "completed" events because event handlers
                        // may reasonably expect the resource from the event to be
                        // present in the repository
                        put(new Stack.Resource(sender.href, sender.rel), true);
                        if (event.resource) {
                            put(event.resource);
                            // an event handler may save a reference to event.resource
                            // and later check its state, so we want to replace event.resource
                            // with a reference to the resource in the repository, which
                            // may be updated later by UCWA events
                            event.resource = resources[event.resource.href];
                        }
                        else {
                            put(new Stack.Resource(target.href, target.rel), true);
                            // an empty "updated" event indicates that the state of the target resource
                            // has changed, but UCWA isn't sending its new state in the event: to get
                            // that state the client needs to send a GET request; so the resource object
                            // is only marked as obsolete and the stack leaves it up to the model layer
                            // to decide whether it's worth sending the GET
                            if (type == 'updated')
                                resources[target.href].dirty(true);
                        }
                        if (context) {
                            put(new Stack.Resource(context.href, context.rel), true);
                            if (type == 'added') {
                                resources[context.href].addLink(target.rel, target.href);
                                if (!resources[target.href].memberships(context.href))
                                    resources[target.href].memberships.add(resources[context.href], context.href);
                            }
                            if (type == 'deleted') {
                                resources[context.href].removeLink(target.rel, target.href);
                                if (resources[target.href].memberships(context.href))
                                    resources[target.href].memberships.remove(context.href);
                            }
                        }
                        if (type == 'deleted' || type == 'completed') {
                            // if the event target is a member of a collection then we should not delete it from
                            // the repository because the target may exist outside the collection; for instance
                            // when someone stops typing in a conversation, the server sends a "participant
                            // deleted in typingParticipants" event.
                            if (!context)
                                remove(target.href, event.reason); // event may contain a #reason property                        
                        }
                    }
                    //#endregion
                    //#region public methods
                    /**
                     * Adds a new resource to the repository or updates an existing resource
                     * in the repository.
                     *
                     * Since the resource may point to related resources, the procedure of adding
                     * a resource into the repository is recursive.
                     *
                     * @param {Resource} r
                     * @param {Boolean} isLink - Whether `r` was created from an empty link.
                     *
                     *      TODO: consider moving this parameter out of `put` and moving it
                     *      into the parameters list of the Resource's ctor.
                     */
                    function put(r, isLink) {
                        if (isLink === void 0) { isLink = false; }
                        if (!r.links)
                            r = new Stack.Resource(r);
                        if (!r.rel || !r.href)
                            return;
                        var href, rel, link, i, c;
                        var isNew = !resources[r.href];
                        updated.fire();
                        if (isNew) {
                            r.isLink = isLink;
                            resources[r.href] = r;
                            // if the only thing we know about a resource is its href,
                            // then the cached state of this resource is obviously invalid
                            if (isLink)
                                r.dirty(true);
                            if (!cache[r.rel])
                                cache[r.rel] = [];
                            cache[r.rel].push(r.href);
                        }
                        // put into the repository the minimum info ("rel" and "href"
                        // attributes) of those resources known to the given resource
                        for (rel in r.related) {
                            for (i = 0; i < r.related[rel].length; i++) {
                                link = r.related[rel][i];
                                href = link.href;
                                // we know nothing about a related resource except
                                // its "rel" and "href" attributes, so create a resource
                                // with these attributes and put it into the repository
                                //
                                // however, if the same resource is embedded, do not add
                                // it here, because this will fire the "added" event now and
                                // the "updated" event later, when the same resource gets updated
                                // from the embedded resource; this is not harmful, but the
                                // unnecessary "updated" event can be easily avoided in this case
                                if (!resources[href] && !r.embedded[href])
                                    put(new Stack.Resource(href, rel, link.revision), true);
                            }
                        }
                        // the resource also has embedded resources about which it knows
                        // more than just their "href" and "rel" attributes - put them
                        // into the repository as well
                        for (href in r.embedded)
                            put(r.embedded[href]);
                        // copy new properties of the resource into the repository
                        if (!isNew && !isLink) {
                            resources[r.href].updateFrom(r);
                            // UCWA may send a resource with one rel as a link of another resource
                            // and later send the same resource with a different rel. For instance
                            // when a rel=messagingInvitation arrives it has a rel=from link which
                            // in fact points to a rel=participant resource.
                            if (resources[r.href].isLink && resources[r.href].rel != r.rel) {
                                c = cache[resources[r.href].rel];
                                assert(c); // if this failed, `cache` and `resources` are unsynced
                                c.splice(indexOf(c, r.href), 1); // c.remove(r.href)
                                if (c.length == 0)
                                    delete cache[resources[r.href].rel];
                                if (!cache[r.rel])
                                    cache[r.rel] = [];
                                cache[r.rel].push(r.href);
                                resources[r.href].rel = r.rel;
                            }
                        }
                    }
                    /**
                     * Removes a resource from the repository.
                     */
                    function remove(href, reason) {
                        assert(isNotEmptyString(href));
                        var r = resources[href];
                        if (r) {
                            var c = cache[r.rel];
                            // remove href from cache[r.rel]
                            c.splice(indexOf(c, href), 1);
                            // remove r from resources
                            delete resources[href];
                            // mark the resource as removed
                            r.remove(reason);
                        }
                    }
                    /**
                     * Finds all resources that match the given selector:
                     * The selector can be:
                     *
                     *      - the "rel" attribute
                     *      - the "href" attribute
                     */
                    function get(selector) {
                        assert(isNotEmptyString(selector));
                        if (resources[selector])
                            return [resources[selector]];
                        if (cache[selector]) {
                            var hrefs = cache[selector];
                            var results = [];
                            for (var _i = 0; _i < hrefs.length; _i++) {
                                var href = hrefs[_i];
                                results.push(resources[href]);
                            }
                            return results;
                        }
                        return [];
                    }
                    /**
                     * Finds all resources that satisfies the given predicate
                     *
                     * @param {Resource => bool} predicate
                     * @returns {Resource[]} - The array of found resources, which can be empty.
                     */
                    function find(predicate) {
                        return values(filter(resources, predicate));
                    }
                    /**
                     * Gets a snapshot of the repository.
                     */
                    function getSnapshot(fn) {
                        var filteredCache = isFunction(fn) ? filter(cache, function (val, rel) { return fn(rel); }) : cache;
                        return map(filteredCache, function (hrefs) {
                            return map(hrefs, function (href) {
                                var rs = resources[href].getSnapshot();
                                delete rs.rel; // no need to store "rel" as it can be inferred from the snapshot
                                return rs;
                            });
                        });
                    }
                    function toString(indent) {
                        return JSON.stringify(getSnapshot(), null, indent);
                    }
                    //#endregion
                    return extend(self, {
                        put: put,
                        get: get,
                        find: find,
                        remove: remove,
                        updated: updated.observer,
                        getSnapshot: getSnapshot,
                        toString: toString
                    });
                }
                return Repository;
            })();
            Stack.Repository = Repository;
            var Repository;
            (function (Repository) {
                function expandSnapshot(snapshot) {
                    snapshot = clone(snapshot);
                    foreach(snapshot, function (resources, rel) {
                        if (!isArray(resources))
                            snapshot[rel] = resources = [resources];
                        foreach(resources, function (r, i) {
                            if (isString(r))
                                resources[i] = r = { _links: { self: { href: r } } };
                        });
                    });
                    return snapshot;
                }
                Repository.expandSnapshot = expandSnapshot;
            })(Repository = Stack.Repository || (Stack.Repository = {}));
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var check = Web.Utils.check;
            /**
             * The event channel with the server (the one to which the "events" resource points)
             * sends to the client resources that have the "sender" property. This property contains
             * a batch of events.
             *
             * The EventCollection is essentially a parser for the "sender" property.
             *
             * @param {Object[]} senders - The value of the "sender" property from the event resource.
             *
             * @example
             *
             *      var events = EventCollection(...);
             *      for (var i = 0; i < events.length; i++)
             *          if (events[i].type == 'added')
             *              ...
             *
             * @created Jun 2013
             * @blame antonkh
             */
            function EventCollection(senders) {
                var events = [];
                for (var _i = 0; _i < senders.length; _i++) {
                    var sender = senders[_i];
                    for (var _a = 0, _b = sender.events; _a < _b.length; _a++) {
                        var target = _b[_a];
                        var resource = null;
                        if (target._embedded)
                            for (var rel in target._embedded) {
                                check(!resource, 'Only one resource is expected in _embedded');
                                check(!resource, 'AlreadyExists', { item: 'embedded resource', resource: target });
                                resource = new Stack.Resource(target._embedded[rel]);
                                // don't rely that the embedded resource
                                // will have a proper rel attribute
                                resource.rel = resource.rel || rel;
                            }
                        var event_2 = {
                            resource: resource,
                            sender: { rel: sender.rel, href: sender.href },
                            target: target.link
                        };
                        for (var name_3 in target)
                            event_2[name_3] = target[name_3];
                        delete event_2['_embedded'];
                        delete event_2['link'];
                        events.push(new Stack.ResourceEvent(event_2));
                    }
                }
                return events;
            }
            Stack.EventCollection = EventCollection;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var Event = Web.Utils.Event;
            var Exception = Web.Utils.Exception;
            var BoolProperty = Web.Utils.BoolProperty;
            /**
             * The Connection is a persistent channel with the server over which it
             * sends events to the client.
             *
             * An event says that something has been changed in a particular resource.
             * In UCWA there are 2 types of resources that are structurally identical, but
             * have slightly different semantics and different sets of associated events.
             *
             * A regular resource, such as a rel=contact or a rel=participant, has three
             * associated events:
             *
             *      An "added" event says that the resource has been created.
             *      If the event contains the "in" link, then the resource has been
             *      added to a collection indicated by that "in" link.
             *
             *      An "updated" event says that the resource state has been
             *      invalidated and the next time the client needs to get any of
             *      its properties or links the client should first fetch the new resource
             *      state via a GET. The event may contain the new resource
             *      state, so that the client wouldn't need to send an extra GET.
             *
             *      A "deleted" event says that the resource has been deleted.
             *      If the event contains the "in" link, then the resource has
             *      been deleted from a collection indicated by that "in" link
             *      and can still belong to another collection or live outside
             *      any collections.
             *
             * An operation resource, such as rel=messagingInvitation, tracks the progress
             * of some asynchronous operation. Operation resources are usually returned
             * in the Location header of 201 responses to some POST requests and then
             * UCWA sends three type of events to update state of these resources:
             *
             *      A "started" event says that the operation has been started.
             *      The operation resource usually has the `operationId` property
             *      defined by the client when it sent a POST request to start the
             *      operation. The server doesn't necessarily send the "started"
             *      event: for instance when notifying of incoming messages it sends
             *      a single "message completed" event.
             *
             *      An "updated" event says that the operation state has been
             *      invalidated. Normally, the "updated" event for operation resources
             *      contains these resources, so the client doesn't need to send an extra
             *      GET to learn the new operation state.
             *
             *      A "completed" event says that the operation has succeeded or failed.
             *      After that no other events regarding this operation are sent, so
             *      the client may delete the resource.
             *
             * It's worth mentioning that the described semantics of events is implemented
             * outside the Connection class: the purpose of Connection is to get events from the
             * server and redirect them to listeners.
             *
             * The Connection is built on top of Endpoint, because it needs to seamlessly
             * bypass the authentication and get responses from the server in the form of
             * resources, and it's not built  on top of Application, because it doesn't
             * need its capability to seamlessly update the repository with arriving
             * events.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            var Connection = (function () {
                function Connection(endpoint) {
                    var eEvent = new Event();
                    var eError = new Event();
                    var pConnected = BoolProperty();
                    function getEvent(url, instanceId) {
                        endpoint.ajax({
                            type: 'GET',
                            url: url,
                            instanceId: instanceId,
                            priority: Infinity
                        }).then(function (eventBatch) {
                            if (eventBatch.hasLink('next'))
                                // normally the server provides the "next" link
                                // from which the next event can be received
                                getEvent(eventBatch.link('next').href, instanceId);
                            else if (eventBatch.hasLink('resume'))
                                // if the client disconnects and then reconnects to the
                                // server, the latter will provide the "resume" link
                                getEvent(eventBatch.link('resume').href, instanceId);
                            else if (eventBatch.hasLink('resync'))
                                // if the client tries to obtain events from an improper
                                // URL, the server will send the "resync" link
                                getEvent(eventBatch.link('resync').href, instanceId);
                            else
                                throw Exception('NextEventLinkMissing', { resource: eventBatch });
                            pConnected(true);
                            try {
                                notifyListeners(eventBatch.properties['sender']);
                            }
                            catch (error) {
                                eError.fire(error);
                            }
                        }).catch(function (error) {
                            // after the 410.LimitExceeded response, the event channel
                            // goes into a suspended state from which it can be recovered
                            // by another call to `connect`
                            if (!Stack.Endpoint.is410Error(error))
                                pConnected(false, error);
                        });
                    }
                    function notifyListeners(sender) {
                        var exists = {}, events = Stack.EventCollection(sender || []);
                        for (var _i = 0; _i < events.length; _i++) {
                            var e = events[_i];
                            var hash = e + '';
                            // There was a version of UCWA that duplicated some events
                            // for the first signed in tab in the multitab scenario.
                            // That bug duplicated events in the same event batch.
                            if (!exists[hash]) {
                                exists[hash] = true;
                                eEvent.fire(e);
                            }
                        }
                    }
                    return {
                        connect: getEvent,
                        connected: pConnected.asReadOnly(),
                        error: eError.observer,
                        event: eEvent.observer
                    };
                }
                return Connection;
            })();
            Stack.Connection = Connection;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var guid = Web.Utils.guid;
            var assert = Web.Utils.assert;
            var foreach = Web.Utils.foreach;
            var isVoid = Web.Utils.isVoid;
            var isString = Web.Utils.isString;
            var isDictionary = Web.Utils.isDictionary;
            var Http = Web.Utils.Http;
            var HttpHeaders = Web.Utils.HttpHeaders;
            function getRequestBody(request) {
                if (isVoid(request.data) || request.type == 'GET')
                    return '';
                if (isString(request.data))
                    return request.data + '';
                if (isDictionary(request.data))
                    return JSON.stringify(request.data);
                return request.data + '';
            }
            function getRequestHeaders(request) {
                var headers = HttpHeaders(request.headers);
                if (isDictionary(request.data))
                    headers.add('Content-Type', 'application/json');
                // the server requires this header to be present,
                // but does not seem to use it
                headers.add('Host', 'Host');
                return headers + '';
            }
            function getRequestUrl(request) {
                var query = '';
                if (request.type == 'GET') {
                    foreach(request.data || {}, function (value, name) {
                        query += (query ? '&' : '?') + name + '=' + value;
                    });
                }
                return request.url + query;
            }
            function serializeRequest(request) {
                var headers = getRequestHeaders(request);
                var body = getRequestBody(request);
                var url = getRequestUrl(request);
                return request.type + ' ' + url + ' HTTP/1.1\r\n' + headers + body;
            }
            function composeBatchRequestBody(requests, boundary) {
                var lines = [];
                for (var _i = 0; _i < requests.length; _i++) {
                    var r = requests[_i];
                    var text = serializeRequest(r);
                    lines.push('--' + boundary);
                    lines.push('Content-Type: application/http; msgtype=request');
                    lines.push('');
                    lines.push(text);
                }
                return lines.join('\r\n') + '\r\n--' + boundary + '--\r\n';
            }
            function getMaxPriority(requests) {
                var priority;
                for (var _i = 0; _i < requests.length; _i++) {
                    var r = requests[_i];
                    if (r.priority > priority || priority === undefined)
                        priority = r.priority;
                }
                return priority;
            }
            /**
             * This util function takes a string representing one response in a batch response
             * and splits it into the four parts: the outer headers, the http status line,
             * the inner headers, and the response body.
             *
             * @param block A part of the batch response that represents a single HTTP response:
             *
             *      Content-Type: application/http; msgtype=response\r\n
             *      \r\n
             *      HTTP/1.1 200 OK\r\n
             *      Cache-Control: no-cache\r\n
             *      Content-Type: application/json; charset=utf-8\r\n
             *      \r\n
             *      {"location":"Office"}\r\n
             */
            function split(block) {
                block = block.substring(2, block.length - 2);
                var i = block.indexOf('\r\n\r\n');
                var j = block.indexOf('\r\n', i + 4);
                var k = block.indexOf('\r\n\r\n', i + 4);
                assert(i > 0 && j > 0 && k > 0);
                return {
                    outer: block.substring(0, i),
                    status: block.substring(i + 4, j),
                    inner: block.substring(j + 2, k),
                    body: block.substring(k + 4)
                };
            }
            /**
             * The Batch is responsible for composing a single HTTP batch request
             * from several separate HTTP requests and for decomposing a HTTP batch
             * response into separate HTTP responses.
             *
             * Batch requests are sent to the "batch" UCWA resource, which is discussed
             * here: http://ucwa.lync.com/documentation/gettingstarted-batching
             *
             * @method compose - Composes a batch request.
             * @method parse - Parses a batch response.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            var Batch = (function () {
                function Batch(url) {
                    this.url = url;
                }
                Batch.prototype.compose = function (requests) {
                    var boundary = guid();
                    var body = composeBatchRequestBody(requests, boundary);
                    var priority = getMaxPriority(requests);
                    return {
                        type: 'POST',
                        priority: priority,
                        url: this.url,
                        data: body,
                        headers: {
                            'Content-Type': 'multipart/batching;boundary=' + boundary,
                            'Accept': 'multipart/batching'
                        }
                    };
                };
                Batch.prototype.parse = function (response) {
                    var headers = HttpHeaders(response.headers);
                    var boundary = headers.get('Content-Type').match(/boundary="(.*?)"/i)[1];
                    var blocks = response.responseText.split('--' + boundary);
                    assert(blocks.length > 2);
                    assert(blocks[blocks.length - 1] == '--\r\n');
                    var responses = [];
                    for (var _i = 0, _a = blocks.slice(+1, -1); _i < _a.length; _i++) {
                        var b = _a[_i];
                        try {
                            var parts = split(b);
                            var status_1 = +parts.status.match(/(\d{3})/)[1];
                            assert(status_1 >= 0);
                            responses.push({
                                status: status_1,
                                headers: parts.inner,
                                responseText: parts.body
                            });
                        }
                        catch (error) {
                            responses.push({
                                status: 417 /* ExpectationFailed */,
                                headers: '',
                                responseText: error + ''
                            });
                        }
                    }
                    return responses;
                };
                return Batch;
            })();
            Stack.Batch = Batch;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var async = Web.Utils.async;
            var random = Web.Utils.random;
            var foreach = Web.Utils.foreach;
            var URI = Web.Utils.URI;
            var Task = Web.Utils.Task;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            var EOAuthFailed = Web.Auth.EOAuthFailed;
            function EMixedContent(url) {
                var text = 'Insecure resource at ' + url + ' cannot be loaded.';
                return Exception.call(text, 'MixedContent', { url: url });
            }
            /**
             * Wraps the cross-domain UCWA's <iframe> element.
             *
             * The implementation is so complicated because it needs to switch
             * between xframes on different domains without dropping requests
             * that have already been sent to the previous xframe. To handle that
             * this implementation creates a new iframe when it's asked to switch
             * to a new xframe and keeps the old xframe if there are pending requests
             * in it. Once an xframe has no pending requests and is not current,
             * it's removed.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            var XFrame = (function () {
                function XFrame(windowmock, tm) {
                    var wnd = windowmock || Web.window;
                    var document = wnd.document;
                    var iframe; // the current <iframe> element
                    var iframes = {}; // iframes[iid] = an <iframe> element
                    var pending = {}; // pending[iid] = the number of pending requests for the iframe
                    var loaded = {}; // loaded[iid] = a task to track the progress of loading the iframe
                    var ready = {}; // ready[iid] = a task to track the progress of loading the xframe
                    var responses = {}; // responses[iid + ":" + rid] = Task<Response>
                    var pSrc = Property({
                        set: function (url) {
                            var uri = new URI(url);
                            // http: URLs are not allowed even if the parent
                            // page was loaded from a http: URL as it is the
                            // MS wide commitment for https: for end user
                            // communication; since all traffic goes thru the
                            // xframe, it's enough to block non-https URLs here
                            if (uri.scheme() != 'https')
                                throw EMixedContent(url);
                            // The src URL changes instantly because all further
                            // requests will be sent to the new URL.
                            pSrc._set(url);
                            // Never loading xframes are usually the OAuth ones:
                            // AAD doesn't return a proper 302 and JS waits forever.
                            var timer = tm && tm.timeout(5000, 'xframe_timeout', {
                                url: url
                            });
                            // However the caller may track the progress of redirecting
                            // the xframe and get notified once the new xframe is loaded.
                            return async(redirect)(url).then(function () {
                                timer && timer.cancel();
                                return url;
                            });
                        }
                    });
                    function reset() {
                        var error = Exception('Reset');
                        function reject(task) {
                            try {
                                task.reject(error);
                            }
                            catch (err) {
                            }
                        }
                        foreach(loaded, reject);
                        foreach(ready, reject);
                        foreach(responses, reject);
                        foreach(iframes, removeElement);
                        // We need to clear iframe onload handler if it exists
                        // it may be triggered and inside try to resolve promise that is already rejected
                        if (iframe)
                            iframe.onload = null;
                        iframe = null;
                        pending = {};
                        loaded = {};
                        ready = {};
                        responses = {};
                    }
                    /**
                     * Changes the "src" attribute of the <iframe>.
                     *
                     * Under the hood, it actually replaces the old <iframe>
                     * with a new one and does this in such a way that all pending
                     * requests sent thru the previous iframe don't get terminated.
                     *
                     * The `src` attribute of an iframe cannot be changed to a URL
                     * on a different domain: the same origin policy prohibits this.
                     * If JS code tries to change `src` in such a way, the browser
                     * silently removes the iframe without throwing any exceptions,
                     * keeps all the HTTP sessions initiated by the iframe open, but
                     * closes corresponding XMLHttpRequest objects with status 0, to make
                     * an impression that sessions have been terminated.
                     *
                     * To handle this the client creates a new iframe and sends all
                     * further requests thru it once it's loaded. The old iframe gets
                     * removed once all requests that were sent thru complete.
                     *
                     * @param {String} url - The new value for the "src" attribute of the <iframe>.
                     */
                    function redirect(url) {
                        var iid = random();
                        // `loaded` and `ready` are different because old xframes
                        // don't support the PING request; `loaded` gets resolved when
                        // the iframe gets something from the server and `ready`
                        // gets resolved when the iframe gets the actual UCWA's xframe
                        var tLoaded = new Task('iframe at ' + url);
                        var tReady = new Task('xframe at ' + url);
                        if (iframe && !pending[iframe.id])
                            remove(iframe.id);
                        iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.title = (new Web.Date).toJSON();
                        iframe.src = url;
                        iframe.id = iid;
                        // this event can be fired multiple times the server sends
                        // intermediate redirects or does full page posts
                        iframe.onload = function () {
                            if (tLoaded) {
                                tLoaded.resolve();
                                tLoaded = null;
                            }
                            // in IE the iframe may have been partially unloaded
                            // if the entire page is being unloaded
                            if (this.contentWindow)
                                post(this, { type: 'PING' });
                            else
                                tReady.reject();
                        };
                        document.body.appendChild(iframe);
                        iframes[iid] = iframe;
                        pending[iid] = 0;
                        loaded[iid] = tLoaded;
                        ready[iid] = tReady;
                        return tReady.promise;
                    }
                    function send(request) {
                        var target = iframe, id, task;
                        if (!target)
                            throw Exception('NoTarget');
                        id = target.id + ':' + random();
                        task = new Task({
                            cancel: function (reason) {
                                cleanup(id);
                                task.reject(reason);
                            }
                        });
                        responses[id] = task;
                        pending[target.id]++;
                        loaded[target.id].promise.then(function () {
                            task.status(request.type + ' ' + request.url);
                            post(target, request, id);
                        }, null, task.status);
                        return task.promise;
                    }
                    function post(iframe, request, id) {
                        request.messageId = id || iframe.id + ':' + random();
                        iframe.contentWindow.postMessage(JSON.stringify(request), '*');
                    }
                    function cleanup(id) {
                        var iid = id.split(':')[0]; // iframe id
                        delete responses[id];
                        pending[iid]--;
                        if (iid != iframe.id && !pending[iid])
                            remove(iid);
                    }
                    function processMessage(message) {
                        var data, id, iid, task;
                        try {
                            data = JSON.parse(message.data);
                            id = data.messageId;
                            iid = id.split(':')[0]; // iframe id
                            task = responses[id];
                            if (task) {
                                cleanup(id);
                                delete data.messageId;
                                task.resolve(data);
                            }
                            if (ready[iid]) {
                                // the OAuth2 redirect may end up with something like
                                // 302 Location: #error = login_required&error_description=...
                                if (data.oauth2 && data.oauth2.error)
                                    ready[iid].reject(EOAuthFailed(data.oauth2));
                                else
                                    ready[iid].resolve();
                                ready[iid] = null;
                            }
                        }
                        catch (_) {
                            // an error indicates that this message
                            // was sent to someone else and thus should
                            // be ignored
                            return;
                        }
                    }
                    function removeElement(element) {
                        try {
                            document.body.removeChild(element);
                        }
                        catch (err) {
                        }
                    }
                    function remove(iid) {
                        removeElement(iframes[iid]);
                        delete iframes[iid];
                        delete pending[iid];
                        delete loaded[iid];
                        delete ready[iid];
                    }
                    // when the iframe gets a request for the server, sends it to the server
                    // and gets a response, it sends that response via the "postMessage"
                    // function of the "window" object, so the message arrives in the "onmessage"
                    // event for "window"
                    if (wnd.addEventListener)
                        wnd.addEventListener('message', processMessage);
                    else
                        wnd.attachEvent('onmessage', processMessage); // IE
                    return {
                        src: pSrc,
                        send: async(send),
                        reset: reset
                    };
                }
                return XFrame;
            })();
            Stack.XFrame = XFrame;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var URI = Web.Utils.URI;
            var Promise = Web.Utils.Promise;
            var Property = Web.Utils.Property;
            /**
             * Encapsulates XMLHttpRequest.
             *
             * The main purpose of this class is to make XHR
             * look like XFrame interface-wise, as other stack
             * components already use XFrame.
             *
             * @created Oct 2015
             * @blame antonkh
             */
            var XHR = (function () {
                /** Must be XHR level 2 to support CORS. */
                function XHR(XHR2, tm) {
                    if (XHR2 === void 0) { XHR2 = Web.XMLHttpRequest; }
                    this.XHR2 = XHR2;
                    this.tm = tm;
                    /** Requests without FQDN are sent to this server. */
                    this.src = Property();
                }
                /**
                 * This method exists for compatibility with XFrame:
                 * different stack layers have to invoke this method
                 * to cleanup resources associated with the <iframe>
                 * element. With XHR there is nothing to deallocate.
                 */
                XHR.prototype.reset = function () {
                };
                /**
                 * Usually URL of the request is relative to the current
                 * server's URL which the stack is talking to: this URL is
                 * kept in the `src` property. However the target URL can be
                 * absolute: XHR level 2 with CORS support will be used in
                 * such cases.
                 */
                XHR.prototype.send = function (request) {
                    var _this = this;
                    return new Promise(function (resolve) {
                        var uri = new URI(request.url);
                        if (!uri.host()) {
                            // sending a request via XHR to a relative URL results in a request
                            // to the parent frame, which is not the desired behavior in an SDK
                            if (!_this.src())
                                throw Error('The target FQDN must be set to send relative requests.');
                            var src = new URI(_this.src());
                            uri.scheme(src.scheme()).host(src.host());
                            request.url = uri + '';
                        }
                        request.headers = request.headers || {};
                        // the absence of this header is treated differently in different browsers:
                        // some may set */*, while others may set something like application/xml
                        if (!request.headers['Accept'])
                            request.headers['Accept'] = '*/*';
                        // MsRtcOAuth needs this format
                        if (request.data && typeof request.data != 'string') {
                            request.data = URI.Query(request.data) + '';
                            request.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
                        }
                        // TODO: it's likely that this can be removed
                        if (request.type == 'GET' && request.data) {
                            debugger;
                            request.url = /^[^#]*/.exec(request.url)[0]; // remove the fragment after #...
                            request.url += (request.url.indexOf('?') < 0 ? '?' : '&') + request.data;
                            delete request.data;
                        }
                        var xhr = new _this.XHR2;
                        xhr.open(request.type, request.url, true);
                        for (var i in request.headers)
                            xhr.setRequestHeader(i, request.headers[i] + '');
                        xhr.onreadystatechange = function () {
                            if (xhr.readyState == 4 /* DONE */) {
                                if (!xhr.status && _this.tm)
                                    _this.tm.record('cors_failed', { type: request.type, url: request.url });
                                resolve({
                                    // in some cases IE replaces 204 with 1223
                                    status: xhr.status == 1223 ? 204 : xhr.status,
                                    statusText: xhr.statusText,
                                    headers: xhr.getAllResponseHeaders(),
                                    responseText: xhr.responseText
                                });
                            }
                        };
                        // in IE sending the undefined value results in sending a string "undefined"
                        xhr.send(request.data || null);
                    });
                };
                return XHR;
            })();
            Stack.XHR = XHR;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var sleep = Web.Utils.sleep;
            var throttle = Web.Utils.throttle;
            var removeAll = Web.Utils.removeAll;
            var repeatAndExit = Web.Utils.repeatAndExit;
            var HttpHeaders = Web.Utils.HttpHeaders;
            function ErrHandler(send, delay, status, filter) {
                return function (req) {
                    var next = delay();
                    return repeatAndExit(function (exit) {
                        return send(req).then(function (rsp) {
                            if (rsp.status != status || filter && !filter(rsp))
                                throw exit(rsp);
                            return sleep(next());
                        });
                    });
                };
            }
            /**
             * Transport allows to send cross-domain requests to the UCWA server only.
             * The UCWA server provides an iframe for this purpose, so as a web app
             * registered on the server can use its iframe to send cross domain requests
             * to it.
             *
             *      var xframe = XFrame('mydomain.com');
             *      var transport = Transport(xframe);
             *      transport.ajax({type:'GET', url:'/my/request?q=123'}).then(function(response){
             *          alert('response arrived');
             *      });
             *
             * @created Jun 2013
             * @blame antonkh
             */
            var Transport = (function () {
                function Transport(xframe, _a) {
                    var _b = _a === void 0 ? {} : _a, tm = _b.tm, buffer = _b.buffer, fmax = _b.fmax, _c = _b.fmin, fmin = _c === void 0 ? Math.pow(2, -64) : _c, _d = _b.delay, delay = _d === void 0 ? [] : _d, _e = _b.now, now = _e === void 0 ? function () { return Web.Date.now(); } : _e;
                    var send = new Web.Identity(function (req) { return xframe.send(req); }).map(function (send) {
                        if (!fmax)
                            return send;
                        // This layer is supposed to throttle identical requests:
                        // this is a defensive measure against improperly written
                        // code that keeps resending the same request in a loop.
                        // Such frequent requests are detected and reported via telemetry.
                        //
                        // The frequency of a request is a positive number defined as follows.
                        // Let's say request A has been sent 3 times: t1, t2 and t2
                        // seconds ago respectively. The frequency of A at this moment
                        // will then be:
                        //
                        //  A(0) = 2 ** -t1 + 2 ** -t2 + 2 ** -t3
                        //
                        // where 0 refers to the current moment in time. In dt seconds
                        // the frequency of A will reduce to:
                        //
                        //  A(dt) = 2 ** -(t1 + dt) + 2 ** -(t2 + dt) + 2 ** -(t3 + dt)
                        //
                        // It can be noted, that A(dt) = A(0) * 2 ** -dt. Thus
                        // the frequency of A can be recomputed any time later
                        // without the need to keep all the timestamps when A
                        // was sent.
                        //
                        // It can be seen that if A is resent every dt seconds, its frequency
                        // will approach 1/(1 - 2 ** -dt), which is 2.0 if dt = 1 second:
                        //
                        //  A(0) = 1 + 2 ** -t + 2 ** -2*t + 2 ** -3*t + ... -> 1/(1 - 2 ** -t)
                        //
                        // As long as the frequency of a request doesn't exceed a certain
                        // threshold, it's sent without a delay. Once the threshold is
                        // exceeded, the request is delayed and resent only when A(0) = the threshold.
                        //
                        // TODO: Nothing prevents to change the threshold at runtime and keep
                        // a unique threadhold value for each request.
                        var freq = {};
                        var log2 = function (x) { return Web.Math.log(x) / Web.Math.log(2); };
                        // when freq[...] was last updated
                        var updated = 0;
                        return function self(req) {
                            var ts = now();
                            var dt = (ts - updated) / 1000;
                            for (var id_1 in freq)
                                freq[id_1] /= Math.pow(2, dt);
                            // it seems right to constrain the growth of freq[...]
                            // and a reasonable way to do so is to remove requests
                            // that were sent long long ago and thus are unlikely
                            // to affect the total frequency value
                            removeAll(freq, function (fq) { return fq < fmin; });
                            updated = ts;
                            var id = req.type + ' ' + req.url;
                            var fq = freq[id] || 0;
                            // the request has been sent a few times in past and thus
                            // its current frequency at the moment is fq; sending the
                            // request again would change the frequency to fq + 2 ** 0
                            // and it must be lower than the threshold fmax; if it exceeds
                            // fmax, then the request can be delayed by a short period dt;
                            // after the delay, the frequency will be fq / 2 ** dt + 1 = fmax,
                            // which implies that dt = log2(fq / (fmax - 1))
                            if (fq + 1 > fmax) {
                                var dt_1 = log2(fq / (fmax - 1));
                                tm && tm.record('repeating_request', { type: req.type, url: req.url });
                                // the actual delay is always a bit longer than dt and hence
                                // after the delay the frequency will be a bit less than fmax
                                return sleep(dt_1).then(function () { return self(req); });
                            }
                            else {
                                freq[id] = fq + 1;
                                return send(req);
                            }
                        };
                    }).map(function (send) {
                        if (!buffer)
                            return send;
                        // this stack layer throttles requests and browsers
                        // do not like when there are too many pending requests;
                        // throttling is disabled only in some unit tests
                        var throttled = throttle(send, buffer);
                        return function (request) { return throttled(request, request.priority); };
                    }).map(function (send) {
                        // if the laptop's lid is closed and reopened, xhr
                        // will terminate all requests with status = 0;
                        // such requests need to be sent again
                        return !delay[0] ? send : ErrHandler(send, delay[0], 0);
                    }).map(function (send) {
                        // If the server is unreachable for some reason, we'll be getting
                        // 502 responses. This often happens when moving from WiFi network
                        // to another.
                        // If the server is unreachable with Content-Type other than
                        // 'application/json' or 'application/xml', it indicates the
                        // HADR scenario where retrying is unlikely going to work.
                        // Currently handling is to return the error to let event
                        // channel close, causing ucwa to disconnect and application
                        // to sign out. The UI should subscribe to the application
                        // status and notify the user to re-login later.
                        //
                        // TODO: restart auto discovery without signing out.
                        return !delay[502] ? send : ErrHandler(send, delay[502], 502, function (rsp) {
                            return !rsp.headers || /^application\/.*(json|xml)/.test(HttpHeaders(rsp.headers).get('Content-Type'));
                        });
                    }).map(function (send) {
                        // A 503 service unavailable indicates that there is some maintenance activity
                        // in the data center, and the application should retry with an exponential back off.
                        // After about 10 minutes of receiving 503 responses, the application should quit
                        // retrying and start the sign in process from the beginning (using auto discovery).
                        // If the application receives another response before the retry algorithm abandons
                        // the retries, such as 404.ApplicationNotFound, it should process this response as
                        // it usually would.
                        return !delay[503] ? send : ErrHandler(send, delay[503], 503);
                    }).value;
                    return {
                        ajax: send
                    };
                }
                return Transport;
            })();
            Stack.Transport = Transport;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var map = Web.Utils.map;
            var async = Web.Utils.async;
            var repeatAndExit = Web.Utils.repeatAndExit;
            var Task = Web.Utils.Task;
            var Exception = Web.Utils.Exception;
            function EDiscoveryFailed(domain, reason) {
                var text = 'UCWA not found on ' + domain;
                return Exception.call(text, 'DiscoveryFailed', { reason: reason, domain: domain });
            }
            /**
             * Discovers the UCWA service URL.
             *
             * An instance of this class takes a domain name and
             * discovers the UCWA server. The result of the discovery is
             * the "root" resource received from the server and the "root"
             * resource has a link to the "user" resource from which the
             * authentication starts and from which the client gets links to
             * all other resources.
             *
             * @param {XFrame} xframe - The auto-discovery process updates the source of the xframe.
             * @param {string} [domain] - The domain name, e.g. "contoso.com"
             * @param {Array} [origins] - Autodiscover URLs.
             * @param {Function} [XFrame] - Constructor of XFrame. Used by unit tests.
             * @param {Function} [Transport] - Constructor of Transport. Used by unit tests.
             *
             * @member {Promise<Resource>} root - The "root" resource with a link to the "user" resource.
             *
             * @blame antonkh
             * @created Jun 2013
             */
            function AutoDiscovery(options) {
                var domain = options.domain;
                var origins = options.origins;
                var TransportCtor = options.Transport || Stack.Transport;
                var XFrameCtor = options.XFrame || Stack.XFrame;
                var xframe = options.xframe;
                function discoverRoot(options) {
                    var internal = options.internal;
                    var xframeUrl = options.xframe;
                    var originUrl = options.origin;
                    var xframe = new XFrameCtor();
                    var transport = new TransportCtor(xframe);
                    xframe.src(xframeUrl);
                    // send a GET request to the current discovery URL,
                    // such as https://lyncdiscover.contoso.com
                    return transport.ajax({
                        type: 'GET',
                        url: originUrl
                    }).then(function (response) {
                        // extract the response text and parse it:
                        // it's supposed to be a valid UCWA resource
                        var root = new Stack.Resource(JSON.parse(response.responseText));
                        return repeatAndExit(function (exit) {
                            // GET webdir.online.lync.com/.../?sipuri=... doesn't return rel=user.
                            // Instead it gives a rel=redirect which is the rel=root for the given SIP URI.
                            if (!root.hasLink('redirect'))
                                return exit();
                            xframe.src(root.link('xframe').href);
                            return transport.ajax({
                                type: 'GET',
                                url: root.link('redirect').href
                            }).then(function (response) {
                                root = new Stack.Resource(JSON.parse(response.responseText));
                            });
                        }).then(function () {
                            // the UCWA server doesn't always specify the rel for the root resource
                            root.rel = root.rel || 'root';
                            root.set('internal', internal);
                            // the UCWA server may provide a new URL of the iframe
                            if (root.hasLink('xframe'))
                                xframe.src(root.link('xframe').href);
                            else
                                root.addLink('xframe', xframe.src());
                            return root;
                        });
                    }).catch(function (error) {
                        // wrap the error into a specific discovery-related error
                        throw EDiscoveryFailed(domain || origins[0].origin, error);
                    }).finally(function () {
                        // remove the xframe no matter whether the discovery succeeded or not:
                        // the caller of this function will create another xframe based on what
                        // this function returned
                        xframe.reset();
                    });
                }
                function discoverUcwa() {
                    // http://ucwa.lync.com/documentation/GettingStarted-RootURL
                    if (!origins) {
                        origins = [];
                        origins.push({
                            internal: true,
                            origin: 'https://lyncdiscoverinternal.' + domain,
                            xframe: 'https://lyncdiscoverinternal.' + domain + '/xframe'
                        });
                        origins.push({
                            internal: false,
                            origin: 'https://lyncdiscover.' + domain,
                            xframe: 'https://lyncdiscover.' + domain + '/xframe'
                        });
                        origins.push({
                            internal: true,
                            origin: 'http://lyncdiscoverinternal.' + domain,
                            xframe: 'http://lyncdiscoverinternal.' + domain + '/xframe'
                        });
                        origins.push({
                            internal: false,
                            origin: 'http://lyncdiscover.' + domain,
                            xframe: 'http://lyncdiscover.' + domain + '/xframe'
                        });
                    }
                    // try all auto-discovery URLs concurrently and if one
                    // succeeds, stop trying all other pending URLs
                    return Task.waitAny(map(origins, async(discoverRoot)));
                }
                return {
                    root: discoverUcwa().then(function (root) {
                        // The current implementation of concurrent autodiscovery
                        // creates a separate xframe for every auto-discovery URL
                        // and tries to get the rel=root resource. After one of
                        // xframes finds the rel=root, all xframes are removed and a
                        // completely separate xframe is directed to the found URL.
                        // This behavior is somewhat suboptimal and it would be better
                        // to change the interface of the auto-discovery class and
                        // make it return a pair [xframe, root] to avoid recreating
                        // an already existing xframe. But changing the interface would
                        // require to change all the stack-level samples and since I'm
                        // going to wrap all the stack layer into a UCWA class anyway,
                        // I'm postponing the change of the auto-discovery interface
                        // until that moment. But anyway, the auto-discovery time is
                        // reduced dramatically even with this suboptimal implementation.
                        xframe.src(root.link('xframe').href);
                        return root;
                    })
                };
            }
            Stack.AutoDiscovery = AutoDiscovery;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var HttpHeaders = Web.Utils.HttpHeaders;
            /**
             * Converts a multi part representation of resources into an array of resources.
             *
             * UCWA may return an HTTP response of the multipart/related type with parts
             * in the response text. Some parts contain JSON serialized resources,
             * while other parts contain data with Content-ID and Content-Type headers.
             * Resources may have links of form "cid:ABC" where "ABC" is the value of one of
             * Content-ID headers in the multipart response.
             *
             * This function parses those parts that represent resources, then checks every link
             * in these resources and if that link is something like "cid:ABC" the function looks for
             * a part with Content-ID:ABC and if such a part exists, it replaces the link with
             * a data URI that containing the found part. For example, if there was
             * a link of the following form:
             *
             *      "_links": {
             *          "mediaAnswer":{"href":"cid:0fced42f-b345-4294-95f0-9fc2f7882ade"}
             *      }
             *
             * and if there was a corresponding part:
             *
             *      Content-Type: application/sdp; charset=utf-8
             *      Content-ID: 0fced42f-b345-4294-95f0-9fc2f7882ade
             *
             *      v=0
             *      s=session
             *
             * the link will be converted to a data URI:
             *
             *      "_links": {
             *          "mediaAnswer":{"href":"data:application/sdp;charset=utf-8,v=0\r\ns=session"}
             *      }
             *
             * which can be parsed with the DataUri class.
             */
            function parseMultipartResources(/** from parseMultipartRelatedResponse */ parts) {
                var resources = [];
                var contents = {};
                for (var _i = 0; _i < parts.length; _i++) {
                    var part = parts[_i];
                    var content = part.responseText;
                    var headers = HttpHeaders(part.headers);
                    var contentId = headers.get('Content-ID');
                    var contentType = headers.get('Content-Type');
                    if (!contentId)
                        resources.push(new Stack.Resource(JSON.parse(content)));
                    else {
                        contents['cid:' + contentId] = {
                            data: content,
                            mime: contentType.replace(/\s/g, '')
                        };
                    }
                }
                for (var _a = 0; _a < resources.length; _a++) {
                    var resource = resources[_a];
                    resource.forEachLink(function (link) {
                        var content = contents[link.href];
                        if (content)
                            link.href = 'data:' + content.mime + ',' + content.data;
                    });
                }
                return resources;
            }
            Stack.parseMultipartResources = parseMultipartResources;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var check = Web.Utils.check;
            var Exception = Web.Utils.Exception;
            var HttpHeaders = Web.Utils.HttpHeaders;
            var ContentTypeHeader = Web.Utils.ContentTypeHeader;
            var rxCRLF2 = /(\r\n|\n){2}/;
            var rxCRLFL = /^(\r\n|\n)/;
            var rxCRLFR = /(\r\n|\n)$/;
            var rxEnding = /--\s*$/;
            /**
             * Parses a multipart/related response that has the following form:
             *
             *      HTTP/1.1 200 OK
             *      Content-Type: multipart/related; charset=utf-8; boundary=e6c28643-44ea-45c8-b62e-6a56bd22b3aa
             *
             *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa
             *      Content-Type: application/vnd.microsoft.com.ucwa+json; charset=utf-8
             *
             *      {"_links":{"self":{"href":"/ucwa/v1/applications/111415042852/events?ack=4"},"next...
             *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa
             *      Content-Type: application/sdp; charset=utf-8
             *      Content-ID: 0fced42f-b345-4294-95f0-9fc2f7882ade
             *
             *      v=0...
             *      --e6c28643-44ea-45c8-b62e-6a56bd22b3aa--
             */
            function parseMultipartRelatedResponse(response) {
                try {
                    var contentType = ContentTypeHeader(HttpHeaders(response.headers).get('Content-Type'));
                    check.equals(contentType.mimeType, 'multipart/related');
                    check.belongs('boundary', contentType.attributes);
                    var parts = response.responseText.split('--' + contentType.attributes['boundary']);
                    check(rxEnding.test(parts[parts.length - 1]));
                    check(parts.length >= 3);
                    return parts.slice(+1, -1).map(function (part, index) {
                        var crlf2 = rxCRLF2.exec(part);
                        if (!crlf2)
                            throw Exception('SingleHeaderExpected', { part: part, index: index });
                        var headers = part.substr(0, crlf2.index);
                        var content = part.substr(crlf2.index + crlf2[0].length);
                        return {
                            headers: headers.replace(rxCRLFL, ''),
                            responseText: content.replace(rxCRLFR, '')
                        };
                    });
                }
                catch (error) {
                    throw Exception('InvalidMultipartRelatedResponse', { response: response, reason: error });
                }
            }
            Stack.parseMultipartRelatedResponse = parseMultipartRelatedResponse;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var keys = Web.Utils.keys;
            var check = Web.Utils.check;
            var filter = Web.Utils.filter;
            var values = Web.Utils.values;
            var isObject = Web.Utils.isObject;
            /**
             * Parses the "application/vnd.microsoft.rtc.autodiscover+json;v=1" format
             * of the resource object. This format is used in a special auto-discovery
             * flow. An example of such a resource:
             *
             *      {
             *          "User": {
             *              "Links": [
             *                  { "href": "http://webdir1D.tip.lync.com/.../root", "token": "Redirect" },
             *                  { "href": "https://webdir0d.tip.lync.com/.../root/user", "token": "Self" },
             *                  { "href": "http://webdir1D.tip.lync.com/.../root/xframe", "token": "XFrame" }],
             *              "SipClientExternalAccess": null,
             *              "SipClientInternalAccess": null,
             *              "SipServerExternalAccess": null,
             *              "SipServerInternalAccess": null
             *          }
             *      }
             *
             * The Resource object created from this sample input will have rel=user
             * and will have links rel=redirect and rel=xframe. Rels are lowercased.
             */
            function parseAutodiscoverResource(json) {
                var roots = filter(json, isObject);
                check(values(roots).length == 1, 'single root expected');
                var rel = keys(roots)[0];
                var root = roots[rel];
                var selfs = filter(root.Links, function (link) { return link.token == 'Self'; });
                check(selfs.length == 1, 'single self href expected');
                var href = selfs[0].href;
                var res = new Stack.Resource(href, rel.toLowerCase());
                for (var _i = 0, _a = root.Links; _i < _a.length; _i++) {
                    var link = _a[_i];
                    if (link.href != href)
                        res.addLink(link.token.toLowerCase(), link.href);
                }
                return res;
            }
            Stack.parseAutodiscoverResource = parseAutodiscoverResource;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="parsers/multipart.ts" />
/// <reference path="parsers/multipart-related.ts" />
/// <reference path="parsers/autodiscover.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var map = Web.Utils.map;
            var bind = Web.Utils.bind;
            var async = Web.Utils.async;
            var sleep = Web.Utils.sleep;
            var assert = Web.Utils.assert;
            var foreach = Web.Utils.foreach;
            var isObject = Web.Utils.isObject;
            var isString = Web.Utils.isString;
            var debounced = Web.Utils.debounced;
            var getOption = Web.Utils.getOption;
            var Http = Web.Utils.Http;
            var Task = Web.Utils.Task;
            var Event = Web.Utils.Event;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            var HttpHeaders = Web.Utils.HttpHeaders;
            function ERequestFailed(req, rsp) {
                var text = req.type + ' ' + req.url + ' failed: ' + (rsp.statusText || rsp.status);
                return Exception.call(text, 'RequestFailed', { req: req, rsp: rsp });
            }
            Stack.ERequestFailed = ERequestFailed;
            /**
             * Endpoint exposes the "ajax" function that behaves like jQuery.ajax
             * and allows to send JSON requests to the UCWA server seamlessly passing
             * thru the authorization - Endpoint obtains the auth token.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            var Endpoint = (function () {
                function Endpoint(args) {
                    var renewed = new Event;
                    var transport = args.transport;
                    var batchRetryDelay = args.batchRetryDelay || 3.0;
                    var authorize = async(args.auth);
                    var restore = args.restore && debounced(args.restore);
                    var replace = args.replace && debounced(args.replace);
                    var enableInternalNS = getOption(args, 'enableInternalNS', true);
                    var id = args.id;
                    var tm = args.tm;
                    //#region suspend/resume
                    var resumed; // if present, all requests must wait for this
                    var tResumed; // the source of `resumed`
                    var suspended = Property({
                        value: false,
                        set: function (value, reason) {
                            if (value) {
                                tm && tm.record('endpoint_suspend', { reason: reason });
                                assert(!resumed); // the 410 response is suspending the stack
                                tResumed = new Task(reason + '');
                                resumed = tResumed.promise;
                                resumed.finally(function () { return resumed = tResumed = null; });
                                return value;
                            }
                            else {
                                tm && tm.record('endpoint_resume', { reason: reason });
                                assert(resumed); // the user activity is resuming the stack
                                resumed = null; // no need to queue requests as the app is being resumed
                                return tResumed.from(replace()).then(function () { return value; });
                            }
                        }
                    });
                    //#endregion
                    //#region batch
                    /**
                     * Sends a batch request and parses the batch response.
                     *
                     * Under the hood it modifies each request, composes them
                     * into a single batch request, adds the authorization header
                     * to it and sends to the batch URL. When the batch response
                     * arrives, it decomposes it into separate responses, parses them
                     * and resolves the returned promise object with the array
                     * of responses.
                     *
                     * @param {Batch} composer - The composer of the batch requests.
                     * @param requests - The array of requests.
                     *
                     * @returns {Promise<Promise<Resource>[]>}
                     *
                     *      The function returns a promise that resolves to an array of
                     *      promises. Each of these promises resolve to a resource.
                     */
                    function batch(composer, requests) {
                        foreach(requests, prepare);
                        var batchreq = composer.compose(requests);
                        return sendBatch(batchreq).then(function (batchrsp) {
                            // Batch requests often fail with HTTP 429 Too Many Requests
                            // and if this happens, resend the request in a few seconds.
                            // The batch request must be sent eventually, as it may contain
                            // requests that are crucial for normal operating of the web app,
                            // such as a POST .../makeMeAvailable request.
                            if (batchrsp.status == 429 /* TooManyRequests */) {
                                return sleep(batchRetryDelay).then(function () {
                                    return batch(composer, requests);
                                });
                            }
                            if (!Http.isSuccess(batchrsp.status))
                                throw ERequestFailed(batchreq, batchrsp);
                            return decompose(composer, requests, batchrsp);
                        });
                    }
                    //#endregion
                    //#region decompose
                    /**
                     * Decomposes a batch response into separate responses and
                     * parses them.
                     */
                    function decompose(composer, requests, batchrsp) {
                        var responses = composer.parse(batchrsp);
                        assert(requests.length == responses.length);
                        return map(requests, async(function (request, i) {
                            return process(requests[i], responses[i]);
                        }));
                    }
                    //#endregion
                    //#region prepare
                    function prepare(request) {
                        if (!request.headers)
                            request.headers = {};
                        // the UCWA server always returns JSON
                        // except when it replies for the batch request
                        request.headers['Accept'] = 'application/json';
                        // TODO: the requested version is supported only if _links.self.revision
                        // is greater than or equal to it or the requested version is 1; at this
                        // point it's too late to check the revision, but somewhere above in the
                        // stack it should be possible
                        if (request.version > 1)
                            request.headers['X-MS-RequiresMinResourceVersion'] = request.version;
                        // specify the Content-Type header
                        if (isString(request.data)) {
                            // if plain text is sent and the content type is not set, assume "text/plain"
                            request.headers['Content-Type'] = request.headers['Content-Type'] || 'text/plain';
                        }
                        else if (isObject(request.data)) {
                            // for POST requests put the data into the body in the JSON format;
                            // for GET requests let jQuery put the data into the query string in the URL
                            if (request.type == 'POST' || request.type == 'PUT') {
                                if (request.type == 'PUT')
                                    request.headers['If-Match'] = '"' + request.data.etag + '"';
                                // if an object is sent, assume that this is a "application/json"
                                request.data = JSON.stringify(request.data);
                                request.headers['Content-Type'] = 'application/json';
                            }
                        }
                    }
                    //#endregion
                    function parseResponse(rsp) {
                        try {
                            // all responses from UCWA are in the JSON format
                            rsp.data = JSON.parse(rsp.responseText);
                        }
                        catch (_) {
                        }
                    }
                    //#region process
                    /**
                     * Handles a response for a request sent by "ajax".
                     *
                     * The response may be a "HTTP 401 Unauthorized" challenge, so
                     * the endpoint must seamlessly obtain an auth token from the server
                     * and send the same request with the auth token.
                     */
                    function process(request, response) {
                        assert(response);
                        var parsed, result, headers = HttpHeaders(response.headers);
                        parseResponse(response);
                        if (!Http.isSuccess(response.status)) {
                            // if the status code doesn't indicate the success,
                            // don't even try to parse the response text
                            throw ERequestFailed(request, response);
                        }
                        else if (!response.responseText) {
                            // in most cases the server responds with a resource,
                            // however when the client sends a POST request to the sendMessage
                            // resource, the server replies with "HTTP 201 Created" and with
                            // empty response body, but with the Location HTTP header that contains
                            // the href of the created message
                            return new Stack.Resource(headers.get('Location'), null);
                        }
                        else {
                            // if the UCWA server sends a successful response,
                            // its contents are expected to be a JSON string and
                            // the JSON string must represent a Resource
                            try {
                                parsed = response.data;
                                // TODO: What if the server returns the same mime type but with a different version, e.g. v=1.1?
                                result = headers.get('Content-Type') == 'application/vnd.microsoft.rtc.autodiscover+json; v=1' ?
                                    Stack.parseAutodiscoverResource(parsed) :
                                    new Stack.Resource(parsed);
                            }
                            catch (_) {
                                // If the response is not a regular resource,
                                // maybe it is a multipart resource?
                                parsed = Stack.parseMultipartRelatedResponse(response);
                                result = Stack.parseMultipartResources(parsed)[0];
                            }
                            // Endpoint provides server responses as resources
                            return result;
                        }
                    }
                    //#endregion
                    //#region send
                    // batch requests are sent thru this layer
                    var sendBatch = new Web.Identity(async(transport.ajax)).map(function (send) {
                        return function (req) {
                            req.headers = req.headers || {};
                            if (enableInternalNS)
                                req.headers['X-Ms-Namespace'] = 'internal';
                            if (id)
                                req.headers['X-Ms-SDK-Instance'] = id;
                            return send(req);
                        };
                    }).map(function (send) {
                        // this layer adds seamless authorization:
                        // if the server requires authorization, the endpoint
                        // seamlessly obtains an auth token and resends the request
                        // again with the token
                        return function (req) {
                            return authorize(req, send).then(function (rsp) {
                                if (rsp['webTicketRenewed'])
                                    renewed.fire(req, rsp);
                                return rsp;
                            });
                        };
                    }).map(function (send) {
                        // this layer parses .responseText if it's in the JSON format
                        return function (req) {
                            return send(req).then(function (rsp) {
                                parseResponse(rsp);
                                return rsp;
                            });
                        };
                    }).map(function (send) {
                        // telemetry layer
                        if (!tm)
                            return send;
                        return function (req) {
                            return send(req).then(function (rsp) {
                                // in the anon p2p case the URL looks like /ucwa/anon/v1/applications
                                if (req.type == 'POST' && /\/applications$/.test(req.url))
                                    tm && tm.record('create_application_completed', { status: rsp.status });
                                return rsp;
                            });
                        };
                    }).map(function (send) {
                        // this layer adds resiliency to the 404.ApplicationNotFound error
                        // that occurs whenever a UCWA instance crashes and gets recreated
                        // on another server machine
                        return function sendWhenResumed(req) {
                            return resumed ?
                                // if the tab has been suspended, all requests must be
                                // queued even if they aren't instanceId-specific
                                resumed.then(function () { return sendWhenResumed(req); }) :
                                send(req).then(function (rsp) {
                                    // whenever this error occurs, it sends a POST to restore the app,
                                    // waits for the POST and then resends the request; if the request
                                    // fails again, it doesn't try to repeat the steps as it's likely
                                    // that the app has been permanently deleted
                                    return !Endpoint.is404(rsp) ? rsp : restore().then(function (res) { return send(req); }, function (err) {
                                        // In the multitab scenario UCWA may kick out a tab:
                                        //
                                        //      GET /events?ack=4&key=1
                                        //      404 subcode=ApplicationNotFound
                                        //      POST /applications (same instanceId)
                                        //      410 subcode=LimitExceeded
                                        //
                                        // If this happens, the SDK can restore the session by
                                        // POST /applications with a different instanceId.
                                        if (!Endpoint.is410Error(err)) {
                                            throw err;
                                        }
                                        else {
                                            suspended(true, err);
                                            if (req.instanceId)
                                                throw err;
                                            else
                                                return sendWhenResumed(req);
                                        }
                                    });
                                });
                        };
                    }).value;
                    var send = new Web.Identity(sendBatch).map(function (send) {
                        // This layer sends JSON requests: it serializes args.data
                        // into a JSON string and sends it with "Content-Type: application/json"
                        // The response is always a Resource: this method parses the
                        // JSON string returned by the server and turns it into a Resource.
                        return function (req) {
                            prepare(req);
                            return send(req).then(bind(process, req));
                        };
                    }).value;
                    //#endregion
                    return {
                        suspended: suspended,
                        renewed: renewed.observer,
                        ajax: send,
                        batch: batch
                    };
                }
                return Endpoint;
            })();
            Stack.Endpoint = Endpoint;
            var Endpoint;
            (function (Endpoint) {
                Endpoint.is404 = function (rsp) { return rsp
                    && rsp.status == 404
                    && rsp.data.subcode == 'ApplicationNotFound'; };
                Endpoint.is410 = function (rsp) { return rsp
                    && rsp.status == 410
                    && rsp.data.subcode == 'LimitExceeded'; };
                Endpoint.is410Error = function (err) { return err
                    && err.code == 'RequestFailed'
                    && Endpoint.is410(err.rsp); };
            })(Endpoint = Stack.Endpoint || (Stack.Endpoint = {}));
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var guid = Web.Utils.guid;
            var async = Web.Utils.async;
            var random = Web.Utils.random;
            var batched = Web.Utils.batched;
            var repeatAndExit = Web.Utils.repeatAndExit;
            var URI = Web.Utils.URI;
            var Task = Web.Utils.Task;
            var Exception = Web.Utils.Exception;
            var ConstProperty = Web.Utils.ConstProperty;
            /**
             * This class wraps the corresponding rel=application resource that
             * represents a signed in UCWA endpoint. The rel=application resource
             * has links to other resources, such as rel=me and rel=conversations,
             * that can be used to get the user name, the list of active conversations
             * and so on.
             *
             * The sign in process starts with the rel=root resource returned by the
             * auto discovery step and then sends a few requests to create a rel=application
             * resource. The diagram below shows the relationships between all these resources:
             *
             *      rel=root
             *          rel=xframe
             *          rel=user
             *              rel=xframe
             *              rel=applications
             *                  rel=application
             *                      rel=me
             *                      rel=batch
             *                      rel=events
             *                      rel=conversations
             *                      ...
             *
             * So to create a rel=application resource the stack sends two requests:
             *
             *      GET rel=user
             *      POST rel=applications
             *      GET rel=events
             *
             * In the case when rel=application already exists in the repository,
             * the client gets the current state of it instead of creating a new
             * rel=application:
             *
             *      GET rel=application
             *      GET rel=events
             *
             * Note, that getting rel=user is also skipped in this case.
             *
             * @created Jun 2013
             * @blame antonkh
             */
            var Application = (function () {
                function Application(args) {
                    var repository = args.repository;
                    var xframe = args.xframe;
                    var endpoint = args.endpoint;
                    var connection = args.connection;
                    var maxBatchSize = args.maxBatchSize || 0;
                    var name = args.name; // guest name
                    var endpointId = name ? void 0 : args.id || guid(); // requires version=2 of POST /applications
                    var instanceId = args.id && guid(); // a forked app has the same endpoint id, but a unique instance id
                    var version = args.version;
                    var culture = args.culture;
                    var root = args.root;
                    var tm = args.tm;
                    var batcher;
                    var lock = args.lock;
                    args = null; // reduce the visibility scope of this variable
                    //#region connect
                    /** Gets the rel=application and connects to the event channel.
                        This is the final step in the sign in process. */
                    function connect(root) {
                        return Task.wait(root).then(function (root) {
                            // the regular flow: sign in, create a rel=application and subscribe to rel=events
                            if (root) {
                                repository.put(root);
                                return getUser(root).then(createApp);
                            }
                            var app = repository.get('application')[0];
                            // the resurrection flow: fetch an existing rel=application and subscribe to rel=events
                            if (app) {
                                instanceId = app.get('instanceId', instanceId);
                                return getApp();
                            }
                            // the partial sign in flow: when the rel=applications link is known, but rel=user isn't
                            return createApp();
                        }).then(init);
                    }
                    //#endregion
                    //#region fixScheme
                    /**
                     * Changes the URI's scheme to https if the URI has a scheme.
                     * If it doesn't, returns the original URI.
                     */
                    function fixScheme(link) {
                        var uri = new URI(link);
                        return uri.scheme() == 'http' ?
                            uri.scheme('https') + '' :
                            link;
                    }
                    //#endregion
                    //#region getUser
                    /**
                     * This GET request is supposed to return a link to rel=applications.
                     * In certain cases, however, the rel=applications link is missing in
                     * the response. If this link is missing, the client may assume that
                     * it's observing a server bug for which there is a workaround:
                     *
                     *      1. The client needs to send the GET to rel=user again,
                     *         but this time with a special Accept header.
                     *
                     *      2. The response will contain a specially formatted resource
                     *         with rel=redirect and rel=xframe links that point to another pool.
                     *
                     *      3. The client needs to send a regular GET to the rel=redirect link
                     *         and the response will contain a link to rel=user on another pool.
                     *
                     * @returns {Promise<Resource>} - Returns the rel=user resource.
                     */
                    function getUser(root) {
                        return endpoint.ajax({
                            type: 'GET',
                            url: root.link('user').href
                        }).then(function (user) {
                            var ucwaLinkExists = name ?
                                user.hasLink('anonApplications') :
                                user.hasLink('applications');
                            // if the user/applications link is missing, try to get it
                            // via the private auto discovery flow
                            return ucwaLinkExists ? user :
                                endpoint.ajax({
                                    type: 'GET',
                                    url: root.link('user').href,
                                    headers: { 'Accept': 'application/vnd.microsoft.rtc.autodiscover+json; v=1' }
                                }).then(function (user1) {
                                    user1.rel = user1.rel || 'user'; // the server may omit "rel" for this resource
                                    if (user1.hasLink('xframe'))
                                        // the server-side auto-d code is handcrafting URLs
                                        // and may mistakenly return an HTTP link here
                                        xframe.src(fixScheme(user1.link('xframe').href));
                                    // repeatAndExit(...) below does a quite simple thing:
                                    //
                                    //      while (user1.redirect)
                                    //          user1 = await GET(user1.redirect.href);
                                    //
                                    return repeatAndExit(function (exit) {
                                        return !user1.hasLink('redirect') ? exit(user1) : endpoint.ajax({
                                            type: 'GET',
                                            // the server-side auto-d code is handcrafting URLs
                                            // and may mistakenly return an HTTP link here
                                            url: fixScheme(user1.link('redirect').href)
                                        }).then(function (redirect) {
                                            redirect.rel = redirect.rel || 'redirect'; // the server may omit "rel" for this resource
                                            if (redirect.hasLink('xframe'))
                                                xframe.src(redirect.link('xframe').href);
                                            user1 = redirect;
                                        });
                                    });
                                }).then(function (redirect) {
                                    return endpoint.ajax({
                                        type: 'GET',
                                        url: redirect.link('user').href
                                    });
                                });
                        }).then(function (user) {
                            user.rel = user.rel || 'user'; // the server may omit "rel" for this resource
                            repository.put(user);
                            if (user.hasLink('xframe'))
                                xframe.src(user.link('xframe').href);
                            return user;
                        });
                    }
                    //#endregion
                    //#region createApp
                    /** Creates a rel=application resource. */
                    var createApp = lock.synchronized(function () {
                        // GET rel=anonUser returns both links
                        var r = name ?
                            repository.get('anonApplications')[0] :
                            repository.get('applications')[0];
                        // if the server doesn't support forking an application, the client
                        // falls back to the regular POST /applications request that creates
                        // a new endpoint or resumes an existing one with the given id
                        var v = (instanceId && r.revision >= 2) ? 2 : 1;
                        tm && tm.record('create_application_started');
                        return Task.run(function () {
                            // Guess the xframe URL only in the p2p anon auth.
                            // This could be done unconditionally, but there may
                            // be troubles with the private OAuth2 flow in which
                            // the xframe.src value is changed to get the token
                            if (!name)
                                return;
                            var _user = new URI(xframe.src());
                            var _apps = new URI(r.href);
                            // in the p2p anon flow rel=anonApplications and rel=anonUser
                            // are on different domains, but GET rel=anonUser doesn't return
                            // a new xframe; the workaround is to guess the new xframe URL
                            if (_user.host() != _apps.host())
                                return xframe.src.set(_apps.path('/xframe') + '');
                        }).then(function () {
                            return endpoint.ajax({
                                type: 'POST',
                                url: r.href,
                                version: v,
                                data: {
                                    AnonymousDisplayName: name,
                                    UserAgent: version,
                                    Culture: culture,
                                    EndpointId: endpointId,
                                    InstanceId: v == 2 ? instanceId : void 0
                                }
                            });
                        }).then(function (app) {
                            repository.put(app);
                            return app;
                        });
                    });
                    //#endregion
                    //#region replaceApp
                    /** Creates a new fork of the endpoint by generating a new instanceId.
                        This invalidates the rel=application and rel=events hrefs. */
                    function replaceApp() {
                        // the current instanceId has been permanently deleted by UCWA
                        instanceId = guid();
                        // these are the only two hrefs that contain instanceId
                        repository.remove(repository.get('application')[0].href);
                        repository.remove(repository.get('events')[0].href);
                        // at this moment the event channel should have been suspended
                        // by the 410 response; this call is supposed to resume it
                        return createApp().then(init);
                    }
                    //#endregion
                    //#region getApp
                    /** Fetches the rel=application resource from UCWA. */
                    function getApp() {
                        return endpoint.ajax({
                            type: 'GET',
                            url: repository.get('application')[0].href,
                            instanceId: instanceId,
                            headers: {
                                // forbid the browser to use a cached response
                                'If-None-Match': '"' + random() + '"'
                            }
                        }).then(function (app) {
                            repository.put(app);
                            return app;
                        }).catch(function (err) {
                            throw Exception('GetAppError', { reason: err });
                        });
                    }
                    //#endregion
                    //#region init
                    function init(app) {
                        // if rel=batch is available, then batch requests are supported
                        if (app.hasLink('batch') && !batcher)
                            batcher = new Stack.Batch(app.link('batch').href);
                        // if rel=events available, start listening to events
                        if (app.hasLink('events'))
                            connection.connect(app.link('events').href, instanceId);
                    }
                    //#endregion
                    //#region ajax
                    /**
                     * Sends an HTTP request to the given URL.
                     * The resource returned by the server is cached in the repository.
                     */
                    function ajax(request) {
                        return endpoint.ajax(request).then(function (resource) {
                            repository.put(resource);
                            // 204-like responses are represented by resources without href
                            // 201-like responses with Location header turn into resources without rel
                            return resource.href && repository.get(resource.href)[0] || resource;
                        });
                    }
                    //#endregion
                    //#region batch
                    /** Sends a few requests in one batch. */
                    function batch(requests) {
                        // if the batch contains only 1 request or batching is not enabled,
                        // send the requests separately
                        if (requests.length == 1 || !batcher || !maxBatchSize)
                            return Task.wait(requests.map(ajax));
                        return endpoint.batch(batcher, requests).then(function (results) {
                            for (var _i = 0; _i < results.length; _i++) {
                                var r = results[_i];
                                Task.wait(r).then(repository.put);
                            }
                            return results;
                        });
                    }
                    //#endregion
                    //#region renewing cwt_ucwa cookie
                    // A response to the first "POST applications" request
                    // contains not only the "application" resource but also
                    // a Set-Cookie header that sets a cwt_ucwa cookie needed
                    // to get contact photos. This cookie looks like this:
                    //
                    //      POST .../applications HTTP/1.1
                    //      {"UserAgent":"...","Culture":"en-us","EndpointId":"..."}
                    //
                    //      HTTP/1.1 201 Created
                    //      Set-Cookie: cwt_ucwa=AAE...b3M; path=.../photos; secure; HttpOnly
                    //
                    // So whenever the client creates an <img> element pointing to
                    // a contact photo, the browser sends a GET request to that URL
                    // including the cwt_ucwa cookie in the Cookie header:
                    //
                    //      GET .../photos/johndoe HTTP/1.1
                    //      Cookie: cwt_ucwa=AAE...b3M
                    //
                    // However this cwt_ucwa cookie has a limited lifetime and eventually
                    // it expires. A right way to renew this cookie was suggested by
                    // the server team: whenever the primary web ticket expires, renew it
                    // and sends a "GET application" request - the response will contain
                    // a new value of the cwt_ucwa cookie:
                    //
                    //      GET .../applications/... HTTP/1.1
                    //      Authorization: Bearer cwt=AAE...1Vo
                    //
                    //      HTTP/1.1 200 OK
                    //      Set-Cookie: cwt_ucwa=AAE...b3M
                    //
                    // So the code snippet below sends this GET request whenever the primary
                    // web ticket expires.
                    endpoint.renewed(function () {
                        if (repository.get('application').length == 1)
                            getApp();
                    });
                    //#endregion
                    //#region send
                    var send = new Web.Identity(async(ajax)).map(function (send) {
                        // this is the batching layer that accumulates all requests
                        // without nobatch=true and sends them in one batch on the
                        // next event cycle
                        var sendInBatch = !maxBatchSize ? send :
                            batched(async(batch), maxBatchSize);
                        return function (req) {
                            req.priority = req.priority || 0;
                            return req.nobatch ? send(req) :
                                sendInBatch(req, req.priority);
                        };
                    }).map(function (send) {
                        // this is debouncing layer that merges identical GET requests
                        // into one; this is possible because GET requests do not modify
                        // the state on the server
                        var reqs = {};
                        return function (req) {
                            if (req.type != 'GET')
                                return send(req);
                            // JSON.stringify acts here as a hash function; since request
                            // objects are very small, JSON.stringify is just better than
                            // any other hash function
                            var uid = JSON.stringify(req);
                            reqs[uid] = reqs[uid] || send(req).finally(function () { return delete reqs[uid]; });
                            return reqs[uid];
                        };
                    }).value;
                    //#endregion
                    return {
                        ajax: send,
                        id: ConstProperty(endpointId),
                        restore: function () { return createApp().then(function () { }); },
                        replace: replaceApp,
                        ready: connect(root)
                    };
                }
                return Application;
            })();
            Stack.Application = Application;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="Resource.ts" />
/// <reference path="ResourceEvent.ts" />
/// <reference path="Repository.ts" />
/// <reference path="EventBatch.ts" />
/// <reference path="EventChannel.ts" />
/// <reference path="RequestBatcher.ts" />
/// <reference path="XFrame.ts" />
/// <reference path="XHR.ts" />
/// <reference path="Transport.ts" />
/// <reference path="AutoDiscovery.ts" />
/// <reference path="Endpoint.ts" />
/// <reference path="Application.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            /** Dumps in the dev console all UCWA requests and responses. */
            Settings.logRequests = false;
            /** Dumps to the dev console all UCWA events. */
            Settings.logEvents = false;
            /** If logging of the UCWA traffic is enabled, this setting
                makes the dump look like a unit test. For internal use only. */
            Settings.logMode = /\blm=ut\b/.test(Web.window.location && Web.window.location.hash) ? 'ut' : null;
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            var ver = Web.version;
            var all = Web.Utils.all;
            var map = Web.Utils.map;
            var Task = Web.Utils.Task;
            var async = Web.Utils.async;
            var clone = Web.Utils.clone;
            var debug = Web.Utils.debug;
            var assert = Web.Utils.assert;
            var extend = Web.Utils.extend;
            var random = Web.Utils.random;
            var batched = Web.Utils.batched;
            var isObject = Web.Utils.isObject;
            var isString = Web.Utils.isString;
            var getOption = Web.Utils.getOption;
            var isFunction = Web.Utils.isFunction;
            var Http = Web.Utils.Http;
            var URI = Web.Utils.URI;
            var Event = Web.Utils.Event;
            var Symbol = Web.Utils.Symbol;
            var SyncLock = Web.Utils.SyncLock;
            var Exception = Web.Utils.Exception;
            var BoolProperty = Web.Utils.BoolProperty;
            var SourcedProperty = Web.Utils.SourcedProperty;
            /** This is a trick to avoid multiple GETs on the same resource object.
                A better solution would be to move this logic inside Resource. */
            var sGET = Symbol('GET');
            function getSelName(selector) {
                return isString(selector) ? selector : selector.rel;
            }
            function getOptParamBound(params, name, upperBound) {
                var val = getOption(params, name, upperBound);
                return val <= upperBound ? val : upperBound;
            }
            /**
             * Encapsulates the UCWA stack.
             *
             * This object brings together various pieces of the stack,
             * such as Connection, XFrame, Transport and so on. The model
             * layer uses this stack as the data source.
             *
             * @created Feb 2014
             * @blame antonkh
             */
            var UCWA = (function () {
                function UCWA(options) {
                    if (options === void 0) { options = {}; }
                    this.eEvent = new Event();
                    this.eRestored = new Event();
                    this.pConnected = BoolProperty(false);
                    /** An event from the UCWA server. Check event.type. */
                    this.event = this.eEvent.observer;
                    /** Tells that the connection with UCWA has been restored. */
                    this.restored = this.eRestored.observer;
                    /** Tells whether the UCWA endpoint is still alive. */
                    this.connected = this.pConnected.asReadOnly();
                    this.suspended = SourcedProperty();
                    this.nReq = 0;
                    this.tInit = new Task();
                    this._log = [];
                    this.tm = options.tm;
                }
                /**
                 * Initializes the UCWA stack.
                 *
                 * If invoked without arguments, returns a promise that
                 * resolves after the client gets signed in.
                 */
                UCWA.prototype.init = function (options) {
                    if (options) {
                        assert(!this.pInit);
                        this.connect(options);
                    }
                    return this.tInit.promise;
                };
                /** Disconnects from the server and cleans up resources. */
                UCWA.prototype.uninit = function (reason) {
                    try {
                        if (this.pInit)
                            this.pInit.cancel(reason);
                        if (this._xframe)
                            this._xframe.reset();
                        this.pInit = null;
                        this.tInit = new Task();
                        this._xframe = null;
                        this._repository = null;
                        this._application = null;
                    }
                    catch (err) {
                        this.tm && this.tm.record('ucwa_uninit_exception', { reason: err });
                        throw err;
                    }
                };
                /** Sends an HTTP request and returns the resource object
                 *  given by the server in response. The options allow to
                 *  control the request priority, set headers, define whether
                 *  it should go to the batching queue and so on.
                 *
                 *      ucwa.send("POST", ".../audioVideoInvitations", {
                 *          nobatch: true,  // SDP offers cannot be batched
                 *          priority: 3,    // some random priority for the throttling queue
                 *          data: "v=0\r\nsession=1\r\n...",
                 *          query: { operationId: "12-342-232" },
                 *          headers: { "Content-Type": "application/sdp; charset=utf-8" }
                 *      });
                 *
                 *  `selector` can be either a URI/URL or an object of the form { rel: '...' }
                 *  to make the stack find the resource with the specified rel and send the
                 *  request to its href:
                 *
                 *      ucwa.send("GET", { rel: "me" });
                 */
                UCWA.prototype.send = function (method, selector, options) {
                    var _this = this;
                    var url = isString(selector) ? selector : this.get(selector).href;
                    var id = ++this.nReq;
                    if (options && options.query) {
                        var uri = new URI(url); // parse the URL
                        var query = URI.Query(uri.query()); // parse the query part of the URL
                        extend(query, options.query); // amend it with the given query params
                        uri.query(query + ''); // change the query of the original URL
                        url = uri + ''; // serialize the URL with the amended query
                    }
                    var req = extend(clone(options || {}), {
                        type: method,
                        url: url
                    });
                    /* istanbul ignore next */
                    if (Web.Settings.logRequests) {
                        if (Web.Settings.logMode == 'ut') {
                            this.log("req[" + id + "] = ucwa.request(\"" + method + " " + url + "\");");
                            if (req.data) {
                                var data = JSON.stringify(req.data, null, 4);
                                this.log("assert.equal(req[" + id + "].data, " + data + ");");
                            }
                        }
                        else {
                            this.log('%c -> ' + id + ' ' + method, 'color:blue;font-weight:bold', url);
                            if (req.data)
                                this.log(req.data);
                        }
                    }
                    var promise = this._application.ajax(req);
                    /* istanbul ignore next */
                    if (Web.Settings.logRequests) {
                        promise.then(function (rsp) {
                            if (Web.Settings.logMode == 'ut') {
                                _this.log('//', method, url);
                                _this.log("req[" + id + "].resolve(" + (rsp.href ? rsp + '' : '') + ");");
                            }
                            else {
                                _this.log('%c <- ' + id + ' ' + method, 'color:green;font-weight:bold', url);
                                if (rsp.href) {
                                    var s = rsp.getSnapshot();
                                    // do not log user credentials if present 
                                    delete s.userName;
                                    delete s.password;
                                    _this.log(s);
                                }
                            }
                        }, function (err) {
                            var rsp = err && err.rsp || {};
                            if (Web.Settings.logMode == 'ut') {
                                var data = JSON.stringify(rsp, null, 4);
                                _this.log("req[" + id + "].reject(" + data + ");");
                            }
                            else {
                                _this.log('%c <- ' + id + ' ' + method, 'color:red;font-weight:bold', url, rsp.status, rsp.statusText);
                                _this.log(err);
                            }
                        });
                    }
                    return promise;
                };
                /**
                 * Finds an existing resource object by href or rel in the repository.
                 * If there is no such resource or there are several such resources,
                 * the method throws an exception.
                 *
                 *     ucwa.get(".../messages/2"); // lookup the resource by its href
                 *     ucwa.get({ rel: "me" }); // lookup the resource by its rel
                 */
                UCWA.prototype.get = function (selector, defaults) {
                    var r = this.find(selector);
                    if (!r || r.length < 1) {
                        if (defaults === null)
                            return null;
                        assert(false, 'The resource does not exist: ' + getSelName(selector));
                    }
                    assert(r.length < 2, 'There are ' + r.length + ' resources matching ' + getSelName(selector));
                    return r[0];
                };
                /**
                 * Finds all resource objects in the repository matching the selector.
                 * The selector may contain the rel or the href of the resource.
                 */
                UCWA.prototype.find = function (selector) {
                    return isFunction(selector) ? this._repository.find(selector) :
                        this._repository.get(isString(selector) ? selector : selector.rel);
                };
                /** Checks whether the resource object exists in the repository. */
                UCWA.prototype.exists = function (selector) {
                    return this.find(selector).length > 0;
                };
                /**
                 * Returns a snapshot of the repository.
                 *
                 * The snapshot is a mapping from a rel to an array of resource snapshots
                 * which are raw objects. This is how a snapshot can be used:
                 *
                 *     var snapshot = ucwa.getSnapshot();
                 *     var resource = Resource(snapshot.contact[0]);
                 */
                UCWA.prototype.getSnapshot = function (filter) {
                    var snapshot = this._repository.getSnapshot(filter);
                    // During auto discovery and sign in, UCWA may have redirected
                    // the client between pools a few times, each time giving a new
                    // xframe URL, so after sign in is completed, the repository may
                    // contain several rel=xframe resources and only one of them is used.      
                    var xframeUrl = new URI(snapshot.applications[0]._links.self.href).path('/xframe').query('').hash('').toString();
                    snapshot.xframe = [{ _links: { self: { href: xframeUrl } } }];
                    return snapshot;
                };
                /*
                 * Get value of the "revision" property associated with the given resource.
                 */
                UCWA.prototype.getRevisionOf = function (r) {
                    var _this = this;
                    // the resource may not contain revision info due to lazy-loading,
                    // so have to load again if initially not found
                    var link = r.link('self');
                    return Task.run(function () {
                        return +link.revision || r[sGET] || (r[sGET] = _this.send('GET', r.href));
                    }).then(function () {
                        return +link.revision || 1; // default revision is 1
                    });
                };
                /**
                 * Waits for a specific event from UCWA.
                 *
                 *      ucwa.wait({
                 *          type: 'completed',
                 *          target: { rel: 'message' }
                 *      }).then(function (event) {
                 *          console.log(event.target.href);
                 *      });
                 */
                UCWA.prototype.wait = function (pattern) {
                    var ucwa = this;
                    var pres = pattern.resource;
                    var ptar = pattern.target;
                    var ptyp = pattern.type;
                    var psts = pattern.status;
                    function matches(event) {
                        var eres = event.resource;
                        var etar = event.target;
                        var etyp = event.type;
                        var ests = event.status;
                        return !(etyp != ptyp ||
                            psts && psts != ests ||
                            etar.rel != ptar.rel ||
                            ptar.href && etar.href != ptar.href ||
                            isFunction(pres) && !pres(eres) ||
                            isObject(pres) && !all(pres, function (v, n) { return eres.has(n) && eres.get(n) == v; }));
                    }
                    var task = new Task(ptar.rel + ' ' + ptyp, {
                        mode: 'sync',
                        cancel: function (reason) {
                            ucwa.event.off(handler);
                            task.reject(reason);
                        }
                    });
                    function handler(event) {
                        if (matches(event)) {
                            ucwa.event.off(handler);
                            task.resolve(event);
                        }
                    }
                    ucwa.event(handler);
                    return task.promise;
                };
                /** Adds a listener to a specific event:
                    ucwa.observe("participant added", event => { ... }); */
                UCWA.prototype.observe = function (pattern, listener) {
                    var _a = /^(\w+) (\w+)$/.exec(pattern), rel = _a[1], type = _a[2];
                    return this.event(function (event) {
                        if (event.type == type && event.target.rel == rel)
                            listener(event);
                    });
                };
                UCWA.prototype.connect = function (options) {
                    var _this = this;
                    var auth = options.auth;
                    var id = options.id; // UCWA's endpoint id.
                    var client_id = options.client_id; // OAuth client_id
                    var redirect_uri = options.redirect_uri;
                    var oauth_uri = options.oauth_uri; // OAuth URI
                    var oauth_state = options.state; // OAuth state
                    var use_cwt = options.use_cwt;
                    var username = options.username;
                    var password = options.password;
                    var token = options.token;
                    var default_graph_uri = options.graph_uri;
                    var default_graph_oauth_uri = options.graph_oauth_uri;
                    var name = options.name;
                    var domain = options.domain; // auto d
                    var origins = options.origins; // auto d
                    var conf_uri = options.meeting; // conference URI
                    var conf_key = options.conf_key;
                    var xmscwt = options.xmscwt;
                    var root = options.root; // rel=root
                    var snapshot = options.snapshot; // if the snapshot is specified, it overrides the snapshot from the storage
                    var culture = options.culture || 'en-us';
                    var version = 'SkypeWeb/' + ver + (options.version ? ' ' + options.version : '');
                    var throttle = getOption(options, 'throttle', 5); // the number of requests in the throttling queue            
                    var enableInternalNS = !!options.enableInternalNS;
                    var cors = options.cors;
                    // Make a choice whether to use XHR or XFrame as the transport.
                    // Note, that determining whether the current agent supports CORS
                    // or not isn't that simple because some agents may be able to send
                    // cross-origin requests, but not able to read all the response
                    // headers because they do not support Access-Control-Expose-Headers.
                    var xframector = options.XFrame || (cors ? Stack.XHR : Stack.XFrame);
                    var document = options.document;
                    var location = options.location;
                    var batchRetryDelay = getOption(options, 'batchRetryDelay', 5.0); // seconds
                    var maxBatchSize = getOptParamBound(options, 'maxBatchSize', 20); // UCWA limits batch size to 20 requests
                    var storage = options.storage || Web.window && Web.window.sessionStorage;
                    var ssPrefix = 'Skype.Web.Snapshot';
                    var ssEnabled = !!id;
                    var instance = random();
                    var lock = new SyncLock('CreateApp');
                    // TODO: status = 0 is given not only to cancelled
                    // XHR requests, but also to failed cross-origin
                    // requests, on some SSL-specific failures and so on.
                    var delay000 = options.delay000 || (function () { return function () { return 3; }; });
                    var delay502 = options.delay502 || (function () {
                        var delay = 30; // fixed delay of 30 seconds
                        var maxdt = 15 * 60; // give up after 15 minutes
                        var n = 0;
                        return function () {
                            if (delay * n++ > maxdt)
                                throw Exception('MaxRetryDelayReached');
                            else
                                return delay;
                        };
                    });
                    var delay503 = options.delay503 || (function () {
                        var delay = 1;
                        return function () {
                            // exponential back off with the 10 mins upper limit
                            if (delay > 600)
                                throw Exception('MaxRetryDelayReached');
                            else
                                return delay *= 1.5;
                        };
                    });
                    options = null; // reduce the visibility scope of this variable         
                    if (cors) {
                        // As of 2015, the UCWA's CORS works with OAuth tokens only:
                        // this is why the token->cwt exchange flag defaults to false.
                        if (use_cwt === void 0)
                            use_cwt = false;
                        // In most cases any URl on the same domain can be used. In IE,
                        // though, a full URL like /token/index.html is required, as
                        // otherwise it drops the access token from the URL's fragment part.
                        // This is why overriding the default redirect_uri may be useful.
                        if (redirect_uri === void 0)
                            redirect_uri = "/" + client_id + "/oauth2/token";
                    }
                    if (isString(origins)) {
                        if (!domain)
                            throw new Error('`domain` is required when `origins` is an env name');
                        origins = Stack.AutoD[origins](domain);
                        domain = null;
                    }
                    try {
                        if (ssEnabled && !snapshot && storage)
                            snapshot = JSON.parse(storage.getItem(ssPrefix + '.' + id) || 'null');
                    }
                    catch (err) {
                    }
                    var getRoutes = function (origins) { return map(origins, function (origin) {
                        return Task.wait().then(function () {
                            if (snapshot) {
                                snapshot = Stack.Repository.expandSnapshot(snapshot);
                                // rel=xframe can be inferred from rel=applications or rel=user
                                if (!cors && !snapshot.xframe) {
                                    var href = (snapshot.applications || snapshot.user)[0]._links.self.href;
                                    snapshot.xframe = [{ _links: { self: { href: '' + new URI(href).path('/xframe').query('') } } }];
                                }
                            }
                            if (isString(origin))
                                origin = { origin: origin };
                            // in most cases the xframe URL can be inferred from the root URL
                            if (origin && !origin.xframe)
                                origin.xframe = new URI(origin.origin).path('/xframe').query('').hash('') + '';
                            // this is either the XFrame ctor or the XHR ctor:
                            // they both have the 1st arg taking a mock for tests
                            // and the undefined value makes both ctors use
                            // the default value for the 1st arg
                            var xframe = new xframector(void 0, _this.tm);
                            var graph_uri = origin && origin.graph_uri || default_graph_uri;
                            var graph_oauth_uri = origin && origin.graph_oauth_uri || default_graph_oauth_uri;
                            return Task.run(function () {
                                if (!graph_uri)
                                    return;
                                // A better way to discover the OAuth URI for Graph is
                                // to send a request to it without a token, get a 401,
                                // read the WWW-Authenticate header in the response and
                                // find there the authorization_uri parameter. Unfortunately,
                                // Graph doesn't set the Access-Control-Expose-Headers in
                                // responses, so XHR doesn't let JS see that header.
                                if (!graph_oauth_uri)
                                    throw Error('OAuth URI for Graph is missing.');
                                var uri = new URI(graph_oauth_uri);
                                uri.query.set('response_type', 'token');
                                uri.query.set('client_id', client_id);
                                uri.query.set('redirect_uri', cors ? redirect_uri : origin.xframe);
                                uri.query.set('resource', new URI(graph_uri).path('').query('').hash('') + '');
                                uri.query.set('prompt', 'none');
                                return Task.run(function () {
                                    return cors ?
                                        // when CORS is used, create a hidden <iframe> to get a token for Graph
                                        Web.Auth.Implicit.getToken(uri, location, document) :
                                        // when the xframe is used, redirect the xframe to get the token
                                        xframe.src.set(uri + '').then(function () {
                                            // First send any request that requires the X-Ms-Origin
                                            // validation. The xframe will see from the response that
                                            // the origin is trusted and can send requests to Graph.
                                            return xframe.send({
                                                type: 'GET',
                                                url: '/ucwa/oauth',
                                                headers: {
                                                    // Using the xframe's token for Graph will result
                                                    // in a 403 Forbidden with the following diag code:
                                                    //
                                                    //   X-Ms-diagnostics: 28055;
                                                    //      source="*.lync.com";
                                                    //      reason="The OAuth token is invalid.";
                                                    //      faultcode="wsse:FailedAuthentication"
                                                    //
                                                    // To pass the X-Ms-Origin check we need a 401 response.
                                                    'Authorization': 'Bearer'
                                                }
                                            });
                                        }).then(function () { return null; });
                                }).then(function (token) {
                                    return xframe.send({
                                        type: 'GET',
                                        headers: { Authorization: token },
                                        url: new URI(graph_uri).path('/me') + ''
                                    });
                                }).then(function (rsp) {
                                    if (!Http.isSuccess(rsp.status))
                                        throw Stack.ERequestFailed({ type: 'GET', url: '/me' }, rsp);
                                    var data = JSON.parse(rsp.responseText);
                                    var sip = data.sipProxyAddress;
                                    var uri = new URI(origin.origin);
                                    if (!sip)
                                        throw Exception('SipProxyAddressMissing', { response: rsp });
                                    // Adding these two parameters to the origin (rel=root) URL
                                    // was the entire point of this extra request to Graph API.
                                    uri.query.set('originalDomain', sip.split('@')[1]);
                                    uri.query.set('sipuri', sip);
                                    origin.origin = uri + '';
                                });
                            }).catch(function (err) {
                                // It doesn't make sense to fail the sign in
                                // because of some Graph-related failure.
                                _this.tm && _this.tm.record('graph_api_failed', { reason: err });
                            }).then(function () {
                                var dfdroot;
                                if (snapshot) {
                                    _this.tm && _this.tm.record('signin_use_snapshot');
                                    xframe.src(snapshot.xframe[0]._links.self.href);
                                }
                                else if (!root) {
                                    if (!domain) {
                                        domain = username ? username.match(/@(.+?)$/)[1] :
                                            conf_uri ? conf_uri.match(/@(.+?);/)[1] :
                                                null;
                                        if (!domain && !origin)
                                            throw Exception('NoFQDN');
                                    }
                                    dfdroot = Stack.AutoDiscovery({
                                        XFrame: xframector,
                                        xframe: xframe,
                                        domain: domain,
                                        origins: origin && [origin]
                                    }).root;
                                }
                                else {
                                    // these parameters are provided by UI, so
                                    // a meaningful error message is required
                                    assert(root.user, 'root.user URL is missing');
                                    // it's important to drop the query, otherwise the xframe won't be loaded
                                    root.xframe = root.xframe || new URI(root.user).path('/xframe').query('') + '';
                                    xframe.src(root.xframe);
                                    dfdroot = new Stack.Resource('//root', 'root')
                                        .addLink('user', root.user)
                                        .addLink('xframe', root.xframe)
                                        .set('internal', !!root.internal);
                                }
                                var authType;
                                var authfn;
                                if (auth == 'passive') {
                                    authfn = Web.Auth.Passive();
                                    authType = 'passive';
                                }
                                else if (isFunction(auth)) {
                                    authfn = auth;
                                    authType = 'function';
                                }
                                else if (token) {
                                    authfn = Web.Auth.Token(token);
                                    authType = 'token';
                                }
                                else if (password) {
                                    authfn = Web.Auth.Basic(username, password);
                                    authType = 'basic';
                                }
                                else if (conf_uri) {
                                    authType = 'anonymous';
                                    authfn = xmscwt ?
                                        Web.Auth.AnonMeetingInternal(conf_uri, conf_key) :
                                        Web.Auth.Anonymous(conf_uri, conf_key);
                                }
                                else if (client_id) {
                                    authType = 'implicit';
                                    authfn = Web.Auth.Implicit({
                                        xframe: xframe,
                                        client_id: client_id,
                                        oauth_uri: oauth_uri,
                                        state: oauth_state,
                                        use_cwt: use_cwt,
                                        tm: _this.tm,
                                        redirect_uri: redirect_uri,
                                        document: document,
                                        location: location
                                    });
                                }
                                else {
                                    authfn = Web.Auth.Integrated();
                                    authType = 'integrated';
                                }
                                _this.tm && _this.tm.record('use_auth', { auth: authType });
                                var transport = new Stack.Transport(xframe, {
                                    fmax: !Web.isUnitTested && 1.5,
                                    tm: _this.tm,
                                    buffer: throttle,
                                    delay: { 0: delay000, 503: delay503, 502: delay502 }
                                });
                                var endpoint = new Stack.Endpoint({
                                    tm: _this.tm,
                                    batchRetryDelay: batchRetryDelay,
                                    transport: transport,
                                    auth: authfn,
                                    id: version + '-' + instance + '-' + random(),
                                    enableInternalNS: enableInternalNS,
                                    replace: function () { return application.replace(); },
                                    restore: function () {
                                        // The handler of 404.ApplicationNotFound requests needs to be implemented
                                        // right on top of the auth layer, as its used by the batching layer and
                                        // by the event channel, and it's implementation needs to send the POST to
                                        // restore the app. The first requirement makes Ednpoint as the natural
                                        // place for this handler, while the second requirement makes Application as
                                        // the proper place. The `restore` function, which is essentially an indirect
                                        // reference from endpoint to application, is the least hacky way to solve this.
                                        // A better solution would be to merge Transport, Endpoint and Application.
                                        return application.restore().then(function () {
                                            _this.eRestored.fire();
                                        });
                                    }
                                });
                                var connection = new Stack.Connection(endpoint);
                                var repository = new Stack.Repository({
                                    snapshot: snapshot,
                                    connection: connection
                                });
                                var application = new Stack.Application({
                                    tm: _this.tm,
                                    maxBatchSize: maxBatchSize,
                                    xframe: xframe,
                                    endpoint: endpoint,
                                    repository: repository,
                                    connection: connection,
                                    root: dfdroot,
                                    name: name,
                                    id: id,
                                    culture: culture,
                                    version: version,
                                    lock: lock
                                });
                                return application.ready.then(function () {
                                    // This subscription has to be synchronous because async delivery of Connection events to UCWA object 
                                    // combined with sync delivery of these events to Repository results in incorrect events to the model layer.
                                    //
                                    // If two related events refer to that same resource but carry a different resource content and if these 
                                    // events arrive in the same batch we will wind up with the following chain:
                                    //
                                    //  1. Event 1 is handed to Repository - resource is saved in Repository and event.resource is replaced 
                                    //     by a reference to the resource in the repository.
                                    //  2. Event 1 delivery to UCWA is postponed until the next event cycle.
                                    //  3. Event 2  is handed to Repository - resource is updated in Repository and event.resource is replaced 
                                    //     by a reference to the resource in the repository. Now both Event 1 and 2 refer to the same resource 
                                    //     copy in Repository.
                                    //  4. Event 2  delivery to UCWA is postponed until the next event cycle.
                                    //
                                    // When Event 1 and 2 reach UCWA they both have the reference to the same resource content received in  
                                    // Event2, which is wrong.
                                    //
                                    connection.event(function (event) {
                                        /* istanbul ignore next */
                                        if (Web.Settings.logEvents) {
                                            var ctx = event['in'];
                                            var name_4 = event.target.rel + ' ' + event.type + (ctx ? ' in ' + ctx.rel : '');
                                            if (Web.Settings.logMode == 'ut') {
                                                _this.log('// ' + name_4);
                                                _this.log("ucwa.fire(" + (event + '') + ");");
                                            }
                                            else {
                                                _this.log('%c ' + name_4, 'color:magenta;font-weight:bold');
                                                _this.log(JSON.parse(event + ''));
                                            }
                                        }
                                        _this.eEvent.fire(event);
                                    });
                                    connection.connected.changed(_this.pConnected);
                                    if (ssEnabled && storage) {
                                        var save = batched(function () {
                                            // can be invoked shortly after the repository
                                            // becomes null due to loss of event channel
                                            if (!_this.connected())
                                                return;
                                            var rx = /^(applications?|xframe|root)$/;
                                            var ss = _this.getSnapshot(function (rel) { return rx.test(rel); });
                                            try {
                                                storage.setItem(ssPrefix + '.' + id, JSON.stringify(ss));
                                            }
                                            catch (err) {
                                            }
                                        });
                                        repository.updated(save);
                                    }
                                    _this.suspended.setSource(endpoint.suspended);
                                    _this._xframe = xframe;
                                    _this._repository = repository;
                                    _this._application = application;
                                });
                            }).catch(function (err) {
                                xframe.reset();
                                throw err;
                            });
                        });
                    }); };
                    var routes = getRoutes(snapshot || !origins ? [null] : origins);
                    this.pInit = Task.waitAny(routes).catch(function (e) {
                        if (snapshot && origins && e && e.code == 'GetAppError') {
                            var r = e.reason;
                            if (r && r.code == 'RequestFailed' && /^(404|502)$/.test(r.rsp.status)) {
                                // upon 404 or 502 error from GET /application, delete the snapshot and retry auto discovery
                                snapshot = null;
                                return Task.waitAny(getRoutes(origins));
                            }
                        }
                        throw e;
                    }).finally(function () {
                        _this.pInit = null;
                    });
                    this.pInit.then(function (res) { return _this.tInit.resolve(res); }, function (err) { return _this.tInit.reject(err); }, this.tInit.status);
                };
                UCWA.prototype.log = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    debug.log.apply(debug, args);
                    if (Web.Settings.logMode == 'ut')
                        this._log.push(args.join(' ') + '\n');
                };
                UCWA.prototype.save = function (fileName) {
                    if (fileName === void 0) { fileName = new Web.Date().toJSON() + '.js'; }
                    var blob = new Blob(this._log, { type: 'application/javascript' });
                    var a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a['download'] = fileName;
                    a.click();
                };
                __decorate([
                    async
                ], UCWA.prototype, "init", null);
                __decorate([
                    async
                ], UCWA.prototype, "send", null);
                return UCWA;
            })();
            Stack.UCWA = UCWA;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="autod.ts" />
/// <reference path="auth.ts" />
/// <reference path="stack/UCWA.ts" />
/**
 * The UCWA stack layer.
 *
 * This is the transport layer or the stack that lays between the UCWA server
 * and the model layer. The stack sends HTTP requests with
 * JSON payload to the UCWA server, processes responses with JSON
 * payload and provides the responses in a object-oriented way.
 *
 * The stack consists of four levels:
 *
 *      XFrame - the lowest level
 *
 *          Abstracts the functionality of the <iframe> HTML element.
 *          XFrame can send an HTTP request to the underlying <iframe>
 *          and receive a response from it. If this XFrame is replaced
 *          with a different XFrame that has the same interface but a different
 *          implementation (e.g. based on the Node's "http" or "https" module)
 *          then the whole stack will be able to run outside the browser.
 *
 *      Transport - built on top of XFrame
 *
 *          Adds resiliency on top of XFrame. Because the <iframe> given
 *          by the server cannot be considered as a reliable way to deliver
 *          messages, Transport takes care of of misbehaving iframes. It also
 *          contains the logic of matching responses with requests.
 *
 *          Transport maintains an xframe queue that queues requests until
 *          the underlying xframe becomes ready to redirect requests to the server.
 *          Almost at all times this queue is empty, because the xframe is ready.
 *
 *          Transport maintains a throttling queue to make sure that at all times
 *          no more than a given number of requests (usually it's 5 or 6) are
 *          pending. This queue is necessary because browsers do not allow
 *          web apps to send have too many pending requests. This queue is normally
 *          empty because the client sends almost all requests in batches. This
 *          queue is aware of that every request may have a priority and
 *          enqueues requests according to their priority.
 *
 *      Endpoint - built on top of Transport
 *
 *          Adds on top of Transport the ability to seamlessly bypass
 *          authentication. If the server responds with an "HTTP 401 Unauthorized"
 *          response, Endpoint obtains the auth token and sends the same
 *          request again with the token. Thus layers above the endpoint
 *          do not need to care about authentication.
 *
 *      Application - built on top of Endpoint
 *
 *          While lower layers of the stack send requests to raw URLs, Application
 *          sends requests to UCWA resources and saves responses to the resource
 *          repository (the cache).
 *
 *          Application has a persistent connection with the server over which it
 *          receives events from it. For example an IM invitation arrives from this
 *          channel.
 *
 *          Application maintains a batching queue that is used to merge requests
 *          of similar priority in chunks and send them as batch requests. The batching
 *          queue is aware of that every request may have a priority and can be
 *          non batchable. For example a request to send an IM has a very high
 *          priority; a request to download a photo is non batchable.
 *
 * In addition to the stack itself, there are a few supplementary  objects:
 *
 *      Repository
 *
 *          Contains all UCWA resources known to the stack. Repository enables
 *          resource lookup by its type (rel), URL (href) or by some other properties.
 *
 *      Connection
 *
 *          Is the persistent event channel connecting the client with the UCWA server
 *          during the lifetime of the JS application. Under the hood it sends
 *          HTTP GET requests to the event channel URL provided by the server,
 *          parses responses and returns responses as events. The caller of Connection
 *          attaches a handler to Connection to receive events. The pending GET requests
 *          to get events are sent with the highest priority, which is +Infinity.
 *
 * @created June 2013
 * @blame antonkh
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Stack;
        (function (Stack) {
            'use strict';
            /** unit tests refer to this ns */
            Stack.Internal = Stack;
        })(Stack = Web.Stack || (Web.Stack = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var singleton = Web.Utils.singleton;
            var Enum = Web.Utils.Enum;
            /**
             * A singleton object that aggregates platform and browser information from
             * window.navigator properties.
             *
             *  @method isIE - returns true if this is Internet Explorer(IE) browser, false otherwise
             *  @method isSupportedIE - returns true if this is a supported version of IE, false otherwise
             *  @method isWindows - return true if this is a Windows OS, false otherwise
             *  @method isMac - return true if this is a Mac OS, false otherwise
             *  @method is32bit - return true if this is a 32-bit browser, false otherwise
             *  @method is64bit - return true if this is a 64-bit browser, false otherwise
             *  @method reset - resets the state of UserAgent. Platform/browser info will be read anew when any
             *                  of the other methods are called again. This method is needed for unit testing only.
             *  @example
             *      if (UserAgent().isWindows() && UserAgent().is64bit())
             *         // do something specific to 64-bit Windows
             *
             * @blame sosobov
             */
            Media.UserAgent = singleton(function () {
                var OsType = Enum('Unknown', 'Windows', 'Mac', 'Linux', 'Mobile'), BrowserBitness = Enum('Unknown', 'Win32', 'Wow64', 'Win64'), BrowserName = Enum('IE', 'Other');
                var browserName = BrowserName.Other, browserBitness = BrowserBitness.Unknown, osType = OsType.Unknown;
                var isInitialized = false;
                function init() {
                    if (isInitialized)
                        return;
                    var userAgent = Web.window.navigator.userAgent.toLowerCase();
                    var platform = Web.window.navigator.platform ? Web.window.navigator.platform.toLowerCase() : '';
                    // detect IE
                    if (userAgent.match(/msie \d+\.\d+/)) {
                        browserName = BrowserName.IE;
                    }
                    else if (userAgent.match(/trident\/\d+\.\d+/) &&
                        userAgent.match(/\brv:\d+\.\d+/)) {
                        // IE11 dropped MSIE token, its user-agent string looks like: 
                        // "Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko"
                        browserName = BrowserName.IE;
                    }
                    // detect browser bitness on windows
                    if (userAgent.match(/wow64/))
                        browserBitness = BrowserBitness.Wow64;
                    else if (platform.match(/win64/) || userAgent.match(/win64/))
                        browserBitness = BrowserBitness.Win64;
                    else if (platform.match(/win32/))
                        browserBitness = BrowserBitness.Win32;
                    // detect OS
                    if (userAgent.match(/mobi/))
                        osType = OsType.Mobile;
                    else if (userAgent.match(/windows nt/) || browserBitness != BrowserBitness.Unknown)
                        osType = OsType.Windows;
                    else if (platform.match(/mac/) || userAgent.match(/macintosh/))
                        osType = OsType.Mac;
                    else if (platform.match(/linux/) || userAgent.match(/linux/))
                        osType = OsType.Linux;
                    isInitialized = true;
                }
                function isIE() {
                    init();
                    return browserName == BrowserName.IE;
                }
                function isSupportedIE() {
                    return (isIE() && document.documentMode); // IE8+
                }
                function isWindows() {
                    init();
                    return osType == OsType.Windows;
                }
                function isMac() {
                    init();
                    return osType == OsType.Mac;
                }
                function is64bit() {
                    init();
                    return browserBitness == BrowserBitness.Win64;
                }
                function is32bit() {
                    init();
                    return browserBitness == BrowserBitness.Win32 ||
                        browserBitness == BrowserBitness.Wow64;
                }
                function reset() {
                    browserName = BrowserName.Other;
                    browserBitness = BrowserBitness.Unknown;
                    osType = OsType.Unknown;
                    isInitialized = false;
                }
                init();
                return {
                    isIE: isIE,
                    isSupportedIE: isSupportedIE,
                    isWindows: isWindows,
                    isMac: isMac,
                    is64bit: is64bit,
                    is32bit: is32bit,
                    reset: reset
                };
            });
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="UserAgent.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var assert = Web.Utils.assert;
            var isVoid = Web.Utils.isVoid;
            var Event = Web.Utils.Event;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            var StringEnum = Web.Utils.StringEnum;
            /**
             * A simple string formatter - replaces {ordinal} in the format string with the argument at
             * the ordinal position in the param list following the format string
             *
             * @param {string} format - the format string
             * @param variable list of parameters to be inserted into the format string
             *
             * @example
             *
             *      var s = formatString('Xbox {0} or {1}', 'One', 360);
             *      assert(s == 'Xbox One or 360');
             *
             * @blame sosobov
             */
            function formatString(format) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (arguments.length == 0)
                    throw new Error('Invalid arguments');
                return format.replace(/{(\d+)}/g, function (substr, index) {
                    // substr is the found substring, index is the first capture group
                    // ex: substr is '{0}', index is '0'
                    return (index in args) ? args[index] : substr;
                });
            }
            Media.formatString = formatString;
            /**
             * Wraps an LWA plugin object instance created by either <object> (ActiveX control) or
             * <embed> (NPAPI plugin) tag
             *
             * A wrapper around a platform-specific scriptable plugin object which is at the heart of each plugin component.
             * It is a COM object for IE and a scriptable plugin object for NPAPI browsers.
             *
             * @property {PluginObject.State} state - returns plugin object state
             *
             * @method innerObject - returns the DOM object representing the plugin object
             * @method {string} id - returns object id
             * @method createInnerObject - creates the plugin DOM object
             * @method destroyInnerObject - destroys the plugin DOM object
             * @method attach(parent, hookEvents) - attaches a visible plugin DOM object to the parent DOM element and
             *                                      optionally hooks up object events
             * @method onObjectLoaded - called by the wrapping PluginComponent after component is loaded
             * @method onObjectUnLoaded - called by the wrapping PluginComponent after component is unloaded
             * @event  event - raised by native plugin object
             *
             * @example
             *
             *    var po = PluginObject( {id: 'mainPluginObject', managerId: '_'} );
             *    po.event(onPOEvent);
             *    po.state.changed(onPOStateChanged);
             *    po.createInnerObject({ hide: true, hookEvents: true });
             *
             * @blame sosobov
             */
            function PluginObject(specs) {
                var state = Property({ value: PluginObject.State.None }), id = ((specs && specs.id) || '_plugin') + '_' + PluginObject.nextCount(), managerId = (specs && specs.managerId) ? specs.managerId : '_', event = new Event(), div, innerObject, isObjectLoaded = false, hookEvents = false, _self;
                function getInnerObject() {
                    return (state() == PluginObject.State.Attached) ? innerObject : null;
                }
                function isManager() {
                    return managerId == '_';
                }
                /**
                 * Creates the scriptable plugin object
                 */
                function createInnerObject(options) {
                    Media.log('PluginObject::createInnerObject ' + id);
                    assert(options);
                    assert(!isVoid(options.hide));
                    assert(!isVoid(options.hookEvents));
                    // we can start from uninitialized state only
                    assert(state() == PluginObject.State.None, 'invalid state');
                    // create html tag that embeds the plugin object
                    var tagHtml = getPluginObjectTag({
                        id: id,
                        managerId: managerId,
                        logLevel: Media.UserAgent().isIE() ? 1 : 0
                    });
                    // create a "div" element to host that object tag
                    div = options.hide ? createHiddenWrapper(tagHtml) :
                        createWrapper(tagHtml);
                    Media.log('PluginObject::createInnerObject ' + id + ' ' + div);
                    state.set(PluginObject.State.Created);
                    // if the object is hidden (i.e. the caller does not care where it is hosted) 
                    // attach our "div" element to the document.body
                    if (options.hide) {
                        attach(document.body, options.hookEvents);
                    }
                }
                /**
                 * Destroys the scriptable plugin object
                 */
                function destroyInnerObject() {
                    Media.log('PluginObject::destroyInnerObject ' + id);
                    cleanup();
                    state.set(PluginObject.State.Destroyed);
                }
                /**
                 * Removes the scriptable plugin object from the DOM tree
                 */
                function cleanup() {
                    Media.log('PluginObject::cleanup ' + id);
                    // window.setTimeout(function () {
                    try {
                        if (div)
                            div.parentNode.removeChild(div);
                    }
                    catch (error) {
                        Media.log(error.message);
                    }
                    div = null;
                    // }, 0);
                    innerObject = null;
                    isObjectLoaded = false;
                    hookEvents = false;
                }
                /**
                 * Attaches the "div" element containing the plugin object tag to the document body
                 */
                function attach(parent, fHookEvents) {
                    Media.log('PluginObject::attach ' + id);
                    assert(state() == PluginObject.State.Created);
                    assert(!isVoid(fHookEvents));
                    try {
                        parent.appendChild(div);
                        innerObject = div.firstChild;
                        if (isVoid(innerObject))
                            throw new Error('object missing');
                    }
                    catch (error) {
                        cleanup();
                        state.set(PluginObject.State.AttachFailed);
                        return;
                    }
                    hookEvents = fHookEvents;
                    // The manager plugin object is good to go upon creation, while plugin objects representing
                    // components should wait till components are actually loaded.
                    if (isManager()) {
                        isObjectLoaded = true;
                        validateAndAttachEvents();
                    }
                }
                /**
                 * Validates the created object and attaches events
                 * @remark this is the first place where we start calling methods of the native plugin object
                 */
                function validateAndAttachEvents() {
                    Media.log('PluginObject::validateAndAttachEvents ' + id);
                    // wait for the correct state
                    if (!innerObject || !isObjectLoaded)
                        return;
                    // check plugin object existence by making a plugin call
                    try {
                        if (!innerObject.CheckExistence()) {
                            cleanup();
                            state.set(PluginObject.State.ExistenceCheckFailed);
                            return;
                        }
                    }
                    catch (error) {
                        cleanup();
                        state.set(PluginObject.State.NotInstalled, error);
                        return;
                    }
                    // start listening to plugin object events
                    if (hookEvents) {
                        try {
                            // OnEvent and OnPing are LWA plugin callbacks
                            innerObject.OnEvent = eventHandler;
                            innerObject.OnPing = pingHandler;
                        }
                        catch (error) {
                            cleanup();
                            state.set(PluginObject.State.AttachFailed, error);
                            return;
                        }
                    }
                    state.set(PluginObject.State.Attached);
                }
                /**
                 * Called by the PluginComponent after it is loaded
                */
                function onObjectLoaded() {
                    Media.log('PluginObject::onObjectLoaded ' + id);
                    if (!isManager()) {
                        isObjectLoaded = true;
                        // need to delay the calling of this so that the entire
                        // path to the plugin is first freed and the loading is
                        // finalized before starting to call methods on the plugin
                        Web.window.setTimeout(validateAndAttachEvents, 0);
                    }
                }
                /**
                 * Called by the PluginComponent after it is unloaded
                 */
                function onObjectUnloaded() {
                    Media.log('PluginObject::onObjectUnloaded ' + id);
                    if (!isManager()) {
                        isObjectLoaded = false;
                        // need to delay the calling of this so that the entire
                        // path to the plugin is first freed and the loading is
                        // finalized before starting to call methods on the plugin
                        // window.setTimeout(destroyInnerObject, 0);
                        destroyInnerObject();
                    }
                }
                /**
                 * Handles native plugin object events
                 */
                function eventHandler(type, data) {
                    // if you want to see raw xml data add + ' ' + trim(data) to the output
                    // log('PluginObject::eventHandler - ' + id + ' ' + type); 
                    event.fire(type, data);
                }
                /**
                 * Handles native plugin object pings
                */
                function pingHandler() {
                    try {
                        innerObject.PingResponse();
                        event.fire('__FxPing', '');
                    }
                    catch (error) {
                        destroyInnerObject();
                        return false;
                    }
                    return true;
                }
                /**
                 * Verifies that Lync NPAPI plugin is installed
                 */
                function isNpPluginInstalled() {
                    return PluginObject.LYNC_PLUGIN.MIME_TYPE in Web.window.navigator.mimeTypes;
                }
                /**
                 * Creates an <embed> tag for the NPAPI plugin or an <object> tag for the ActiveX control
                 */
                function getPluginObjectTag(params) {
                    assert(params);
                    var tagHtml;
                    if (Media.UserAgent().isIE()) {
                        assert(Media.UserAgent().isWindows());
                        tagHtml = formatString(PluginObject.IE_HTML_TEMPLATE, params.id, PluginObject.LYNC_PLUGIN.MIME_TYPE, params.managerId, params.logLevel);
                    }
                    else {
                        assert(Media.UserAgent().isWindows() || Media.UserAgent().isMac());
                        // we can quickly check whether the plugin is installed
                        if (!isNpPluginInstalled()) {
                            state.set(PluginObject.State.NotInstalled);
                            throw Exception('PluginNotInstalled');
                        }
                        tagHtml = formatString(PluginObject.FF_HTML_TEMPLATE, params.id, PluginObject.LYNC_PLUGIN.MIME_TYPE, params.managerId, params.logLevel);
                    }
                    return tagHtml;
                }
                /**
                 * Creates a hidden "div" element containing the passed-in html fragment
                 */
                function createHiddenWrapper(html) {
                    var div = document.createElement('div');
                    div.style.position = 'absolute';
                    div.style.width = '1px';
                    div.style.height = '1px';
                    div.style.left = '-100px';
                    div.style.top = '0px';
                    div.style.overflow = 'hidden';
                    div.style.visibility = 'hidden';
                    div.innerHTML = html;
                    return div;
                }
                /**
                 * Creates a visible "div" element containing the passed-in html fragment
                 */
                function createWrapper(html) {
                    var div = document.createElement('div');
                    div.style.width = '100%';
                    div.style.height = '100%';
                    div.innerHTML = html;
                    return div;
                }
                _self = {
                    id: function () { return id; },
                    state: state.asReadOnly(),
                    innerObject: getInnerObject,
                    createInnerObject: createInnerObject,
                    destroyInnerObject: destroyInnerObject,
                    attach: attach,
                    event: event.observer,
                    onObjectLoaded: onObjectLoaded,
                    onObjectUnloaded: onObjectUnloaded
                };
                return _self;
            }
            Media.PluginObject = PluginObject;
            var PluginObject;
            (function (PluginObject) {
                PluginObject.nextCount = (function () {
                    var count = 0;
                    return function () {
                        return count++;
                    };
                })();
                PluginObject.State = StringEnum('None', 'ConfigNotSupported', 'NotInstalled', 'CreateFailed', 'ExistenceCheckFailed', 'AttachFailed', 'Created', 'Attached', 'Destroyed');
                PluginObject.IE_HTML_TEMPLATE = '<object id=\"{0}\" type=\"{1}\" width=\"100%\" height=\"100%\"><param name=\"managerID\" value=\"{2}\"><param name=\"componentID\" value=\"{0}\"><param name=\"logLevel\" value=\"{3}\"></object>';
                PluginObject.FF_HTML_TEMPLATE = '<embed id=\"{0}\" type=\"{1}\" width=\"100%\" height=\"100%\" managerID=\"{2}\" componentID=\"{0}\" logLevel=\"{3}\"></embed>';
                // This object is provided by each plugin build (<build-name>.js). Update it when the plugin is changed.
                // CLSID and CLSID64 were obtained by checking the registry. 
                // Need to confirm with plugin team why they don't provide CLSID for v16 plugin.
                var LYNC_PLUGIN;
                (function (LYNC_PLUGIN) {
                    LYNC_PLUGIN.MIME_TYPE = "application/x-skypeforbusiness-plugin-16.0";
                    LYNC_PLUGIN.MIME_TYPE_VERSION = "application/x-skypeforbusiness-version-16.0";
                    LYNC_PLUGIN.SHELLAPP_URL_SCHEME = "sfb-16.0";
                    LYNC_PLUGIN.SHELLAPP_ID = "com.microsoft.skypeforbusiness.shellapp.16.0";
                })(LYNC_PLUGIN = PluginObject.LYNC_PLUGIN || (PluginObject.LYNC_PLUGIN = {}));
                ;
            })(PluginObject = Media.PluginObject || (Media.PluginObject = {}));
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="PluginObject.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var check = Web.Utils.check;
            var assert = Web.Utils.assert;
            var isVoid = Web.Utils.isVoid;
            var isNumber = Web.Utils.isNumber;
            var isNotEmptyString = Web.Utils.isNotEmptyString;
            var Enum = Web.Utils.Enum;
            var Task = Web.Utils.Task;
            var Event = Web.Utils.Event;
            var Property = Web.Utils.Property;
            // matches enum values in the native plugin
            Media.PluginLoadResult = Enum('LoadSuccessful', 'NoInstanceManager', 'ComponentNotFound', 'ComponentLoadFailed', 'ComponentInitFailed', 'ComponentLoadCancelled');
            /** Represents plugin method result */
            function PluginMethodResult(res) {
                var i, s = '0x', hr = res[0];
                for (i = 7; i >= 0; i--)
                    s += ((hr >> (i * 4)) & 15).toString(16);
                res.hresultstr = s;
                res.succeeded = res[0] >= 0;
                res.failed = res[0] < 0;
                res.hresult = res[0];
                return res;
            }
            Media.PluginMethodResult = PluginMethodResult;
            /**
             * Wraps an individual native plugin component like MediaPlatformConfig or AVComponent
             *
             * Each component implements a certain subset of plugin functionality, for example:
             * Media configuration, Tuning Wizard, Audio/Video Call, App sharing, etc.
             *
             * @method {string} id() - returns component id
             * @method load() - loads component
             * @method unload() - unloads component
             * @property {PluginComponent.State} state - component state
             * @event event - raised by a contained plugin object
             *
             * @blame sosobov
             */
            function PluginComponent(specs) {
                assert(specs.type == 'MediaPlatformConfig' || specs.type == 'AVComponent' ||
                    specs.type == 'VideoUI' || specs.type == 'TuningWizard' ||
                    specs.type == 'AppShareCore' || specs.type == 'AppShareViewerUI');
                var state = Property({ value: PluginComponent.State.Unloaded }), event = new Event(), pluginMgr, // plugin manager
                pluginObj, // scriptable plugin object
                parent, // parent DOM element
                loadParams = [], // parameters passed to load method
                task, isCanceled = false;
                pluginMgr = specs.pluginManager;
                pluginObj = Media.PluginObject({
                    id: '_' + specs.type,
                    managerId: pluginMgr.id()
                });
                pluginObj.event(onPluginObjectEvent, 'async');
                pluginObj.state.changed(onPluginObjectState);
                /**
                 * Returns component id
                 */
                function id() {
                    return (pluginObj && pluginObj.id()) || "";
                }
                /**
                 * Starts loading plugin component
                 */
                function load() {
                    Media.log('PluginComponent::load ' + id());
                    assert(state() == PluginComponent.State.Unloaded, 'invalid component state');
                    assert(pluginMgr.state() == Media.PluginManager.State.Initialized);
                    assert(!task || task.state() != 'pending');
                    state.set(PluginComponent.State.Loading);
                    task = new Task('Loading ' + specs.type + '.', {
                        cancel: function (reason) {
                            Media.log('PluginComponent::load canceled ' + id());
                            isCanceled = true;
                            unload();
                            task.reject(reason);
                        }
                    });
                    // TODO: figure why LWA merges options passed to this method with ctor options
                    // extend the array 
                    loadParams = [].slice.call(arguments, 0);
                    try {
                        pluginObj.createInnerObject({
                            hide: specs.hide,
                            hookEvents: true
                        });
                    }
                    catch (err) {
                        if (task.state() == 'pending')
                            task.reject(err);
                    }
                    return task.promise;
                }
                /**
                 * Unloads component
                 */
                function unload() {
                    Media.log('PluginComponent::unload ' + id());
                    if (state() == PluginComponent.State.Loading ||
                        state() == PluginComponent.State.Loaded) {
                        state.set(PluginComponent.State.Unloading);
                        try {
                            pluginObj.innerObject().UnLoad();
                        }
                        catch (error) {
                            debugger;
                            cleanupPluginObject();
                            state.set(PluginComponent.State.Unloaded);
                        }
                    }
                }
                /**
                 * Called by PluginManager upon receiving the __FxComponentLoadComplete event
                 */
                function onLoaded() {
                    Media.log('PluginComponent::onLoaded ' + id());
                    assert(pluginObj);
                    pluginObj.onObjectLoaded();
                }
                /**
                 * Called by PluginManager upon receiving the __FxComponentUnLoadComplete event
                 */
                function onUnloaded() {
                    Media.log('PluginComponent::onUnloaded ' + id());
                    assert(pluginObj);
                    pluginObj.onObjectUnloaded();
                }
                /**
                 * Sets the hosting DOM element for a visible component
                 */
                function setContainer(parentElem) {
                    check(!specs.hide, 'setContainer called for a hidden component');
                    check(state() != PluginComponent.State.Loaded, 'setContainer called after component is already loaded');
                    parent = parentElem;
                    if (state() == PluginComponent.State.Loading &&
                        pluginObj.state() == Media.PluginObject.State.Created)
                        pluginObj.attach(parent, true);
                }
                /**
                 * Handles native plugin object events
                 */
                function onPluginObjectEvent(type, args) {
                    var arg0;
                    Media.log('%c' + id() + ' ' + type, 'color:blue', args);
                    switch (type) {
                        case '__FxLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isNumber(arg0));
                            if (arg0 == Media.PluginLoadResult.LoadSuccessful &&
                                state() == PluginComponent.State.Loading) {
                                if (!isCanceled)
                                    task.resolve();
                                state.set(PluginComponent.State.Loaded);
                                setLogLevel(1 /* Error */ |
                                    2 /* Info */);
                            }
                            else {
                                // TODO: examine arg0 to determine the failure reason
                                cleanupPluginObject();
                                if (!isCanceled)
                                    task.reject(arg0);
                                state.set(PluginComponent.State.Unloaded);
                            }
                            break;
                        case '__FxUnLoadComplete':
                            assert(args.length == 0);
                            cleanupPluginObject();
                            state.set(PluginComponent.State.Unloaded);
                            break;
                        default:
                            event.fire({ type: type, args: args });
                            break;
                    }
                }
                /**
                 * Plugin object state change event handler
                 */
                function onPluginObjectState(value) {
                    Media.log('PluginComponent::onPluginObjectState ' + id() + ' ' + value);
                    switch (value) {
                        case Media.PluginObject.State.None:
                            // initial state - ignore
                            break;
                        case Media.PluginObject.State.Created:
                            // attach the div element hosting the visible component to the parent DOM element
                            if (!specs.hide && !isVoid(parent))
                                pluginObj.attach(parent, true);
                            break;
                        case Media.PluginObject.State.Attached:
                            // load component
                            Web.window.setTimeout(loadComponent, 0);
                            break;
                        case Media.PluginObject.State.Destroyed:
                            state.set(PluginComponent.State.Unloaded);
                            break;
                        default:
                            cleanupPluginObject();
                            state.set(PluginComponent.State.Unloaded);
                    }
                }
                /**
                 * Loads component for real
                 */
                function loadComponent() {
                    Media.log('PluginComponent::loadComponent ' + id());
                    assert(state() == PluginComponent.State.Loading);
                    assert(pluginObj.state() == Media.PluginObject.State.Attached);
                    try {
                        pluginObj.innerObject().Load(specs.type, loadParams);
                    }
                    catch (error) {
                        debugger;
                        cleanupPluginObject();
                        state.set(PluginComponent.State.Unloaded);
                    }
                }
                /**
                 * plugin object cleanup
                 */
                function cleanupPluginObject() {
                    Media.log('PluginComponent::cleanupPluginObject ' + id());
                    if (pluginObj) {
                        pluginObj.event.off(onPluginObjectEvent);
                        pluginObj.state.changed.off(onPluginObjectState);
                        pluginObj.destroyInnerObject();
                        pluginObj = null;
                    }
                }
                /**
                 * Invokes component method
                 *
                 * @param {string} method - method name
                 * @param {arguments} - list of method parameters
                 *
                 * @returns [] - results array
                 */
                function invoke(method) {
                    assert(pluginObj);
                    assert(isNotEmptyString(method));
                    assert(state() == PluginComponent.State.Loaded);
                    var args = [].slice.call(arguments, 1), res, ret;
                    Media.log('PluginComponent::invoke %c' + method, 'color:red', args, id());
                    try {
                        res = pluginObj.innerObject().ProcessMethod(method, args);
                        ret = PluginMethodResult(res);
                    }
                    catch (error) {
                        Media.log(id() + ' error executing ' + method + ' ' + error.message);
                        throw error;
                    }
                    if (ret.failed)
                        throw new Error(method + ' : error = ' + ret.hresultstr);
                    return ret;
                }
                /**
                 * Sets logger level
                 * @param {Number} level - logger level, may be a combo of any levels defined by
                 *                         PluginComponent.LogLevel enumeration
                 */
                function setLogLevel(level) {
                    check(level > 0 && level <= 7 /* All */, 'Invalid level');
                    if (pluginObj)
                        try {
                            pluginObj.innerObject().SetLogLevel(level);
                        }
                        catch (error) {
                            Media.log('SetLogLevel(' + level + ') failed: ', error);
                        }
                }
                return {
                    id: id,
                    state: state.asReadOnly(),
                    load: load,
                    unload: unload,
                    onLoaded: onLoaded,
                    onUnloaded: onUnloaded,
                    event: event.observer,
                    setContainer: setContainer,
                    setLogLevel: setLogLevel,
                    invoke: invoke
                };
            }
            Media.PluginComponent = PluginComponent;
            var PluginComponent;
            (function (PluginComponent) {
                PluginComponent.State = Enum('Unloaded', 'Unloading', 'Loading', 'Loaded');
                PluginComponent.UnloadReason = Enum('None', 'CreateFailed', 'LoadFailed', 'UserInitiated', 'PluginInitiated', 'PluginClosedUnexpectedly');
            })(PluginComponent = Media.PluginComponent || (Media.PluginComponent = {}));
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var assert = Web.Utils.assert;
            var isString = Web.Utils.isString;
            var isNumber = Web.Utils.isNumber;
            var isBoolean = Web.Utils.isBoolean;
            /**
             * JavaScript supports signed integers |x| < 2^53. BigInt represents a signed 64-bit
             * integer (__int64 or "long long" in C++) as high and low 32-bit parts (+ sign)
             *
             * @constructor BigInt(string) - initialize the object from a string
             * @constructor BigInt(long) - initialize the object from a long
             * @constructor BigInt(high, low, [sign]) - initialize the object from high and low parts and an optional sign
             *
             * @method empty() - reset the object
             * @method fromString(string) - reset the object from a string
             * @method toString(string) - serialize the object to string
             *
             * @example
             *
             *   var bigInt = BigInt(1024, 2048);
             *   assert(bigInt.toString() == '1024,2048,false');
             *
             * @blame sosobov
             */
            function BigInt(_lo, _hi, _sign) {
                var high = 0, low = 0, isNegative = false;
                if (arguments.length == 1) {
                    if (isString(arguments[0]))
                        fromString(arguments[0]);
                    else if (isNumber(arguments[0]))
                        fromLong(arguments[0]);
                    else
                        throw new Error('invalid argument');
                }
                else if (arguments.length >= 2) {
                    assert(isNumber(arguments[0]));
                    assert(isNumber(arguments[1]));
                    assert(!arguments[2] || isBoolean(arguments[2]));
                    high = arguments[0];
                    low = arguments[1];
                    isNegative = arguments[2] || false;
                }
                function empty() {
                    high = 0;
                    low = 0;
                    isNegative = false;
                }
                function toString() {
                    return high + ',' + low + ',' + isNegative;
                }
                function fromString(str) {
                    assert(isString(str));
                    var args = str.split(',');
                    if (args.length < 2)
                        throw new Error('invalid argument format');
                    empty();
                    high = parseInt(args[0]);
                    low = parseInt(args[1]);
                    isNegative = sign(args[2]);
                }
                function sign(arg) {
                    var negative = false;
                    if (arg === undefined)
                        return false;
                    assert(isString(arg));
                    switch (arg) {
                        case 'true':
                            negative = true;
                            break;
                        case 'false':
                            negative = false;
                            break;
                        default:
                            throw new Error('invalid argument format');
                    }
                    return negative;
                }
                function fromLong(value) {
                    assert(isNumber(value));
                    if (value > 0x80000000 || value <= -0x80000000) {
                        throw new RangeError('out of range');
                    }
                    high = 0;
                    isNegative = false;
                    if (value < 0) {
                        value = -value;
                        isNegative = true;
                    }
                    low = value & 0xFFFFFFFF;
                }
                return {
                    toString: toString,
                    fromString: fromString,
                    empty: empty
                };
            }
            Media.BigInt = BigInt;
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="PluginComponent.ts" />
/// <reference path="BigInt.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var guid = Web.Utils.guid;
            var async = Web.Utils.async;
            var assert = Web.Utils.assert;
            var extend = Web.Utils.extend;
            var isVoid = Web.Utils.isVoid;
            var isNumber = Web.Utils.isNumber;
            var isString = Web.Utils.isString;
            var isBoolean = Web.Utils.isBoolean;
            var singleton = Web.Utils.singleton;
            var Enum = Web.Utils.Enum;
            var Task = Web.Utils.Task;
            var Property = Web.Utils.Property;
            var Exception = Web.Utils.Exception;
            /**
             * Encapsulates the native LWA media plugin.
             *
             * Loads/unloads the plugin into the browser,
             * controls the plugin lifetime and allows the application to
             * load individual plugin components.
             *
             * @blame sosobov
             */
            Media.PluginManager = singleton(function () {
                var components = {}, // Plugin components controlled by PluginManager
                pluginObj = null, // PluginManager plugin object
                state = Property({ value: Media.PluginManager.State.Deinitialized }), language, isRtl, loadTimerId = 0, loadTimeout = 5000, pingTimerId = 0, pingTimeout = 5000, task, isCanceled = false;
                /**
                 * Initializes PluginManager by creating PluginManager plugin object
                 *
                 * @param {string} specs.language - language, i.e. "en-us", "ru-ru"
                 * @param {bool}   specs.rtl - is a right-to-left script?
                 *
                 * @returns {Promise}
                 */
                function init(specs) {
                    if (state() == Media.PluginManager.State.Deinitialized) {
                        var id = '__mainPluginManager_' + guid().replace(/-/g, '_');
                        Media.log('PluginManager::init - id = ' + id);
                        language = (specs && specs.language) || "en-us";
                        isRtl = (specs && specs.rtl) || false;
                        assert(!task || task.state() != 'pending');
                        task = new Task('Loading the media plugin.', {
                            cancel: function (reason) {
                                Media.log('PluginManager::init canceled ' + id);
                                isCanceled = true;
                                stopLoadTimer();
                                cleanupPluginObject(reason);
                                state.set(Media.PluginManager.State.Deinitialized);
                                task.reject(reason);
                            }
                        });
                        state.set(Media.PluginManager.State.Initializing);
                        pluginObj = Media.PluginObject({
                            id: id,
                            managerId: '_'
                        });
                        pluginObj.event(onPluginObjectEvent, 'async');
                        pluginObj.state.changed(onPluginObjectState);
                        Media.log('PluginManager::init - creating inner object');
                        try {
                            pluginObj.createInnerObject({
                                hide: true,
                                hookEvents: true
                            });
                        }
                        catch (err) {
                            if (task.state() == 'pending')
                                task.reject(err);
                        }
                    }
                    else {
                        // init has already been called and the plugin is either 
                        // initializing or is already initialized; in either case
                        // we will return an existing promise
                        assert(task);
                    }
                    return task.promise;
                }
                /**
                 * Uninitializes PluginManager by unloading all loaded components and
                 * the main plugin object
                 */
                function uninit() {
                    Media.log('PluginManager::uninit');
                    if (state() == Media.PluginManager.State.Deinitialized)
                        return;
                    assert(!task || task.state() != 'pending');
                    task = new Task('Unloading the media plugin.');
                    try {
                        // unload components
                        for (var id in components)
                            components[id].unload();
                        pluginObj.innerObject().UnLoad();
                    }
                    catch (error) {
                        cleanupPluginObject(error);
                        state.set(Media.PluginManager.State.Deinitialized);
                        if (!isCanceled)
                            task.reject();
                    }
                    stopLoadTimer();
                    stopPingTimer();
                    return task.promise;
                }
                /**
                 * main plugin object cleanup
                 */
                function cleanupPluginObject(reason) {
                    Media.log('PluginManager::cleanupPluginObject', reason || '');
                    if (isVoid(pluginObj))
                        return;
                    pluginObj.event.off(onPluginObjectEvent);
                    pluginObj.state.changed.off(onPluginObjectState);
                    pluginObj.destroyInnerObject();
                    pluginObj = null;
                }
                /**
                 * returns the identifier of the main plugin object
                 */
                function id() {
                    assert(pluginObj);
                    return pluginObj.id();
                }
                /**
                 * Creates a plugin component
                 */
                function createComponent(specs) {
                    assert(specs);
                    assert(isString(specs.type));
                    assert(isBoolean(specs.hide));
                    assert(state() == Media.PluginManager.State.Initialized);
                    Media.log('PluginManager::createComponent ' + specs.type);
                    extend(specs, { pluginManager: Media.PluginManager() });
                    var component = Media.PluginComponent(specs);
                    var thisId = component.id();
                    var onComponentState = function (stateValue) {
                        Media.log('PluginManager::onComponentState ' + stateValue);
                        if (stateValue == Media.PluginComponent.State.Unloaded) {
                            if (components[thisId]) {
                                components[thisId].state.changed.off(onComponentState);
                                delete components[thisId];
                            }
                        }
                        else if (stateValue == Media.PluginComponent.State.Loaded) {
                        }
                    };
                    // do not change the order of the next two statements - if you do, the immediate execution  
                    // of the component state event handler while component is 'Unloaded' will orphan the component 
                    component.state.changed(onComponentState);
                    components[thisId] = component;
                    return component;
                }
                /**
                 * main plugin object event handler
                 */
                function onPluginObjectEvent(type, args) {
                    var arg0;
                    switch (type) {
                        case '__FxLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isNumber(arg0));
                            Media.log('PluginManager::onPluginObjectEvent ' + type);
                            stopLoadTimer();
                            if (arg0 == Media.PluginLoadResult.LoadSuccessful &&
                                state() == Media.PluginManager.State.Initializing) {
                                state.set(Media.PluginManager.State.Initialized);
                                startPingTimer();
                                task.resolve();
                            }
                            else {
                                // TODO: examine arg0 to determine the failure reason
                                cleanupPluginObject(Error(arg0));
                                state.set(Media.PluginManager.State.Deinitialized);
                                if (!isCanceled)
                                    task.reject();
                            }
                            break;
                        case '__FxUnLoadComplete':
                            assert(args.length == 0);
                            Media.log('PluginManager::onPluginObjectEvent ' + type);
                            stopLoadTimer();
                            stopPingTimer();
                            cleanupPluginObject();
                            state.set(Media.PluginManager.State.Deinitialized);
                            if (!isCanceled)
                                task.resolve();
                            break;
                        case '__FxComponentLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isString(arg0));
                            Media.log('PluginManager::onPluginObjectEvent ' + type + ' ' + arg0);
                            if (components[arg0]) {
                                components[arg0].onLoaded();
                            }
                            break;
                        case '__FxComponentUnLoadComplete':
                            assert(args.length == 1);
                            arg0 = args[0];
                            assert(isString(arg0));
                            Media.log('PluginManager::onPluginObjectEvent ' + type + ' ' + arg0);
                            if (components[arg0])
                                components[arg0].onUnloaded();
                            break;
                        case '__FxPing':
                            startPingTimer();
                            break;
                    }
                }
                /**
                 * main plugin object state change event handler
                 */
                function onPluginObjectState(value) {
                    Media.log('PluginManager::onPluginObjectState ' + value);
                    switch (value) {
                        case Media.PluginObject.State.None:
                            // initial state - ignore
                            break;
                        case Media.PluginObject.State.Created:
                            // nothing interesting - ignore
                            break;
                        case Media.PluginObject.State.Attached:
                            Web.window.setTimeout(loadManager, 0);
                            break;
                        case Media.PluginObject.State.NotInstalled:
                            var err = Exception('PluginNotInstalled');
                            cleanupPluginObject(err);
                            state.set(Media.PluginManager.State.Deinitialized);
                            if (!isCanceled && task.state() == 'pending')
                                task.reject(err);
                            break;
                        default:
                            stopLoadTimer();
                            cleanupPluginObject();
                            state.set(Media.PluginManager.State.Deinitialized);
                    }
                }
                /**
                 * Loads plugin component manager
                 */
                function loadManager() {
                    Media.log('PluginManager::loadManager');
                    if (state() != Media.PluginManager.State.Initializing ||
                        pluginObj.state() != Media.PluginObject.State.Attached)
                        return;
                    try {
                        startLoadTimer();
                        pluginObj.innerObject().Load('__pluginFx', [language, isRtl]);
                    }
                    catch (error) {
                        stopLoadTimer();
                        cleanupPluginObject(error);
                        state.set(Media.PluginManager.State.Deinitialized);
                    }
                }
                /**
                 * Checks the existence of the main plugin object
                 */
                function pluginObjectExists() {
                    var exists = false;
                    try {
                        exists = pluginObj.innerObject().CheckExistence();
                    }
                    catch (error) { }
                    return exists;
                }
                function startLoadTimer() {
                    stopLoadTimer();
                    loadTimerId = Web.window.setTimeout(onLoadTimeout, loadTimeout);
                }
                function stopLoadTimer() {
                    if (loadTimerId != 0) {
                        Web.window.clearTimeout(loadTimerId);
                        loadTimerId = 0;
                    }
                }
                function onLoadTimeout() {
                    if (pluginObjectExists()) {
                        startLoadTimer();
                    }
                    else {
                        stopLoadTimer();
                        cleanupPluginObject(Error('TimedOut'));
                        state.set(Media.PluginManager.State.Deinitialized);
                    }
                }
                function startPingTimer() {
                    stopPingTimer();
                    pingTimerId = Web.window.setTimeout(onPingTimeout, pingTimeout);
                }
                function stopPingTimer() {
                    if (pingTimerId != 0) {
                        Web.window.clearTimeout(pingTimerId);
                        pingTimerId = 0;
                    }
                }
                function onPingTimeout() {
                    if (Media.UserAgent().isMac()) {
                        // On mac there is no native timeout, so we use this timer to track the existence of the plugin
                        startPingTimer();
                    }
                    else {
                        // On windows this will get hit if the plugin loaded/pinged once but not again for 5 seconds.
                        stopPingTimer();
                    }
                    if (!pluginObjectExists())
                        uninit();
                }
                return {
                    init: async(init),
                    uninit: async(uninit),
                    createComponent: createComponent,
                    state: state.asReadOnly(),
                    id: id
                };
            });
            Media.PluginManager.State = Enum('Deinitialized', 'Deinitializing', 'Initializing', 'Initialized');
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="utils.ts" />
/// <reference path="media/plugin/PluginManager.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Settings;
        (function (Settings) {
            /** Dumps to the dev console all media logs */
            Settings.logMedia = false;
        })(Settings = Web.Settings || (Web.Settings = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var debug = Web.Utils.debug;
            function isFirefoxWebRtc() {
                return !!navigator['mozGetUserMedia'];
            }
            Media.isFirefoxWebRtc = isFirefoxWebRtc;
            function log() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i - 0] = arguments[_i];
                }
                if (Web.Settings.logMedia)
                    debug.log.apply(null, args);
            }
            Media.log = log;
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_1) {
            var Internal;
            (function (Internal) {
                'use strict';
                var foreach = Web.Utils.foreach;
                var batched = Web.Utils.batched;
                var deepEqual = Web.Utils.deepEqual;
                var isFunction = Web.Utils.isFunction;
                var isProperty = Web.Utils.isProperty;
                var Model = Web.Utils.Model;
                var Symbol = Web.Utils.Symbol;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var ConstProperty = Web.Utils.ConstProperty;
                var ENotSupported = Web.Utils.ENotSupported;
                var Resource = Web.Stack.Resource;
                /** It's used to distinguish the case when a property is updated
                    after an event from UCWA from the case when someone invokes
                    Property::set. */
                var sUpdated = Symbol('updated');
                /** Used to attach hidden fields to created properties and collections.
                    Essentially, it's a simulation of WeakMap from ES6. */
                var sDescriptor = Symbol('hidden');
                var Descriptor = (function () {
                    function Descriptor(describe) {
                        var _this = this;
                        /**
                         * Properties that need to be exposed in the model.
                         *
                         *  This is a mapping from a property name to a parsing function which is,
                         *  in most cases, the identity function that returns whatever it's given:
                         *
                         *      properties: {
                         *          name: function (value) { return value },
                         *          uri: function (value) { return value },
                         *          id: function (value) { return +value }
                         *      }
                         *
                         *  Each property can provide the following additional information:
                         *
                         *      parse - method to change resource value to property representation
                         *      convert - method to change property value to resource value
                         *      prepare - method to change value prior to sending PUT
                         *      readOnly - the property is read-only even if other properties are not
                         *
                         *  Example:
                         *
                         *      expirationTime: {
                         *          parse: timeStampToDate,
                         *          convert: dateToTimeStamp,
                         *          prepare: function (val) {
                         *              return val.toJSON();
                         *          }
                         *      }
                         *
                         *  The property may be set using a Date object which will need to be compared against the
                         *  resource representation and modified to properly send in the PUT request.
                         */
                        this.properties = {};
                        /**
                         * Commands that need to be exposed in the model.
                         *
                         *  In the current version, only the 'enabled' property in each exposed command
                         *  is implemented. This read-only property is associated with whether the
                         *  resource contains the corresponding link.
                         */
                        this.commands = {};
                        /**
                         * Some resources contain a collection of links to other resources.
                         * For instance, the contact list is represented by UCWA this way:
                         *
                         *      /myContacts
                         *          /contact[x]
                         *              displayName
                         *              uri
                         *
                         * Such collections of links can be mapped to collections of models.
                         */
                        this.collections = {};
                        /**
                         * Some resources contain other resources.
                         * A good example is /application/communication.
                         */
                        this.members = {};
                        describe({
                            member: function (name, describe) {
                                _this.members[name] = new Descriptor(describe);
                            },
                            command: function (name) {
                                _this.commands[name] = {};
                            },
                            property: function (name, desc) {
                                _this.properties[name] = desc || {};
                            },
                            collection: function (name, describe) {
                                _this.collections[name] = new Descriptor(describe);
                            }
                        });
                    }
                    return Descriptor;
                })();
                /**
                 * Wraps a UCWA resource into an observable model by mapping properties of the
                 * resource to observable properties of the model.
                 *
                 *      ObservableResource(ucwa, "/contacts/johndoe", $ => {
                 *          $.property('uri');
                 *          $.property('name');
                 *          $.member('contactPresence', $ => {
                 *              $.property('availability');
                 *              $.property('activity');
                 *              $.property('activeSince', s => new Date(/\d+/.exec(s)[0]));
                 *          });
                 *      });
                 *
                 * Resources that contain an `etag` can be updated by the supplied properties
                 * (that are not marked as read-only) which will create a PUT request to send
                 * an aggregated update.
                 *
                 * @created Apr 2014
                 * @blame antonkh
                 * @blame v-shagma
                 */
                function ObservableResource(ucwa, source, describe) {
                    var dfdget;
                    var self = Model();
                    var collections = {}; // collections are indexed by hrefs
                    var properties = {};
                    var commands = {};
                    var members = {}; // hrefs
                    var writable = Property({ value: false, reason: Exception('Disconnected') });
                    var descriptor = isFunction(describe) ?
                        new Descriptor(describe) :
                        describe; // unit tests can pass raw descriptors
                    /** When one observable creates a nested observable resource,
                        it gives to the latter a Property<string> which is able
                        to fetch the href on demand. So if there's a chain of
                        nested resources, a request from the last resource will
                        be nicely chained up to the root resource. */
                    var resource = Property({
                        // the app may not be signed in at the moment
                        get: function () { return resource() || ucwa.init()
                            .then(function () { return isProperty(source) ? source.get() : source; })
                            .then(function (href) { return ucwa.get(href); }); } // the .get() should fail if the resource isn't available
                    });
                    var changeProperty = batched(function (requests) {
                        var r = resource(); // by this moment the resource should be available
                        var snapshot = r.getSnapshot();
                        var data = {}; // this is what will be sent in the PUT request
                        var changed = false;
                        for (var _i = 0; _i < requests.length; _i++) {
                            var _a = requests[_i], name_5 = _a[0], value = _a[1];
                            var p = properties[name_5];
                            var $ = p[sDescriptor];
                            var oldVal = snapshot[name_5];
                            var newVal = $.convert ? $.convert(value) : value; // new Date(123) => "/Date(123)/"
                            // TODO: if the user changes a property value multiple times:
                            // model.prop(1), model.prop(2), model.prop(1) then this code
                            // will send the PUT request anyway, despite it's not needed
                            if (!deepEqual(newVal, oldVal)) {
                                changed = true;
                                snapshot[name_5] = newVal;
                            }
                        }
                        if (changed) {
                            foreach(snapshot, function (value, name) {
                                var p = properties[name];
                                var $ = p && p[sDescriptor];
                                data[name] = $ && $.prepare ?
                                    $.prepare($.parse(value)) :
                                    value;
                            });
                            return ucwa.send('PUT', r.href, { data: data });
                        }
                    }, Infinity);
                    function fetch() {
                        var promise = dfdget || resource.get().then(function (r) { return ucwa.send('GET', r.href); });
                        dfdget = promise;
                        // if GET fails, allow further attempts to send it again;
                        // note, that in unit tests .then(...) doesn't add a delay
                        dfdget.then(null, function () { dfdget = null; });
                        return promise;
                    }
                    foreach(descriptor.collections, function (desc, name) {
                        var items = Collection({
                            subscribed: fetch,
                            get: function () { return resource.get()
                                .then(function (r) { return !r.hasLink(name) && fetch(); })
                                .then(function () { return null; }); }
                        });
                        items[sDescriptor] = desc;
                        collections[name] = items;
                        self[name] = items.asReadOnly();
                    });
                    foreach(descriptor.properties, function (_data, name) {
                        var data = (isFunction(_data) ? { parse: _data } : _data);
                        if (!data.parse)
                            data.parse = function (x) { return x; };
                        var p = Property({
                            subscribed: fetch,
                            get: function () { return resource.get().then(function (r) {
                                return r.has(name) ? p() : fetch().then(function () { return p(); });
                            }); }
                        });
                        // if the property isn't there, it cannot be changed
                        var set = function (value) { return resource.get()
                            .then(function (r) { return changeProperty([name, value], 0)
                            .then(function () { return p(); }); }); };
                        p[sDescriptor] = data;
                        properties[name] = p;
                        self[name] = p.fork(Command(set, data.readOnly ? ConstProperty(false) : writable));
                    });
                    foreach(descriptor.commands, function (data, name) {
                        var enabled = Property({
                            get: function () { return resource.get()
                                .then(function (r) { return !r.hasLink(name) && fetch(); })
                                .then(function (r) { return r.hasLink(name); }); }
                        });
                        commands[name] = { enabled: enabled };
                        self[name] = Command(function () { throw ENotSupported(); }, enabled.asReadOnly());
                    });
                    foreach(descriptor.members, function (desc, name) {
                        var href = Property({
                            // the value of href is set by the Resource::updated handler
                            get: function () { return href() || fetch().then(function (r) { return r.link(name).href; }); }
                        });
                        members[name] = href;
                        self[name] = ObservableResource(ucwa, href.asReadOnly(), desc);
                    });
                    ucwa.init().then(function () {
                        if (source instanceof Resource)
                            resource(source);
                        else if (isProperty(source))
                            source.changed(function (href) { return resource(ucwa.get(href)); });
                        else if (ucwa.exists(source))
                            resource(ucwa.get(source));
                    });
                    // start observing the resource once it becomes available
                    resource.once(function (r) { return !!r; }, function () {
                        var r = resource();
                        r.updated(function () {
                            writable(r.has('etag'), Exception('ETagMissing'));
                            foreach(collections, function (items, name) {
                                // items are added when new links appear
                                for (var _i = 0, _a = r.links(name); _i < _a.length; _i++) {
                                    var link = _a[_i];
                                    if (!items(link.href)) {
                                        var desc = items[sDescriptor];
                                        var item = ObservableResource(ucwa, link.href, desc);
                                        items.add(item);
                                    }
                                }
                            });
                            foreach(properties, function (p, name) {
                                var parse = p[sDescriptor].parse;
                                var value = r.has(name) ? parse(r.get(name)) : void 0;
                                p(value, sUpdated); // a custom reason invokes all observers
                            });
                            foreach(commands, function (m, name) {
                                m.enabled(r.hasLink(name));
                            });
                            foreach(members, function (href, name) {
                                if (r.hasLink(name))
                                    href(r.link(name).href);
                            });
                        });
                        r.dirty.when(true, function () {
                            dfdget = null;
                        });
                    });
                    return self;
                }
                Internal.ObservableResource = ObservableResource;
            })(Internal = Model_1.Internal || (Model_1.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="model/ObservableResource.ts" />
/**
 * Parts of the model layer common for both
 * media-dependent and media-independent models.
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Exception = Web.Utils.Exception;
                var Symbol = Web.Utils.Symbol;
                function EInvitationFailed(reason) {
                    var text = reason && reason.message;
                    return Exception.call(text, 'InvitationFailed', { reason: reason });
                }
                Internal.EInvitationFailed = EInvitationFailed;
                var Modality;
                (function (Modality) {
                    var State;
                    (function (State) {
                        State.Disconnected = 'Disconnected';
                        State.Disconnecting = 'Disconnecting';
                        State.Connecting = 'Connecting';
                        State.Ringing = 'Ringing';
                        State.Connected = 'Connected';
                        State.Notified = 'Notified';
                        State.Created = 'Created';
                    })(State = Modality.State || (Modality.State = {}));
                })(Modality = Internal.Modality || (Internal.Modality = {}));
                /** model[sHref] = href of the underlying resource */
                Internal.sHref = Symbol('href');
                /** model[sInternal] - an object exposing internal model properties and methods */
                Internal.sInternal = Symbol('internal');
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                /**
                 * Wraps the rel=mediaPolicies resource into an observable model.
                 *
                 * rel=mediaPolicies represents a resource that allows clients to fetch
                 * all media-related settings that cannot be modeled as capability links
                 * or properties of individual resources. Most of them are directly consumed
                 * by media stack manager on the client side.
                 *
                 * @created Apr 2014
                 * @blame antonkh
                 */
                var MediaPolicies = (function () {
                    //#endregion
                    function MediaPolicies(ucwa) {
                        function tryParseInt(src) {
                            var num = +src | 0;
                            return num == src ? num : src;
                        }
                        return Internal.ObservableResource(ucwa, { rel: 'mediaPolicies' }, function ($) {
                            $.property('bandwidthControl');
                            $.property('fipsCompliantMedia');
                            $.property('poorDeviceWarnings');
                            $.property('poorNetworkWarnings');
                            $.property('portRange');
                            $.property('qualityOfService');
                            $.property('audioVideoEncryption');
                            $.property('audioBitRate', tryParseInt);
                            $.property('audioBypass');
                            $.property('audioBypassId');
                            $.property('internalAudioBypassMode');
                            $.property('externalAudioBypassMode');
                            $.property('minimumAudioPort', tryParseInt);
                            $.property('maximumAudioPort', tryParseInt);
                            $.property('minimumVideoPort', tryParseInt);
                            $.property('maximumVideoPort', tryParseInt);
                            $.property('maximumVideoRateAllowed');
                            $.property('multiViewJoin');
                            $.property('totalReceivedVideoBitRateKB', tryParseInt);
                            $.property('video');
                            $.property('videoBitRate', tryParseInt);
                            $.property('applicationSharingBitRate', tryParseInt);
                            $.property('applicationSharingEncryption');
                            $.property('minimumApplicationSharingPort', tryParseInt);
                            $.property('maximumApplicationSharingPort', tryParseInt);
                            $.property('highPerformanceApplicationSharingInOnlineMeeting');
                        });
                    }
                    return MediaPolicies;
                })();
                Internal.MediaPolicies = MediaPolicies;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var PluginManager = Web.Media.PluginManager;
                /**
                 * Encapsulates media plugin functionality.
                 * The AV modality takes a reference to this object and
                 * uses it to communicate with the media plugin.
                 * Unit tests create a mock of this object.
                 */
                var MediaPlugin = (function () {
                    //#endregion
                    function MediaPlugin(ucwa) {
                        var mediaConfig, appSharing;
                        function getMediaConfig() {
                            return mediaConfig ||
                                initMedia().then(function () {
                                    return ucwa.init();
                                }).then(function () {
                                    mediaConfig = Internal.MediaConfig({
                                        ucwa: ucwa,
                                        mediaPlugin: self
                                    });
                                    return mediaConfig.init();
                                }).then(function () {
                                    return mediaConfig;
                                });
                        }
                        function getAppSharing(language) {
                            return appSharing ||
                                initMedia(language).then(getMediaConfig).then(function () {
                                    appSharing = Internal.AppSharing({
                                        mediaConfig: mediaConfig,
                                        component: createComponent({
                                            type: 'AppShareCore',
                                            hide: true
                                        })
                                    });
                                    return appSharing.init();
                                }).then(function () {
                                    return appSharing;
                                });
                        }
                        function initMedia(language) {
                            if (language === void 0) { language = 'en-us'; }
                            check(PluginManager, 'NoMedia');
                            // TODO: deduce rtl from language
                            var rtl = false;
                            return PluginManager().init({
                                language: language,
                                rtl: rtl
                            });
                        }
                        function uninitMedia() {
                            if (mediaConfig) {
                                mediaConfig.uninit();
                                mediaConfig = null;
                            }
                            return PluginManager().uninit();
                        }
                        function uninitAppSharing() {
                            if (appSharing) {
                                appSharing.uninit();
                                appSharing = null;
                            }
                        }
                        function createComponent(options) {
                            return PluginManager().createComponent(options);
                        }
                        var self = {
                            getMediaConfig: async(getMediaConfig),
                            getAppSharing: async(getAppSharing),
                            initMedia: async(initMedia),
                            uninitMedia: async(uninitMedia),
                            uninitAppSharing: async(uninitAppSharing),
                            createComponent: createComponent
                        };
                        return self;
                    }
                    return MediaPlugin;
                })();
                Internal.MediaPlugin = MediaPlugin;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var Task = Web.Utils.Task;
                var Property = Web.Utils.Property;
                var EWrongType = Web.Utils.EWrongType;
                var StringEnum = Web.Utils.StringEnum;
                var log = Web.Media.log;
                /**
                 * Media configuration model.
                 *
                 * @param {UCWA} ucwa
                 * @param {MediaPlugin} mediaPlugin
                 *
                 * @method {Promise} init - initialized media configuration
                 * @method uninit - uninitializes media configuration
                 * @method {Boolean} isInternal - indicates whether this client is signed in on the internal or external network
                 * @method {MediaEnum.SecurityLevel} audioVideoSecurityLevel - returns audio/video security level
                 * @method {MediaEnum.SecurityLevel}applicationSharingSecurityLevel - returns app sharing security level
                 * @method {Number} maxVideoChannelCount - returns the max number of video channels
                 * @method  setDefaultDevices - sets default media devices
                 * @property {MediaConfig.ProxyDetection} proxyDetection - proxy detection state
                 *
                 * @author sosobov
                 * @created October 2013
                 */
                function MediaConfig(options) {
                    var ucwa = options.ucwa, mediaPlugin = options.mediaPlugin, isInternal = !!ucwa.get({ rel: 'root' }).get('internal', false), pcMediaConfig, proxyDetection = Property({ value: MediaConfig.ProxyDetection.None }), proxies = {}, EnforcementPolicy = StringEnum('Enforced', 'Supported', 'NotSupported');
                    options = null;
                    /**
                     * Initializes media configuration by loading MediaPlatformConfig plugin component,
                     * fetching media config from UCWA server and passing it to the plugin component
                     */
                    function init() {
                        pcMediaConfig = mediaPlugin.createComponent({
                            type: 'MediaPlatformConfig',
                            hide: true
                        });
                        pcMediaConfig.event(onPluginComponentEvent);
                        pcMediaConfig.state.changed(function (state) {
                            log('pcMediaConfig.state = ' + state);
                        });
                        var p = pcMediaConfig.load().then(getMediaConfig).then(setMediaConfig).then(null, function (error) {
                            log('MediaConfig::init rejected');
                            uninit();
                            throw error;
                        });
                        return p;
                    }
                    /**
                     * Uninitializes media configuration
                     */
                    function uninit() {
                        if (pcMediaConfig) {
                            pcMediaConfig.event.off(onPluginComponentEvent);
                            pcMediaConfig = null;
                        }
                    }
                    /**
                     * MediaPlatformConfig component event listener
                     */
                    function onPluginComponentEvent(ev) {
                        if (ev.type == 'ProxyDetectionCompleted') {
                            // args0 (string) - the host name, args1 (boolean) - was the proxy detected or not
                            proxies[ev.args[0]] = (ev.args[1] == 'true') ?
                                MediaConfig.ProxyDetection.Succeeded :
                                MediaConfig.ProxyDetection.Failed;
                            // we signal that proxy detection is completed once we received the plugin event
                            // for all tested proxies.
                            var done = true, res = MediaConfig.ProxyDetection.Failed;
                            for (var p in proxies) {
                                switch (p) {
                                    case MediaConfig.ProxyDetection.None:
                                    case MediaConfig.ProxyDetection.Started:
                                        done = false;
                                        break;
                                    case MediaConfig.ProxyDetection.Succeeded:
                                        res = MediaConfig.ProxyDetection.Succeeded;
                                        break;
                                }
                            }
                            if (done)
                                proxyDetection(res);
                        }
                    }
                    /**
                     * Fetches media configuration from UCWA server
                     */
                    function getMediaConfig() {
                        return Task.waitAll([
                            ucwa.send('GET', { rel: 'mediaPolicies' }),
                            ucwa.send('GET', { rel: 'mediaRelayAccessToken' })
                        ]);
                    }
                    /**
                     * Set media configuration in the plugin
                     */
                    function setMediaConfig() {
                        var comm = ucwa.get({ rel: 'communication' }), mras = ucwa.get(comm.link('mediaRelayAccessToken').href), mp = ucwa.get(comm.link('mediaPolicies').href), res;
                        if (mp.properties.portRange == 'Enabled') {
                            res = pcMediaConfig.invoke('SetPortRanges', mp.properties['minimumAudioPort'], mp.properties['maximumAudioPort'], mp.properties['minimumVideoPort'], mp.properties['maximumVideoPort'], mp.properties['minimumApplicationSharingPort'], mp.properties['maximumApplicationSharingPort']);
                        }
                        res = pcMediaConfig.invoke('SetMediaPlatformConfig', mp.properties['qualityOfService'] == 'Enabled', isInternal);
                        res = pcMediaConfig.invoke('SetMediaSettings', true, // fEnableBWCheck
                        true, // EnableBWPolicyOverride
                        parseInt(mp.properties['audioBitRate']) || -1, parseInt(mp.properties['videoBitRate']) || -1, parseInt(mp.properties['applicationSharingBitRate']) || -1, -1, // file transfer bit rate ignored
                        parseInt(mp.properties['totalReceivedVideoBitRateKB']) || -1, mp.properties['fipsCompliantMedia'] == 'Required');
                        // TODO: param from some user options ??
                        res = pcMediaConfig.invoke('SetStereoAudioRendering', false);
                        var username = mras.properties['userName'];
                        var password = mras.properties['password'];
                        var mr, tcpPort, udpPort, hostName, realm = '*';
                        for (var i = 0, len = mras.related.mediaRelay.length; i < len; i++) {
                            mr = ucwa.get(mras.related.mediaRelay[i].href);
                            if ((isInternal && mr.properties['location'] == 'Internet') ||
                                (!isInternal && mr.properties['location'] == 'Intranet'))
                                continue;
                            hostName = mr.properties['host'];
                            tcpPort = mr.properties['tcpPort'] || -1;
                            udpPort = mr.properties['udpPort'] || -1;
                            res = pcMediaConfig.invoke('AddProxyServer', hostName);
                            proxies[hostName] = MediaConfig.ProxyDetection.Started;
                            if (proxyDetection() == MediaConfig.ProxyDetection.None)
                                proxyDetection(MediaConfig.ProxyDetection.Started);
                            if (udpPort != -1) {
                                try {
                                    res = pcMediaConfig.invoke('AddIceServer', 1 /* TurnUDP */, hostName, udpPort, username, realm, password);
                                }
                                catch (err) {
                                    log(err.message + ' : UDP ' + hostName + ':' + udpPort);
                                }
                            }
                            if (tcpPort != -1) {
                                try {
                                    res = pcMediaConfig.invoke('AddIceServer', 2 /* TurnTCP */, hostName, tcpPort, username, realm, password);
                                }
                                catch (err) {
                                    log(err.message + ' : TCP ' + hostName + ':' + tcpPort);
                                }
                            }
                        }
                    }
                    /**
                     * Sets default audio and video devices
                     */
                    function setDefaultDevices() {
                        assert(pcMediaConfig);
                        pcMediaConfig.invoke('SetDefaultDevices');
                    }
                    /**
                     * Returns AV security level
                     */
                    function getAudioVideoSecurityLevel() {
                        var comm = ucwa.get({ rel: 'communication' }), mp = ucwa.get(comm.link('mediaPolicies').href), encr, level;
                        if (mp) {
                            encr = mp.properties['audioVideoEncryption'];
                            switch (encr) {
                                case EnforcementPolicy.Enforced:
                                    level = 3 /* Required */;
                                    break;
                                case void 0:
                                // anonymous user will not get this media policy from the
                                // server - when undefined we default to 'Supported'.
                                case EnforcementPolicy.Supported:
                                    level = 2 /* Supported */;
                                    break;
                                case EnforcementPolicy.NotSupported:
                                    level = 1 /* Unsupported */;
                                    break;
                                default:
                                    throw EWrongType(encr, 'EnforcementPolicy');
                            }
                        }
                        return level;
                    }
                    /**
                     * Returns AS security level
                     */
                    function getApplicationSharingSecurityLevel() {
                        var comm = ucwa.get({ rel: 'communication' }), mp = ucwa.get(comm.link('mediaPolicies').href), encr, level;
                        if (mp) {
                            encr = mp.properties['applicationSharingEncryption'];
                            switch (encr) {
                                case EnforcementPolicy.Enforced:
                                    level = 3 /* Required */;
                                    break;
                                case void 0:
                                // anonymous user will not get this media policy from the
                                // server - when undefined we default to 'Supported'.
                                case EnforcementPolicy.Supported:
                                    level = 2 /* Supported */;
                                    break;
                                case EnforcementPolicy.NotSupported:
                                    level = 1 /* Unsupported */;
                                    break;
                                default:
                                    throw EWrongType(encr, 'EnforcementPolicy');
                            }
                        }
                        return level;
                    }
                    /**
                     * Returns the number of video channels
                     */
                    function getMaxVideoChannelCount() {
                        var res = pcMediaConfig.invoke('GetMaxVideoChannelCount');
                        return res[1];
                    }
                    return {
                        init: async(init),
                        uninit: uninit,
                        isInternal: function () { return isInternal; },
                        audioVideoSecurityLevel: getAudioVideoSecurityLevel,
                        applicationSharingSecurityLevel: getApplicationSharingSecurityLevel,
                        maxVideoChannelCount: getMaxVideoChannelCount,
                        proxyDetection: proxyDetection.asReadOnly(),
                        setDefaultDevices: setDefaultDevices
                    };
                }
                Internal.MediaConfig = MediaConfig;
                var MediaConfig;
                (function (MediaConfig) {
                    ;
                    MediaConfig.ProxyDetection = StringEnum('None', 'Started', 'Succeeded', 'Failed');
                })(MediaConfig = Internal.MediaConfig || (Internal.MediaConfig = {}));
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_2) {
            var Internal;
            (function (Internal) {
                'use strict';
                var assert = Web.Utils.assert;
                var DataUri = Web.Utils.DataUri;
                var async = Web.Utils.async;
                var extend = Web.Utils.extend;
                var indexOf = Web.Utils.indexOf;
                var guid = Web.Utils.guid;
                var Property = Web.Utils.Property;
                var check = Web.Utils.check;
                var Exception = Web.Utils.Exception;
                var Task = Web.Utils.Task;
                var Command = Web.Utils.Command;
                var Model = Web.Utils.Model;
                var log = Web.Media.log;
                /**
                 * Starts outgoing app sharing and receives incoming app sharing.
                 * Uses the native media plugin for that.
                 *
                 * @param {UCWA} ucwa
                 * @param {MediaPlugin} mediaPlugin
                 * @param {SharedResources} sharedResources
                 * @param {String} [threadId] - Required for outgoing app sharing.
                 * @param {AppSharingInvitation} [invitation] - Required for incoming app sharing.
                 * @param {Resource} [resource] - Required for incoming app sharing.
                 * @param {Collection} participants
                 * @param {Resource} [rConversation] - The parent rel=conversation resource.
                 *
                 *      If the AS modality gets added to an existing conversation, the AS call
                 *      is started with sending a POST request to rel=conversation/rel=applicationSharing/rel=addScreenSharing.
                 *
                 *      If the AS modality is the first modality in the conversation, then the
                 *      AS call is started with sending the same request to the global rel=startScreenSharing link.
                 *
                 * @property {Modality.State} state
                 * @property {ShareableWindow|ShareableMonitor} shared - the currently shared content
                 *
                 * @member {Participant} from
                 *
                 * @command {Promise} start - Starts an outgoing call.
                 * @command {Promise} accept - Accepts an incoming call.
                 * @command {Promise} decline - Declines an incoming call.
                 * @command {Promise} stop - Stops an ongoing call.
                 *
                 * @created Dec 2013
                 * @blame v-shagma
                 * @blame sosobov
                 */
                function AppSharingModality(options) {
                    //#region Locals
                    var self = Model(), ucwa = options.ucwa, invitation = options.invitation, rConversation = options.rConversation, // rel=conversation resource
                    participants = options.participants, state = Property({
                        value: invitation ? Internal.Modality.State.Notified :
                            Internal.Modality.State.Created
                    }), threadId = options.threadId, mediaPlugin = options.mediaPlugin, sharedResources = options.sharedResources, mediaConfig, // MediaConfig  - a wrapper around "MediaPlatformConfig" plugin component
                    appSharing, // MediaPlugin wrapper around PluginComponent of type "AppShareCore"
                    pcASUI, // PluginComponent of type "AppShareViewerUI"
                    shareable, // local reference to shareable object (used by start(...))
                    dfdAccept, // a task returned by the accept method
                    dfdStart, // a task returned by the start method
                    to, // SIP URI of the remote party
                    asSession, // applicationSharingSession UCWA resource
                    asRenegotiation, // applicationSharingRenegotiation UCWA resource
                    asInvitation = options.resource, // applicationSharingInvitation UCWA resource
                    outAsRenegoOpIds = {}, // list of outgoing applicationSharingRenegotiation operationId values
                    container, // container object for viewing  shared content
                    wHandle; // handle to App sharing viewer
                    options = null;
                    //#endregion
                    var shared = Property({
                        value: null,
                        get: function () {
                            return shareable;
                        },
                        set: function (val) {
                            return changeShared(val).then(function () {
                                return val;
                            });
                        }
                    });
                    //#region Initialization
                    extend(self, {
                        state: state.asReadOnly(),
                        shared: shared
                    });
                    if (invitation)
                        self.from = invitation.from;
                    state.changed(function (newState, reason, oldState) {
                        log('AppSharingModality::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                    });
                    ucwa.event(onServerEvent);
                    //#endregion
                    //#region defineAsyncCommand
                    function defineAsyncCommand(name, states, method) {
                        var enabled = Property();
                        state.changed(function (value) {
                            enabled(indexOf(states, value) >= 0);
                        });
                        self[name] = Command(async(method), enabled);
                    }
                    //#endregion
                    //#region onServerEvent
                    function onServerEvent(event) {
                        var id = event.target.rel + ' ' + event.type;
                        var handler = ucwaEventHandlers[id];
                        if (handler) {
                            // debugger; // this is to let debug the handler of the event
                            handler(event.status, event.resource, event);
                        }
                    }
                    var ucwaEventHandlers = {
                        'applicationSharingInvitation started': function (status, resource) {
                            // @todo: "POST startApplicationSharing" returns a URL of the applicationSharingInvitation resource
                            if (resource.properties.direction == 'Outgoing' &&
                                resource.properties.threadId == threadId) {
                                // assert(!asInvitation);
                                asInvitation = resource;
                                dfdStart.status('awaiting "applicationSharingNegotiation started" event from UCWA');
                            }
                        },
                        'applicationSharingNegotiation started': function (status, resource) {
                            var sdp, remoteEndpoint;
                            if (resource.relatedHref('applicationSharingInvitation') == asInvitation.href) {
                                sdp = DataUri(resource.relatedHref('mediaProvisionalAnswer')).data;
                                remoteEndpoint = resource.get('remoteEndpoint');
                                appSharing.setProvisionalAnswer(true, true, remoteEndpoint, sdp);
                                dfdStart.status('awaiting "applicationSharingNegotiation completed" event from UCWA');
                            }
                        },
                        'applicationSharingNegotiation completed': function (status, resource, event) {
                            if (event.sender.href == asInvitation.href) {
                                switch (status) {
                                    case 'Success':
                                        setFinalAnswer(resource, resource.get('remoteEndpoint'));
                                        dfdStart.status('awaiting "applicationSharingInvitation completed" event from UCWA');
                                        break;
                                    case 'Failure':
                                        dfdStart.status(event.reason && event.reason.message);
                                        break;
                                }
                            }
                        },
                        'applicationSharingSession added': function (status, resource) {
                            if (asInvitation.relatedHref('conversation') == resource.relatedHref('conversation'))
                                asSession = resource;
                        },
                        // handle { type:"completed", status:"Failure", reason:{...}, target:{rel:"applicationSharingInvitation"} }
                        // it may arrive before the "applicationSharingInvitation started" event, which this code does not expect
                        'applicationSharingInvitation completed': function (status, resource) {
                            if (asInvitation && asInvitation.href == resource.href) {
                                if (asInvitation.get('direction', '') == 'Outgoing') {
                                }
                                else if (asInvitation.get('direction', '') == 'Incoming') {
                                    if (status == 'Success') {
                                        try {
                                            // an "applicationSharingRenegotiation started" event may arrive later
                                            completeNegotiation(status);
                                            dfdAccept.resolve();
                                            state(Internal.Modality.State.Connected);
                                        }
                                        catch (error) {
                                            dfdAccept.reject(error);
                                            state(Internal.Modality.State.Disconnected, error);
                                        }
                                    }
                                }
                            }
                        },
                        'applicationSharingRenegotiation started': function (status, resource) {
                            // LWA uses the empty string as the Content-ID for the SDP in the case of renegotiation
                            var sdp, id = '';
                            if (resource.properties.direction == 'Incoming' &&
                                resource.relatedHref('conversation') == asInvitation.relatedHref('conversation')) {
                                sdp = DataUri(resource.relatedHref('mediaOffer')).data;
                                log('Incoming SDP offer:\n' + sdp);
                                Task.wait(null).then(function () {
                                    if (state() === 'Connected' && shareable)
                                        return changeShared(null);
                                }).then(function () {
                                    appSharing.setOffer(false, 1, sdp, id);
                                });
                                // now expect one more ANSWER_READY event from the plugin
                                asRenegotiation = resource;
                            }
                        },
                        'applicationSharingRenegotiation completed': function (status, resource) {
                            if (resource.relatedHref('conversation') == asInvitation.relatedHref('conversation')) {
                                if (resource.get('direction') == 'Outgoing')
                                    setFinalAnswer(resource, asSession.get('remoteEndpoint'));
                                completeNegotiation(status);
                            }
                        },
                        'applicationSharing updated': function (status, resource) {
                            if (asInvitation && resource.href == asInvitation.relatedHref('applicationSharing') &&
                                resource.get('state') == 'Disconnected') {
                                if (resource.hasLink('applicationSharer')) {
                                    asSession = null;
                                    changeShared(null);
                                }
                                else {
                                    cleanup();
                                    state(Internal.Modality.State.Disconnected);
                                }
                            }
                        },
                        'conversation updated': function (status, resource) {
                            if (asInvitation && resource.href == asInvitation.relatedHref('conversation') &&
                                (resource.get('state') == 'Connected' || resource.get('state') == 'Conferenced')) {
                                var appSharing = indexOf(resource.get('activeModalities'), 'ApplicationSharing') >= 0;
                                if (appSharing) {
                                }
                            }
                        }
                    };
                    //#endregion
                    //#region onPluginComponentEvent
                    function onPluginComponentEvent(event) {
                        log('pcAS.event %c ' + event.type, 'color:blue', event.args);
                        var handler = pluginEventHandlers[event.type];
                        if (handler) {
                            // debugger; // this is to let debug the handler of the event
                            handler.apply(null, event.args !== "" ? event.args : null);
                        }
                    }
                    var pluginEventHandlers = {
                        'OFFER_READY': function (hasOffer, diagCode, sdpCount) {
                            var i, offers = [];
                            try {
                                for (i = 0; i < sdpCount; i++) {
                                    offers.push({
                                        sdp: arguments[3 + i * 2],
                                        id: arguments[3 + i * 2 + 1]
                                    });
                                }
                                if (offers.length == 0)
                                    throw Exception('NoSdpOffers', { diagCode: diagCode });
                                if (asSession) {
                                    // expect an "applicationSharingRenegotiation completed" event from UCWA
                                    sendRenegotiationOffer(offers[0].sdp);
                                }
                                else {
                                    // expect an "applicationSharingInvitation started" event from UCWA
                                    sendOffer(offers).then(function () {
                                        dfdStart.resolve();
                                        state(Internal.Modality.State.Connected);
                                    }, function (error) {
                                        dfdStart.reject(error);
                                        state(Internal.Modality.State.Disconnected, error);
                                        cleanup();
                                    }, dfdStart.status);
                                }
                            }
                            catch (error) {
                                if (dfdStart)
                                    dfdStart.reject(error);
                            }
                        },
                        'ANSWER_READY': function (_arg0, sdp) {
                            if (asRenegotiation) {
                                // expect an "applicationSharingRenegotiation completed" after this call
                                ucwa.send('POST', asRenegotiation.link('answer').href, {
                                    headers: { 'Content-Type': 'application/sdp' },
                                    data: sdp,
                                    nobatch: true
                                });
                            }
                            else {
                                dfdAccept.status('sending answer to UCWA');
                                // expect an "applicationSharingRenegotiation started" after this call
                                invitation.acceptWithAnswer(sdp).then(function () {
                                    dfdAccept.status('awaiting a "applicationSharingInvitation completed" event from UCWA');
                                }, function (error) {
                                    state(Internal.Modality.State.Disconnected, error);
                                    dfdAccept.reject(error);
                                }, dfdAccept.status);
                            }
                        },
                        'StopSharing': function () {
                            self.stop();
                        }
                    };
                    //#endregion
                    //#region initMedia
                    function initMedia() {
                        return mediaConfig ?
                            Task.wait(mediaConfig) :
                            mediaPlugin.getMediaConfig() // otherwise load it and return when it becomes available
                                .then(function (mc) {
                                mediaConfig = mc;
                                return mediaConfig;
                            });
                    }
                    //#endregion
                    //#region setupAppShareViewerUI
                    function setupAppShareViewerUI() {
                        assert(!pcASUI);
                        pcASUI = mediaPlugin.createComponent({
                            type: 'AppShareViewerUI',
                            hide: false
                        });
                        pcASUI.setContainer(container);
                        pcASUI.event(onViewerEvent, 'async');
                        return pcASUI.load();
                    }
                    //#endregion
                    //#region prepareAppSharing
                    // Based on supplied role (MediaEnum.AppSharingRole) this function will configure the
                    // needed plugins (AppShareCore/AppShareViewerUI) to allow sharing or viewing content.
                    function prepareAppSharing(role) {
                        function reinitSharing() {
                            return sharedResources.init().then(mediaPlugin.getAppSharing).then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                            });
                        }
                        function setupSharer() {
                            return Task.wait(null).then(function () {
                                sharedResources.windows.each(function (item) {
                                    sharedResources.setShared(item.id(), false);
                                });
                                sharedResources.monitors.each(function (item) {
                                    sharedResources.setShared(item.id(), false);
                                    item.selected(false);
                                });
                                sharedResources.setShared(shareable.id(), true);
                                appSharing.setCallConfig();
                                appSharing.setMediaConfig(3 /* BOTH */, 2 /* Sharer */);
                            });
                        }
                        function setupViewer() {
                            return Task.wait(null).then(function () {
                                if (!pcASUI)
                                    return setupAppShareViewerUI();
                            }).then(function () {
                                pcASUI.invoke('CreateAppShareViewerUI');
                                var result = pcASUI.invoke('GetViewerWindow');
                                if (result.length === 2 && result[1])
                                    wHandle = result[1];
                                appSharing.setCallConfig();
                                appSharing.initializeViewer(wHandle);
                                appSharing.connectViewer('connectString');
                                appSharing.setSmartSizingViewer(true);
                                appSharing.setViewerWindowSize(container.offsetWidth, container.offsetHeight);
                                if (isConferencing()) {
                                    appSharing.setMediaConfig(3 /* BOTH */, 1 /* Viewer */);
                                }
                                else {
                                    appSharing.createViewerStream();
                                }
                            });
                        }
                        if (role === 2 /* Sharer */) {
                            if (appSharing) {
                                return setupSharer();
                            }
                            else {
                                return reinitSharing().then(setupSharer);
                            }
                        }
                        else {
                            return Task.wait(null).then(function () {
                                if (appSharing) {
                                    return setupViewer();
                                }
                                else {
                                    return reinitSharing().then(setupViewer);
                                }
                            });
                        }
                    }
                    //#endregion
                    //#region onViewerEvent
                    function onViewerEvent(event) {
                        log('pcASUI.event %c ' + event.type, 'color:blue', event.args);
                        if (event.type == 'SIZE_CHANGED' && appSharing)
                            appSharing.setViewerWindowSize(event.args[0], event.args[1]);
                    }
                    //#endregion
                    //#region isConferencing
                    function isConferencing() {
                        return rConversation && (rConversation.get('state', '') == 'Conferenced' || rConversation.get('state', '') == 'Conferencing');
                    }
                    //#endregion
                    //#region start
                    /**
                     * Starts an outgoing app-sharing call. Under the hood it does the following:
                     *
                     *      - Get an AppSharingComponent from the media plugin.
                     *      - Attaches an event handle for plugin events.
                     *      - Marks all currently shared resources as not shared and shares the new resource.
                     *      - Invokes AppSharingComponent::SetCallConfig.
                     *      - Invokes AppSharingComponent::SetMediaConfig.
                     *      - Gets an OFFER_READY event from the AppSharingComponent.
                     *      - Sends a POST request to startApplicationSharing link with the SDP offer.
                     *      - Gets an "applicationSharingInvitation started" event from UCWA.
                     *      - Gets an "applicationSharingNegotiation started" event from UCWA with a provisional SDP answer.
                     *      - Invokes AppSharingComponent::SetProvisionalAnswer.
                     *      - Gets an "applicationSharingSession added" event.
                     *      - Gets an "applicationSharingNegotiation completed" event with a final SDP answer.
                     *      - Invokes AppSharingComponent::SetFinalAnswer.
                     *      - Gets a "applicationSharingInvitation completed" event from UCWA.
                     *      - Invokes AppSharingComponent::CompleteNegotiation.
                     *      - Gets a "applicationSharingRenegotiation started" event from UCWA.
                     *      - Gets a OFFER_READY event from AppSharingComponent with a new SDP answer.
                     *      - Sends a POST request to applicationSharingSession/renegotiations link.
                     *      - Gets a "applicationSharingRenegotiation completed" event from UCWA with a new SDP answer.
                     *      - Invokes AppSharingComponent::SetFinalAnswer.
                     *      - Invokes AppSharingComponent::CompleteNegotiation.
                     *
                     * @param {String} to - SIP URI of the remote participant.
                     * @param {ShareableWindow} window - Window resource to be shared
                     * @param {ShareableMonitor} monitor - Monitor resource to be shared
                     *
                     * @returns {Promise}
                     *
                     *      This promise gets resolved after the client receives an "applicationSharingInvitation completed" event.
                     *      The "status" property of the promise lets track the progress of the operation.
                     *      Since the promise gets resolved before the renegotiation starts, the progress
                     *      of the renegotiation cannot be monitored with it.
                     */
                    defineAsyncCommand('start', [Internal.Modality.State.Created], function (options) {
                        state(Internal.Modality.State.Connecting);
                        options = options || {};
                        container = options.container;
                        if (!isConferencing()) {
                            to = to || options.to;
                            if (!to) {
                                // find some remote participant
                                participants.each(function (p) {
                                    if (!p.local())
                                        to = p.uri();
                                });
                            }
                            check(to, 'the remote participant URI is not specified');
                        }
                        shareable = options.window || options.monitor;
                        return initMedia().then(function () {
                            return mediaPlugin.getAppSharing().then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                                prepareAppSharing(shareable ? 2 /* Sharer */ : 1 /* Viewer */);
                                // expect an OFFER_READY event from the media plugin
                                assert(!dfdStart);
                                dfdStart = new Task('awaiting an OFFER_READY event from the media plugin');
                                return dfdStart.promise;
                            }).then(null, function (error) {
                                if (asInvitation && asInvitation.hasLink('cancel') &&
                                    (asInvitation.get('state', '') == 'Connecting' || asInvitation.get('state', '') == 'Alerting'))
                                    ucwa.send('POST', asInvitation.link('cancel').href, { nobatch: true });
                                state(Internal.Modality.State.Disconnected, error);
                                throw error;
                            });
                        });
                    });
                    //#endregion
                    //#region cleanup
                    function cleanup() {
                        ucwa.event.off(onServerEvent);
                        if (appSharing) {
                            appSharing.event.off(onPluginComponentEvent);
                            if (shareable)
                                sharedResources.setShared(shareable.id(), false);
                            appSharing.disposeSharer();
                            // TODO: See if this makes the most sense for cleanup of old plugin / loading of new...
                            sharedResources.uninit();
                        }
                        if (pcASUI) {
                            appSharing.disposeViewer();
                            pcASUI.event.off(onViewerEvent);
                            pcASUI.unload();
                        }
                        pcASUI = null;
                        mediaPlugin.uninitAppSharing().then(function () {
                            appSharing = null;
                            return sharedResources.init();
                        });
                    }
                    //#endregion
                    //#region stop
                    defineAsyncCommand('stop', [Internal.Modality.State.Connected], function () {
                        cleanup();
                        return ucwa.send('GET', asInvitation.link('applicationSharing').href).then(function (rAS) {
                            return ucwa.send('POST', rAS.link('stopScreenSharing').href);
                        }).then(function () {
                            state(Internal.Modality.State.Disconnected);
                            asInvitation = null;
                            asSession = null;
                        });
                    });
                    //#endregion
                    //#region accept
                    /**
                     * Accepts an incoming app-sharing invitation.
                     *
                     * If the AS modality was created to handle a applicationSharingInvitation event,
                     * the accept method will configure the media plugin and connect it with
                     * the remote party via UCWA.
                     *
                     * Under the hood the accept method does the following:
                     *
                     *      - Get an AppSharingComponent from the media plugin.
                     *      - Attaches an event handle for plugin events.
                     *      - Create an AppSharingViewerComponent with the media plugin.
                     *      - Invokes AppSharingViewerComponent::CreateAppShareViewerUI.
                     *      - Invokes AppSharingViewerComponent::GetViewerWindow.
                     *      - Invokes AppSharingComponent::SetCallConfig.
                     *      - Invokes AppSharingComponent::InitializeViewer.
                     *      - Invokes AppSharingComponent::ConnectViewer.
                     *      - Invokes AppSharingComponent::SetOffer with the SDPs received from the remote party.
                     *      - Invokes AppSharingComponent::PublishFullScreenState.
                     *      - Handles the ANSWER_READY event from the media plugin: the event contains an SDP.
                     *      - Sends a POST applicationSharingInvitation/acceptWithAnswer with the SDP from the media plugin.
                     *      - Receives an "applicationSharinginvitation completed" event from UCWA
                     *      - Receives an "applicationSharingRenegotiation started" event with a new SDP from the remote party.
                     *      - Invokes AppSharingComponent::SetOffer with the new SDP given in the renegotiation event.
                     *      - Handles another ANSWER_READY event from the media plugin with an SDP answer.
                     *      - Sends a POST applicationSharingRenegotiation/answer with the SDP answer.
                     *      - Receives a "applicationSharingRenegotiation completed" event from UCWA.
                     *      - Invokes AppSharingComponent::CompleteNegotiation
                     *
                     * @returns {Promise}
                     *
                     *      This promise gets resolved after the POST request to applicationSharingInvitation/acceptWithAnswer
                     *      succeeds. The renegotiation is considered to be optional and its progress is not tracked
                     *      by the promise returned from the accept method.
                     */
                    defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (options) {
                        assert(options && options.container);
                        state(Internal.Modality.State.Connecting);
                        container = options.container;
                        return initMedia().then(function () {
                            return mediaPlugin.getAppSharing().then(function (as) {
                                appSharing = as;
                                appSharing.event(onPluginComponentEvent, 'async');
                                return prepareAppSharing(1 /* Viewer */).then(function () {
                                    // expect the ANSWER_READY event from the plugin after this call
                                    setOffer(invitation.offers);
                                });
                            });
                        }).then(function () {
                            assert(!dfdAccept);
                            dfdAccept = new Task();
                            dfdAccept.status('awaiting an ANSWER_READY event from the media plugin');
                            return dfdAccept.promise;
                        }).then(null, function (error) {
                            state(Internal.Modality.State.Disconnected, error);
                            cleanup();
                            throw error;
                        });
                    });
                    //#endregion
                    //#region changeShared
                    /**
                     * Changes the shared content and/or presentation role in the conversation.  Presentation roles can switch
                     * depending on what is currently active in the conversation and if the optional shareable resource was
                     * provided.
                     *
                     * @param {ShareableWindow|ShareableMonitor} resource - resource to be shared (not required)
                     *
                     * @returns {Promise}
                     */
                    function changeShared(resource) {
                        check.state(state(), Internal.Modality.State.Connected);
                        function sharing() {
                            if (!isConferencing()) {
                                appSharing.setCallConfig();
                                appSharing.setMediaConfig(3 /* BOTH */, 2 /* Sharer */);
                            }
                            appSharing.disposeViewer();
                            pcASUI.event.off(onViewerEvent);
                            pcASUI.unload();
                            pcASUI = null;
                            if (isConferencing()) {
                                return mediaPlugin.uninitAppSharing().then(function () {
                                    appSharing = null;
                                    sharedResources.uninit();
                                }).then(function () {
                                    shareable = resource;
                                    return prepareAppSharing(2 /* Sharer */);
                                });
                            }
                            else {
                                sharedResources.setShared(resource.id(), true);
                                shareable = resource;
                            }
                        }
                        function viewing() {
                            appSharing.disposeSharer();
                            return mediaPlugin.uninitAppSharing().then(function () {
                                appSharing = null;
                                sharedResources.uninit();
                            }).then(function () {
                                return prepareAppSharing(1 /* Viewer */);
                            });
                        }
                        if (shareable) {
                            sharedResources.setShared(shareable.id(), false);
                        }
                        if (pcASUI) {
                            return sharing();
                        }
                        else if (resource) {
                            sharedResources.setShared(resource.id(), true);
                            shareable = resource;
                        }
                        else {
                            return viewing();
                        }
                    }
                    //#endregion
                    //#region decline
                    defineAsyncCommand('decline', [Internal.Modality.State.Notified], function () {
                        return invitation.decline().then(function () {
                            state(Internal.Modality.State.Disconnected);
                        });
                    });
                    //#endregion
                    //#region setOffer
                    /**
                     * Invokes appSharing.setOffer(...) with the given set of SDPs,
                     * e.g. pcAS.invoke("SetOffer", false, 2, sdp1, id1, sdp2, id2).
                     *
                     * @param {Object[]} offers
                     * @returns Whatever pcAS returns.
                     */
                    function setOffer(offers) {
                        assert(offers.length >= 0);
                        var i, offer, args = [false, offers.length];
                        for (i = 0; i < offers.length; i++) {
                            offer = offers[i];
                            assert('sdp' in offer);
                            assert('id' in offer);
                            args.push(offer.sdp);
                            args.push(offer.id);
                        }
                        appSharing.setOffer.apply(appSharing, args);
                    }
                    //#endregion
                    //#region setFinalAnswer
                    /**
                     * Sets the final SDP answer from the remote party
                     */
                    function setFinalAnswer(resource, remoteEndpoint) {
                        var mediaAnswer = resource.relatedHref('mediaAnswer'), sdp = DataUri(mediaAnswer).data;
                        log('Final answer from the remote party:\n' + sdp);
                        appSharing.setFinalAnswer(remoteEndpoint, sdp);
                    }
                    //#endregion
                    //#region completeNegotiation
                    function completeNegotiation(eventStatus) {
                        // TODO: this is entirely my fantasy - figure out what are other values
                        // that ucwa can return here
                        var statusCode = (eventStatus == 'Success') ?
                            Internal.MediaEnum.NegotiationStatus.NS_SUCCESS :
                            Internal.MediaEnum.NegotiationStatus.NS_LOCAL_INTERNAL_ERROR;
                        appSharing.completeNegotiation(statusCode);
                    }
                    //#endregion
                    //#region getStartScreenSharingUri
                    /**
                     * The first SDP offer is sent to a URI given by this function.
                     */
                    function getStartScreenSharingUri() {
                        // if the AS modality is the 1-st modality in the conversation,
                        // send a request to the global startScreenSharing link
                        if (!rConversation)
                            return { rel: 'startScreenSharing' };
                        // if the AS modality gets added to an existing conversation,
                        // send the request to its addScreenSharing link
                        var link = rConversation.link('applicationSharing');
                        return ucwa.send('GET', link.href).then(function (rAS) {
                            return rAS.link('addScreenSharing').href;
                        });
                    }
                    //#endregion
                    //#region sendOffer
                    /**
                     * Composes an SDP offer from the OFFER_READY media plugin event data and
                     * sends it to the server to start an AS session.
                     */
                    function sendOffer(offers) {
                        assert(offers.length > 0);
                        // for now it takes only one SDP offer from all offers given by the media plugin
                        var mediaOffer = 'data:application/sdp;charset=utf-8,' +
                            DataUri.encodeData(offers[0].sdp);
                        return async(getStartScreenSharingUri).call(null).then(function (uri) {
                            var dfdPost, dfdCompleted, operationId = guid(), data;
                            if (isConferencing()) {
                                data = {
                                    operationId: operationId,
                                    threadId: threadId,
                                    mediaOffer: mediaOffer
                                };
                            }
                            else {
                                data = {
                                    to: to,
                                    operationId: operationId,
                                    sessionContext: guid(),
                                    threadId: threadId,
                                    mediaOffer: mediaOffer
                                };
                            }
                            dfdPost = ucwa.send('POST', uri, {
                                data: data
                            }).then(function (r) {
                                asInvitation = r;
                            });
                            // wait for the "applicationSharingInvitation completed" event that corresponds to the given conversation
                            dfdCompleted = ucwa.wait({
                                type: 'completed',
                                target: { rel: 'applicationSharingInvitation' },
                                resource: function (r) {
                                    return r.get('direction') == 'Outgoing' && (r.get('threadId') == threadId || r.get('operationId') == operationId);
                                }
                            }).then(function (event) {
                                if (event.status == 'Failure')
                                    throw Internal.EInvitationFailed(event.reason);
                                completeNegotiation(event.status);
                            });
                            return Task.waitAll([dfdPost, dfdCompleted]);
                        });
                    }
                    //#endregion
                    //#region sendRenegotiationOffer
                    /**
                     * Composes an SDP offer from the OFFER_READY media plugin event data and
                     * sends it to the server to renegotiate the AV session.
                     */
                    function sendRenegotiationOffer(sdp) {
                        var url = asSession.relatedHref('renegotiations');
                        assert(url, '"renegotiations" link is missing');
                        // cache operation id
                        var operationId = guid();
                        outAsRenegoOpIds[operationId] = "";
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { operationId: operationId },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    //#endregion
                    return self;
                }
                Internal.AppSharingModality = AppSharingModality;
            })(Internal = Model_2.Internal || (Model_2.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_3) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var ConstProperty = Web.Utils.ConstProperty;
                var Model = Web.Utils.Model;
                /**
                 * Encapsulates logic for a shareable window
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {JSON} resource
                 * @param {Property} shared
                 *
                 * @property {Number} id - read only
                 * @property {String} title - read only
                 * @property {Boolean} shared - Gets the shared state of the resource
                 *
                 * @method {String} preview - returns the data URL of the image
                 *
                 * @created Jan 2014
                 * @blame v-shagma
                 */
                function ShareableWindow(_a) {
                    var mediaPlugin = _a.mediaPlugin, resource = _a.resource, shared = _a.shared;
                    resource.filter = 2 /* ApplicationFilter */;
                    function preview(dimensions) {
                        return mediaPlugin.getAppSharing().then(function (as) {
                            return as.getResourcePreview(resource, dimensions);
                        });
                    }
                    return Model({
                        id: ConstProperty(resource.id),
                        title: ConstProperty(resource.name),
                        shared: shared,
                        preview: async(preview)
                    });
                }
                Internal.ShareableWindow = ShareableWindow;
            })(Internal = Model_3.Internal || (Model_3.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_4) {
            var Internal;
            (function (Internal) {
                'use strict';
                var ConstProperty = Web.Utils.ConstProperty;
                var Property = Web.Utils.Property;
                var Model = Web.Utils.Model;
                /**
                 * Encapsulates logic for a shareable monitor
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {JSON} resource
                 * @param {Property} shared
                 *
                 * @property {Number} id - read only
                 * @property {String} title - read only
                 * @property {Boolean} shared - Gets the shared state of the resource
                 * @property {Boolean} selected - Draws/Removes tracking chrome based on selection
                 *
                 * @created Jan 2014
                 * @blame v-shagma
                 */
                function ShareableMonitor(_a) {
                    var mediaPlugin = _a.mediaPlugin, resource = _a.resource, shared = _a.shared;
                    if (resource.id !== -1)
                        resource.name = 'Monitor #' + resource.id;
                    else
                        resource.name = 'Desktop Sharing';
                    resource.filter = 1 /* DesktopFilter */;
                    // draws or removes tracking chrome based on selection state
                    var selected = Property({
                        value: false,
                        set: function (val) {
                            return mediaPlugin.getAppSharing().then(function (as) {
                                if (val)
                                    as.drawTrackingChrome(resource.id);
                                else
                                    as.removeTrackingChrome(resource.id);
                                return val;
                            });
                        }
                    });
                    return Model({
                        id: ConstProperty(resource.id),
                        title: ConstProperty(resource.name),
                        shared: shared,
                        selected: selected
                    });
                }
                Internal.ShareableMonitor = ShareableMonitor;
            })(Internal = Model_4.Internal || (Model_4.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_5) {
            var Internal;
            (function (Internal) {
                'use strict';
                var assert = Web.Utils.assert;
                var async = Web.Utils.async;
                var foreach = Web.Utils.foreach;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var Model = Web.Utils.Model;
                var UserAgent = Web.Media.UserAgent;
                /**
                 * Encapsulates AppSharing component to be shared across Models
                 *
                 * @collection {ShareableWindow} windows - available shareable windows
                 * @collection {ShareableMonitor} monitors - available shareable monitors
                 *
                 * @method {Promise} init - initializes/loads shareable resources
                 * @method uninit
                 * @method setShared(id, value) - Sets the shared state value of a resource based on supplied id
                 *
                 * @created Jan 2014
                 * @blame v-shagma
                 */
                function SharedResources(mediaPlugin) {
                    var appSharing, dfdInit, // `init` returns this promise
                    windows = Collection({ get: init, subscribed: init }), monitors = Collection({ get: init, subscribed: init }), sharedProperties = {};
                    /**
                     * Note, that `init` may be called multiple times: the first call
                     * must start initializing the AS component, while subsequent calls
                     * must await the first call. This is achieved by keeping the promise
                     * returned by the first call in a variable `dfdInit` and returning
                     * this `dfdInit` from subsequent calls.
                     */
                    function init() {
                        return dfdInit ? dfdInit : dfdInit = mediaPlugin.initMedia().then(function () {
                            return mediaPlugin.getAppSharing();
                        }).then(function (as) {
                            assert(!appSharing);
                            appSharing = as;
                            appSharing.event(onPluginComponentEvent, 'async');
                            // Skip resource discovery for Mac for now
                            if (!UserAgent().isMac()) {
                                var windowItems = [], monitorItems = [], resources = appSharing.getShareableResources();
                                foreach(resources, function (item) {
                                    if (item.type === 1) {
                                        monitorItems.push(item);
                                    }
                                    else if (item.type === 3) {
                                        windowItems.push(item);
                                    }
                                });
                                updateItems(windowItems, windows);
                                updateItems(monitorItems, monitors);
                            }
                            handleDesktopSharing();
                        });
                    }
                    function uninit() {
                        if (appSharing)
                            appSharing.event.off(onPluginComponentEvent);
                        appSharing = null;
                        dfdInit = null;
                    }
                    /**
                     * Listen for 'ResourceUpdate' component events to determine when resources are added/removed
                     */
                    function onPluginComponentEvent(event) {
                        if (event.type == 'ResourceUpdated') {
                            var action = event.args.splice(7, 1)[0], type = event.args[0], item, resource = {
                                type: event.args[0],
                                id: event.args[1],
                                appId: event.args[2],
                                name: event.args[3],
                                isShared: event.args[4],
                                flags: event.args[5],
                                isResourceAsIsShareable: event.args[6],
                                fIsImmersiveModeApp: event.args[7]
                            }, shared;
                            if (type === 1) {
                                // This is a monitor resource
                                item = GetResourceKey(resource, monitors);
                                if (action === 1) {
                                    // Add
                                    if (!item) {
                                        shared = createSharedProperty(resource);
                                        sharedProperties[resource.id] = shared;
                                        monitors.add(Internal.ShareableMonitor({
                                            resource: resource,
                                            mediaPlugin: mediaPlugin,
                                            shared: shared.asReadOnly()
                                        }));
                                    }
                                }
                                else if (action === 2) {
                                    // Delete
                                    if (item) {
                                        monitors.remove(item);
                                        delete sharedProperties[resource.id];
                                    }
                                }
                                handleDesktopSharing();
                            }
                            else if (type === 3) {
                                // This is a window resource
                                item = GetResourceKey(resource, windows);
                                if (action === 1) {
                                    // Add
                                    if (!item && resource.isResourceAsIsShareable) {
                                        shared = createSharedProperty(resource);
                                        sharedProperties[resource.id] = shared;
                                        windows.add(Internal.ShareableWindow({
                                            resource: resource,
                                            mediaPlugin: mediaPlugin,
                                            shared: shared.asReadOnly()
                                        }));
                                    }
                                }
                                else if (action === 2) {
                                    // Delete
                                    if (item) {
                                        windows.remove(item);
                                        delete sharedProperties[resource.id];
                                    }
                                }
                            }
                        }
                    }
                    /**
                     * Adds or removes option for sharing entire desktop based on number of monitors
                     */
                    function handleDesktopSharing() {
                        var desktopSharingKey, resource = {
                            type: 4,
                            id: -1,
                            appId: -1
                        }, shared;
                        monitors.each(function (item, key) {
                            if (item.title() === 'Desktop Sharing') {
                                desktopSharingKey = key;
                            }
                        });
                        if (desktopSharingKey) {
                            monitors.remove(desktopSharingKey);
                            delete sharedProperties[resource.id];
                        }
                        shared = createSharedProperty(resource);
                        sharedProperties[resource.id] = shared;
                        monitors.add(Internal.ShareableMonitor({
                            resource: resource,
                            mediaPlugin: mediaPlugin,
                            shared: shared.asReadOnly()
                        }));
                    }
                    /**
                     * Find the specific resource key for a value potentially in the collection
                     */
                    function GetResourceKey(value, collection) {
                        var resourceKey;
                        collection.each(function (item, key) {
                            if (item.id() === value.id) {
                                resourceKey = key;
                                return;
                            }
                        });
                        return resourceKey;
                    }
                    /**
                     * Add/Remove resources of a collection
                     */
                    function updateItems(resources, collection) {
                        foreach(resources, function (item) {
                            var skip = false;
                            collection.each(function (obj) {
                                if (item.id === obj.id()) {
                                    skip = true;
                                }
                            });
                            if (!skip) {
                                var shared = createSharedProperty(item);
                                sharedProperties[item.id] = shared;
                                if (item.type === 1) {
                                    collection.add(Internal.ShareableMonitor({
                                        resource: item,
                                        mediaPlugin: mediaPlugin,
                                        shared: shared.asReadOnly()
                                    }));
                                }
                                else {
                                    collection.add(Internal.ShareableWindow({
                                        resource: item,
                                        mediaPlugin: mediaPlugin,
                                        shared: shared.asReadOnly()
                                    }));
                                }
                            }
                        });
                    }
                    function createSharedProperty(resource) {
                        return Property({
                            value: false,
                            set: function (val) {
                                return mediaPlugin.getAppSharing().then(function (appSharing) {
                                    var obj = {
                                        type: resource.type,
                                        id: resource.id,
                                        appId: resource.appId,
                                        filter: resource.filter
                                    };
                                    if (val)
                                        appSharing.shareResource(obj);
                                    else
                                        appSharing.unshareResource(obj);
                                    return val;
                                });
                            }
                        });
                    }
                    function setShared(id, value) {
                        if (sharedProperties[id]) {
                            sharedProperties[id](value);
                        }
                    }
                    return Model({
                        init: async(init),
                        uninit: uninit,
                        windows: windows.asReadOnly(),
                        monitors: monitors.asReadOnly(),
                        setShared: setShared
                    });
                }
                Internal.SharedResources = SharedResources;
            })(Internal = Model_5.Internal || (Model_5.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var DataUri = Web.Utils.DataUri;
                var async = Web.Utils.async;
                var extend = Web.Utils.extend;
                var guid = Web.Utils.guid;
                var map = Web.Utils.map;
                var check = Web.Utils.check;
                var HttpHeaders = Web.Utils.HttpHeaders;
                var parseMultipartRelatedResponse = Web.Stack.parseMultipartRelatedResponse;
                /**
                 * This model represents a applicationSharingInvitation resource.
                 *
                 * @param {Resource} resource - A resource with rel=applicationSharingInvitation.
                 * @param {Function} createParticipant - Takes a rel=participant resource and creates a Participant model.
                 * @param {UCWA} ucwa
                 *
                 * @member {Participant} from
                 * @member {Object[]} offers - An array of media offers.
                 *
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @method {Promise} decline
                 * @method {Promise} acceptWithAnswer(sdp)
                 *
                 * @created Dec 2013
                 * @blame v-shagma
                 */
                function AppSharingInvitation(_a) {
                    var ucwa = _a.ucwa, resource = _a.resource, createParticipant = _a.createParticipant;
                    check.equals(resource.rel, 'applicationSharingInvitation');
                    /*  An applicationSharingInvitation resource may have the following form:
            
                        {
                            "rel": "applicationSharingInvitation",
                            "direction": "Incoming",
                            "importance": "Normal",
                            "threadId": "...",
                            "state": "Connecting",
                            "operationId": "...",
                            "telemetryId": "...",
                            "sessionContext": "...",
                            "_links": {
                                "self": ...,
                                "from": ...,
                                "cancel": ...,
                                "conversation": ...,
                                "applicationSharing": ...
                            }
                        }
                    */
                    var self = {
                        acceptWithAnswer: async(acceptWithAnswer),
                        decline: async(decline),
                        offers: getMediaOffers(),
                        from: getSender()
                    };
                    extend(self, resource.properties);
                    // if the server has not provided the sessionContext of
                    // the app sharing invitation, generate some unique value
                    self.sessionContext = self.sessionContext || guid();
                    /**
                     * Reads the "mediaOffer" link and converts it to a collection SDPs.
                     */
                    function getMediaOffers() {
                        /* The "mediaOffer" link may have the following form:
                         *
                         *  data:multipart/alternative;charset=utf-8;boundary=e47d80f2,
                         *  --e47d80f2
                         *  Content-Type:+application/sdp
                         *  Content-ID:+<9544aa8a8ac9dfe08fad74893bd1095e@contoso.com>
                         *  Content-Disposition:+session;+handling=optional;+proxy-fallback
                         *
                         *  v=0
                         *  o=-+0+0+IN+IP4+127.0.0.1
                         *  s=session
                         *  ...
                         *
                         *  --e47d80f2
                         *  Content-Type:+application/sdp
                         *  Content-ID:+<cdfd6188fd977372c577873b03dd580d@contoso.com>
                         *  Content-Disposition:+session;+handling=optional
                         *
                         *  v=0
                         *  o=-+0+1+IN+IP4+127.0.0.1
                         *  s=session
                         *  c=IN+IP4+127.0.0.1
                         *  ...
                         *
                         *  --e47d80f2
                         */
                        var href, dataUri, responses;
                        href = resource.relatedHref('mediaOffer');
                        if (!href)
                            return [];
                        dataUri = DataUri(href);
                        try {
                            responses = parseMultipartRelatedResponse({
                                status: null,
                                responseText: dataUri.data,
                                headers: 'Content-Type:multipart/related;boundary=' + dataUri.attributes.boundary
                            });
                            return map(responses, function (response) {
                                var headers = HttpHeaders(response.headers);
                                return {
                                    sdp: response.responseText,
                                    id: headers.get('Content-ID')
                                };
                            });
                        }
                        catch (error) {
                            // if the media offer is not a multipart/alternate-encoded
                            // set of SDPs, consider it as a single SDP
                            return [{
                                    sdp: dataUri.data,
                                    id: ''
                                }];
                        }
                    }
                    function getSender() {
                        var href = resource.relatedHref('from');
                        return href && createParticipant(resource.embedded[href]);
                    }
                    function acceptWithAnswer(sdp) {
                        var url = resource.link('acceptWithAnswer').href;
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { sessionContext: self.sessionContext },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    function decline() {
                        return ucwa.send('POST', resource.link('decline').href, {
                            data: { reason: 'Local' }
                        });
                    }
                    return self;
                }
                Internal.AppSharingInvitation = AppSharingInvitation;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var guid = Web.Utils.guid;
                var Exception = Web.Utils.Exception;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                /**
                 * Encapsulates AppSharing component to be shared across Models
                 *
                 * @param {MediaPlugin} mediaPlugin
                 * @param {PluginComponent} component
                 *
                 * @method {Promise} init - initializes/loads AppSharing component
                 * @method uninit - unloads AppSharing component
                 * @method setCallConfig - wraps call to component's SetCallConfig
                 * @method setMediaConfig - wraps call to component's SetMediaConfig
                 * @method initializeViewer - wraps call to component's InitializeViewer
                 * @method connectViewer - wraps call to component's ConnectViewer
                 * @method createViewerStream - wraps call to component's ConnectViewerStream
                 * @method setViewerWindowSize - wraps call to component's SIZE_CHANGED
                 * @method setSmartSizingViewer - wraps call to component's SetSmartSizingViewer
                 * @method publishFullScreenState - wraps call to component's PublishFullScreenState
                 * @method setOffer - wraps call to component's SetOffer
                 * @method setFinalAnswer - wraps call to component's SetFinalAnswer
                 * @method setProvisionalAnswer - wraps call to component's SetProvisionalAnswer
                 * @method completeNegotiation - wraps call to component's CompleteNegotiation
                 * @method {Array} getShareableResources - queries component for shareable resources (windows/monitors)
                 * @method drawTrackingChrome - draws a tracking chrome around a specified monitor
                 * @method removeTrackingChrome - removes a tracking chrome around a specified monitor
                 * @method {String} getResourcePreview - returns the data URL of the image
                 * @method shareResource - Shares a resource (window/monitor) with AppSharing component
                 * @method unshareResource - Unshares a resource (window/monitor) with AppSharing component
                 * @method disposeSharer - wraps call to component's DisposeSharer
                 * @method disposeViewer - wraps call to component's DisposeViewer
                 * @method on - attaches handler to component's events
                 * @method off - detaches handler from component's events
                 *
                 * @created Jan 2014
                 * @blame v-shagma
                 */
                function AppSharing(_a) {
                    var mediaConfig = _a.mediaConfig, pcAS = _a.component;
                    var isInitialized = false;
                    function init() {
                        return pcAS.load('', // local uri
                        '', // remote uri
                        guid(), // threadId
                        false, // isConference
                        mediaConfig.maxVideoChannelCount(), mediaConfig.applicationSharingSecurityLevel()).then(function () {
                            pcAS.invoke('InitializeSharer');
                            pcAS.setLogLevel(3);
                            isInitialized = true;
                        });
                    }
                    function uninit() {
                        if (pcAS) {
                            pcAS.unload();
                            pcAS = null;
                            isInitialized = false;
                        }
                    }
                    function checkState() {
                        if (!isInitialized)
                            throw Exception.call('Not Initialized', 'NotInitialized');
                    }
                    function setCallConfig() {
                        checkState();
                        pcAS.invoke('SetCallConfig', mediaConfig.isInternal() ?
                            Internal.MediaEnum.PreferredMediaAddressType.Direct :
                            Internal.MediaEnum.PreferredMediaAddressType.Relay);
                    }
                    function setMediaConfig(direction, type) {
                        checkState();
                        pcAS.invoke('SetMediaConfig', direction, type);
                    }
                    function initializeViewer(wHandle) {
                        checkState();
                        pcAS.invoke('InitializeViewer', wHandle);
                    }
                    function connectViewer(connectionString) {
                        checkState();
                        pcAS.invoke('ConnectViewer', connectionString);
                    }
                    function createViewerStream() {
                        checkState();
                        pcAS.invoke('CreateViewerStream', 3 /* BOTH */);
                    }
                    function setViewerWindowSize(width, height) {
                        checkState();
                        pcAS.invoke('SIZE_CHANGED', width, height);
                    }
                    function setSmartSizingViewer(val) {
                        checkState();
                        pcAS.invoke('SetSmartSizingViewer', val);
                    }
                    function publishFullScreenState(state) {
                        checkState();
                        pcAS.invoke('PublishFullScreenState', state);
                    }
                    function setOffer(isProvisionalAnsReq, count) {
                        checkState();
                        if (count < 1)
                            throw EInvalidArgument('count', 'No Offers Provided');
                        var args = ['SetOffer', isProvisionalAnsReq, count].concat([].slice.call(arguments, 2));
                        pcAS.invoke.apply(pcAS, args);
                    }
                    function setFinalAnswer(remoteEndpoint, sdp) {
                        checkState();
                        pcAS.invoke('SetFinalAnswer', remoteEndpoint, sdp);
                    }
                    function setProvisionalAnswer(isOfferForked, acceptEarlyMedia, remoteEndpoint, sdp) {
                        checkState();
                        pcAS.invoke('SetProvisionalAnswer', isOfferForked, acceptEarlyMedia, remoteEndpoint, sdp);
                    }
                    function completeNegotiation(statusCode) {
                        checkState();
                        pcAS.invoke('CompleteNegotiation', statusCode);
                    }
                    function getShareableResources() {
                        checkState();
                        var items = [], resources, count, index = 0;
                        pcAS.invoke('LockFetchResources');
                        resources = pcAS.invoke('GetResources');
                        pcAS.invoke('UnlockFetchResources');
                        if (resources) {
                            count = resources[resources.length - 1];
                            resources = resources.slice(1, -1);
                            for (var i = 0; i < count; i++) {
                                // Check if resource is shareable before adding to list and not already shared
                                if (resources[index + 4] !== 1 && (resources[index] === 1 || (resources[index] === 3 && resources[index + 6] !== 0))) {
                                    items.push({
                                        type: resources[index],
                                        id: resources[index + 1],
                                        appId: resources[index + 2],
                                        name: resources[index + 3],
                                        isShared: resources[index + 4],
                                        flags: resources[index + 5],
                                        isResourceAsIsShareable: resources[index + 6],
                                        fIsImmersiveModeApp: resources[index + 7]
                                    });
                                }
                                index += 8;
                            }
                        }
                        return items;
                    }
                    function drawTrackingChrome(id) {
                        checkState();
                        pcAS.invoke('DrawMonitorTrackingChrome', id);
                    }
                    function removeTrackingChrome(id) {
                        checkState();
                        pcAS.invoke('RemoveMonitorTrackingChrome', id);
                    }
                    function getResourcePreview(resource, dimensions) {
                        checkState();
                        var result;
                        // TODO: Consider reusing filter...
                        if (resource.type === 1) {
                        }
                        else {
                            var temp = pcAS.invoke('GetApplicationPreview', resource.appId, resource.id, dimensions.width, dimensions.height);
                            result = 'data:image/png;base64,' + temp[1];
                        }
                        return result;
                    }
                    function shareResource(resource) {
                        checkState();
                        // Probably a try/catch here...
                        // Figure out if we can move control related to another method or extend signature...
                        pcAS.invoke('SetControlAllowed', 1, true, true);
                        if (resource.id !== -1) {
                            pcAS.invoke('SetResourceFilter', resource.filter, 1);
                            pcAS.invoke('SetResourceSharedState', resource.type, resource.id, resource.appId, 1);
                        }
                        else {
                            pcAS.invoke('DisableFilters');
                        }
                        // Figure out if we should allow control over allowing sharing to stop..?
                        pcAS.invoke('CanStopSharing', true);
                    }
                    function unshareResource(resource) {
                        checkState();
                        pcAS.invoke('SetResourceSharedState', resource.type, resource.id, resource.appId, 0);
                    }
                    function disposeSharer() {
                        checkState();
                        pcAS.invoke('DisposeSharer');
                    }
                    function disposeViewer() {
                        checkState();
                        pcAS.invoke('DisposeViewerCore');
                    }
                    return {
                        init: async(init),
                        uninit: uninit,
                        setCallConfig: setCallConfig,
                        setMediaConfig: setMediaConfig,
                        initializeViewer: initializeViewer,
                        connectViewer: connectViewer,
                        createViewerStream: createViewerStream,
                        setViewerWindowSize: setViewerWindowSize,
                        setSmartSizingViewer: setSmartSizingViewer,
                        publishFullScreenState: publishFullScreenState,
                        setOffer: setOffer,
                        setFinalAnswer: setFinalAnswer,
                        setProvisionalAnswer: setProvisionalAnswer,
                        completeNegotiation: completeNegotiation,
                        getShareableResources: getShareableResources,
                        drawTrackingChrome: drawTrackingChrome,
                        removeTrackingChrome: removeTrackingChrome,
                        getResourcePreview: getResourcePreview,
                        shareResource: shareResource,
                        unshareResource: unshareResource,
                        disposeSharer: disposeSharer,
                        disposeViewer: disposeViewer,
                        event: pcAS.event
                    };
                }
                Internal.AppSharing = AppSharing;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var guid = Web.Utils.guid;
                var check = Web.Utils.check;
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var values = Web.Utils.values;
                var filter = Web.Utils.filter;
                var foreach = Web.Utils.foreach;
                var contains = Web.Utils.contains;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var currentUTCms = Web.Utils.currentUTCms;
                var Task = Web.Utils.Task;
                var Event = Web.Utils.Event;
                var Symbol = Web.Utils.Symbol;
                var DataUri = Web.Utils.DataUri;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var EDoesNotExist = Web.Utils.EDoesNotExist;
                var EInvalidState = Web.Utils.EInvalidState;
                var ENotSupported = Web.Utils.ENotSupported;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var log = Web.Media.log;
                var PluginComponent = Web.Media.PluginComponent;
                /** denotes escalation as a reason for internal property change */
                Internal.sEscalation = Symbol('escalation');
                /**
                 * Created by AudioVideoModality to represent an AudioVideo session (call). Can be either
                 * peer-to-peer or multi-party (conference). Only one such session exists when the call is
                 * established. When a P2P conversation is escalated to a conference, a second session
                 * linking this client to the conference is created. Once escalation succeeds, the second
                 * session replaces the original P2P session.
                 *
                 * @created Apr 2014 - refactored out of old AudioVideoModality; added MPOP and escalation support.
                 * @blame sosobov
                 */
                var AudioVideoSession = (function () {
                    //#endregion
                    function AudioVideoSession(options) {
                        var changed = new Event(), escalated = new Event(), self = {}, pcAV, mediaConfig, mediaPlugin = options.mediaPlugin, devices = options.devices, ucwa = options.ucwa, invitationContext = options.context, participants = options.participants, selfParticipant = options.selfParticipant, conversation = options.conversation, rConversation = options.rConversation, rAVInvitation = options.rAVInvitation, rAVRenegotiation, 
                        // During an outgoing call the server may set up more than one audioVideoSession, because
                        // the remote sip uri that we are calling may be signed in on more than one endpoint.
                        // Therefore we may see multiple pairs of audioVideoNegotiation - audioVideoSession events.
                        // Eventually, one of these sessions will be connected, others will be deleted. We keep
                        // track of these sessions in a dictionary of objects indexed by audioVideoSession hrefs,
                        // where these session objects may have properties:
                        //    resource:  audioVideoSession resource;
                        //    negotiated:  boolean (true if this session was successfully negotiated);
                        //    resumeAudioVideoUri:  present if this is an escalated conference session.
                        avSessions = {}, invitation = options.invitation, rInvitation = options.rInvitation, operationId = options.operationId || guid(), // provided by unittest or generated on the fly
                        sessionContext = options.sessionContext || guid(), // provided by unittest or generated on the fly
                        outAvRenegoOpIds = {}, // list of outgoing audioVideoRenegotiation operationId values
                        localUri = options.localUri, remoteUri, state = Property({
                            value: invitation || (rInvitation && rInvitation.rel == 'onlineMeetingInvitation') ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), 
                        // TODO: if we receive a video invitation we force the client to accept/decline on the video
                        // service. Figure out how to deal with answering with audio to a video invitation.
                        audioState = Property({
                            value: isAudioInvitation() ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), videoState = Property({
                            value: isVideoInvitation() ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), activeSourceId, recentActiveSpeakers = {}, activeModalities = { audio: false, video: false }, audioChannel, mainVideoStream = new Internal.MediaStream({
                            mediaPlugin: mediaPlugin,
                            type: Internal.MediaEnum.StreamType.MainRender
                        }), selfVideoStream = new Internal.MediaStream({
                            mediaPlugin: mediaPlugin,
                            type: Internal.MediaEnum.StreamType.Preview
                        }), 
                        // remote video streams
                        videoStreams = Collection(), dfdStart, // promise returned by the start method
                        dfdAccept, // promise returned by the accept method
                        // video config of the main media manager channel requested by either start or accept;
                        // is needed for setting the initial value of video channel's isStarted property for the
                        // self participant when start/accept is finished.
                        mainVideoConfig = 0 /* NOT_PRESENT */, 
                        // a unique id of this session - handy for debugging this session's
                        // server event subscription
                        modelId = random(), RemoteHoldState = {
                            Unknown: 0,
                            HoldOffered: 1,
                            HoldAnswered: 2,
                            HoldCompleted: 3,
                            ResumeOffered: 4,
                            ResumeAnswered: 5,
                            ResumeCompleted: 6
                        }, AudioVideoDirection = StringEnum('Inactive', // hold
                        'ReceiveOnly', 'SendOnly', 'SendReceive', // resume
                        'Unknown'), 
                        // A flag to track the renegotiation progress when a remote
                        // participant hold/resume the call in P2P mode.
                        //
                        // Steps to identify when remote participant hold/resume in P2P:
                        // 1. wait for audioVideo renegotiation offer.
                        // 2. if the offer has "a=inactive" field (for m=audio or m=video),
                        //    it is a HOLD request, mark it and expect ANSWER READY.
                        //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                        //    so mark it that way.
                        // 3. if answer has "a=inactive" field, it is a HOLD request, mark it
                        //    and expect "audioVideoRenegotiation completed".
                        //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                        //    so mark it that way.
                        // 4. when "audioVideoRenegotiation completed" event is received
                        //    with "Incoming" direction, progress the marker set in previous
                        //    steps; and expect CHANNEL_DIRECTION_CHANGED event.
                        // 5. if CHANNEL_DIRECTION_CHANGED event is received with direction
                        //    equal to NO_ACTIVE_MEDIA, and the HOLD marker was set in last
                        //    step, it completes a HOLD renegotiation, so we can set:
                        //    p.audioOnHold(true) for the remote participant.
                        // 6. if CHANNEL_DIRECTION_CHANGED event is received with direction
                        //    equal to other values (likely BOTH), and the RESUME marker was
                        //    set in last step, it completes a RESUME renegotiation, so set:
                        //    p.audioOnHold(false) for the remote participant.
                        remoteHoldState = RemoteHoldState.Unknown, escalateAudioVideoUri = options.escalateAudioVideoUri, fEscalation = isNotEmptyString(escalateAudioVideoUri), 
                        // A subscription to the devicesManager.selectedCamera changed event
                        selectedCameraChangedSubscription, reportMediaDiagnosticsUrl, publishCallQualityFeedbackUrl;
                        assert(conversation);
                        //#region mute
                        // mutes/unmutes the audio channel or returns the mute status
                        var muted = Property({
                            value: false,
                            get: function () {
                                // if this throws, the cached value won't be changed
                                check.state(pcAV.state(), PluginComponent.State.Loaded);
                                if (isConferencing())
                                    return muted();
                                var res = pcAV.invoke('GetMuteStatus', Internal.MediaEnum.MediaDeviceType.MIC, false); // isDeviceSystemProperty
                                // the output param is a flag telling us if our audio is muted or not
                                return res[1];
                            },
                            set: function (val) {
                                // if this throws, the cached value won't be changed
                                check.state(pcAV.state(), PluginComponent.State.Loaded);
                                // soft mute is applicable in conference mode
                                if (isConferencing()) {
                                    var rel = val ? 'muteAudio' : 'unmuteAudio', rAudio = selfParticipant[Internal.sInternal].rAudio;
                                    return Task.wait().then(function () {
                                        if (!rAudio.hasLink(rel))
                                            return ucwa.send('GET', rAudio.href);
                                    }).then(function () {
                                        return rAudio.link(rel).href;
                                    }).then(function (href) {
                                        return ucwa.send('POST', href);
                                    }).then(function () {
                                        return val;
                                    });
                                }
                                // hard mute is applicable to P2P mode
                                // NOTE: this would cause the other participant to receive
                                // MEDIA_CHANGED event. However, those events are not
                                // reliable triggers to update participant mute states since
                                // they can also appear when the remote participant is not
                                // on mute but there is no sound input for a while. Also
                                // confirmed with Lync Client that there is no way for one
                                // endpoint to know whether the other endpoing is on mute or
                                // not. So you will always see participant.audio.isMuted to
                                // be 'false' in P2P mode.
                                pcAV.invoke('MuteOrUnMute', Internal.MediaEnum.MediaDeviceType.MIC, val, // mute
                                false); // isDeviceSystemProperty
                                return val;
                            }
                        });
                        //#endregion mute
                        //#region onHold
                        // holds/resumes audio/video or returns the onHold status
                        var onHold = Property({
                            value: false,
                            get: function () {
                                check.state(pcAV.state(), PluginComponent.State.Loaded);
                                return onHold();
                            },
                            set: function (val) {
                                // if this throws, the cached value won't be changed
                                check.state(pcAV.state(), PluginComponent.State.Loaded);
                                if (!isConferencing() && participants.size() > 0) {
                                    // the call is on hold when the remote puts on hold; so when
                                    // the local participant requests hold, the plugin will not
                                    // renegotiate, and no need to wait for renegotiation result
                                    if (participants(0).audio.isOnHold() && !onHold())
                                        return val;
                                }
                                var audioConfig = val ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                                var moreChannels = activeModalities.video && isConferencing();
                                mainVideoConfig = activeModalities.video ?
                                    (val ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */) :
                                    0 /* NOT_PRESENT */;
                                pcAV.invoke('SetMediaConfig', audioConfig, // audio configuration
                                mainVideoConfig, // main video configuration
                                moreChannels ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                                moreChannels ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                                0 /* NOT_PRESENT */); // panoVideoConfig
                                return ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'audioVideoRenegotiation' },
                                    resource: function (r) {
                                        return r.get('direction') == 'Outgoing' && r.link('audioVideoSession').href in avSessions;
                                    }
                                }).then(function (event) {
                                    if (event.status == 'Success')
                                        return val;
                                    throw Exception('RenegotiationFailed', { reason: event.reason });
                                });
                            }
                        });
                        //#endregion onHold
                        options = null;
                        ucwa.event(onServerEvent);
                        state.changed(function (newState, reason, oldState) {
                            log('AudioVideoSession(' + modelId + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        audioState.changed(function (newState, reason, oldState) {
                            log('AudioVideoSession(' + modelId + ')::audioState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        videoState.changed(function (newState, reason, oldState) {
                            log('AudioVideoSession(' + modelId + ')::videoState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        state.when(Internal.Modality.State.Disconnected, function () {
                            audioState(Internal.Modality.State.Disconnected);
                            videoState(Internal.Modality.State.Disconnected);
                        });
                        // note that both reset* methods will be called with the "reason" parameter if the
                        // reason was set when property values were changed.
                        videoState.when(Internal.Modality.State.Disconnected, resetVideo);
                        audioState.when(Internal.Modality.State.Disconnected, resetAudio);
                        participants.removed(function (p) {
                            var id = p[Internal.sInternal].audioSourceId();
                            delete recentActiveSpeakers[id];
                            if (activeSourceId == id)
                                activeSourceId = -1;
                        });
                        setVideoRendering(selfVideoStream, true);
                        if (!isConferencing())
                            setVideoRendering(mainVideoStream, false);
                        //#region self
                        extend(self, {
                            state: state.asReadOnly(),
                            audioState: audioState.asReadOnly(),
                            videoState: videoState.asReadOnly(),
                            start: async(start),
                            stop: async(stop),
                            sendDtmf: sendDtmf,
                            changed: changed.observer,
                            escalated: escalated.observer,
                            muted: muted,
                            onHold: onHold,
                            selfVideoStream: selfVideoStream,
                            showParticipantVideo: showParticipantVideo,
                            removeParticipantVideo: removeParticipantVideo,
                            removeVideo: async(removeAllVideo)
                        });
                        if (invitation) {
                            // incoming call
                            extend(self, {
                                from: invitation.from,
                                accept: async(accept)
                            });
                        }
                        //#endregion
                        //#region private utilities
                        function initMedia() {
                            return mediaConfig ?
                                Task.wait(mediaConfig) :
                                mediaPlugin.getMediaConfig() // otherwise load it and return when it becomes available
                                    .then(function (mc) {
                                    mediaConfig = mc;
                                    return mediaConfig;
                                });
                        }
                        function isConferencing() {
                            rConversation = rConversation || getConversationResource();
                            var convState = rConversation && rConversation.get('state', '');
                            // TODO: move Conversation.State to model.common.js and use enum here
                            return convState == 'Conferencing' || convState == 'Conferenced';
                        }
                        function getConversationResource() {
                            // sHref is an internal id available in this file
                            var href = conversation && conversation[Internal.sHref];
                            return href ? ucwa.get(href) : null;
                        }
                        function getRenegotiationsHref() {
                            var renegoHref, negoSession, negotiated = filter(values(avSessions), function (session) {
                                return session.negotiated;
                            });
                            if (negotiated.length > 0) {
                                assert(negotiated.length == 1);
                                negoSession = negotiated[0];
                                renegoHref = negoSession.resumeAudioVideoUri ||
                                    negoSession.resource.link('renegotiations').href;
                                assert(renegoHref);
                            }
                            return renegoHref;
                        }
                        function setNegotiatedSession(sctx) {
                            foreach(avSessions, function (session) {
                                if (session.resource.get('sessionContext') == sctx)
                                    session.negotiated = true;
                            });
                        }
                        // switches video rendering on/off for 1:1 conversations when video starts/stops streaming 
                        // and when video container is set/changed/nulled
                        function setVideoRendering(videoStream, isPreview) {
                            videoStream._isFlowing.changed(function (val) {
                                if (val)
                                    showVideo(videoStream, isPreview);
                                else
                                    removeVideo(videoStream, isPreview);
                            });
                            videoStream.source.sink.container.changed(function (newVal, reason, oldVal) {
                                if (videoStream._isFlowing()) {
                                    if (oldVal)
                                        removeVideo(videoStream, isPreview);
                                    if (newVal)
                                        showVideo(videoStream, isPreview);
                                }
                            });
                            videoStream.source.sink.format.changed(function (v) {
                                var sink = videoStream.source.sink;
                                if (v && videoStream._id() && sink._videoWindow() && videoStream._isFlowing()) {
                                    pcAV.invoke('SetVideoDisplayOptions', isPreview ? Internal.MediaEnum.MediaDeviceType.PREVIEW : Internal.MediaEnum.MediaDeviceType.RENDER, sink._videoWindow(), sink._format(), 1 /* SmartCrop */);
                                }
                            });
                        }
                        // called when we stop 1:1 video (including escalation to a meeting)
                        function removeAllVideo() {
                            removeVideo(mainVideoStream, false);
                            removeVideo(selfVideoStream, true);
                            mainVideoStream._isFlowing(false);
                            selfVideoStream._isFlowing(false);
                            selfParticipant[Internal.sInternal].setVideoStream(null);
                            if (participants.size() > 0) {
                                participants(0)[Internal.sInternal].setVideoStream(null);
                                participants(0)[Internal.sInternal].setVideoStarted(void 0);
                            }
                        }
                        function resetVideo(reason) {
                            participants.each(function (p) {
                                // reset the participant video stream source to an empty stream
                                p[Internal.sInternal].setVideoStream(null);
                                if (!isConferencing())
                                    p[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                            });
                            mainVideoStream._isFlowing(false);
                            selfVideoStream._isFlowing(false);
                            videoStreams.empty();
                            selfParticipant[Internal.sInternal].setVideoStream(null);
                            if (reason !== Internal.sEscalation)
                                selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                        }
                        function resetAudio() {
                            if (!isConferencing() && participants(0))
                                participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                            // The audio state of self participant is replaced by AudioVideoModality::audioState 
                            // in the conversation ctor, so resetting it as we do in resetVideo is useless:
                            // if (reason !== sEscalation)
                            //    selfParticipant[sInternal].audioState(Modality.State.Disconnected);
                        }
                        function enumcastStreamState(meState) {
                            var ss = Internal.MediaEnum.StreamState, state;
                            switch (meState) {
                                case 1 /* STREAM_STARTED */:
                                    state = ss.Started;
                                    break;
                                case 2 /* STREAM_ACTIVE */:
                                    state = ss.Active;
                                    break;
                                case 3 /* STREAM_INACTIVE */:
                                    state = ss.Inactive;
                                    break;
                                case 4 /* STREAM_STOPPED */:
                                    state = ss.Stopped;
                                    break;
                            }
                            return state;
                        }
                        // Check if the SDP offer/answer contains a=inactive field,
                        // which indicates it is a renegotiation triggered when a
                        // participant holds a call.
                        function isHoldRequest(sdp) {
                            return /\ba=inactive\b/gmi.test(sdp);
                        }
                        function isAudioInvitation() {
                            return invitation && !invitation.hasVideo() ||
                                rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                    conversation.meeting.availableModalities.audio() &&
                                    !conversation.meeting.availableModalities.video();
                        }
                        function isVideoInvitation() {
                            return invitation && invitation.hasVideo() ||
                                rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                    conversation.meeting.availableModalities.video();
                        }
                        function getDiagnosticsBlob() {
                            var blob;
                            try {
                                if (pcAV)
                                    blob = pcAV.invoke('GetDiagnosticsBlob');
                                if (blob && blob[0] === 0)
                                    return blob[1];
                            }
                            catch (err) {
                                log('GetDiagnosticsBlob FAILURE', err);
                            }
                        }
                        // This POST will fail until we upgrade to v16.1 of the plugin since the 
                        // diagnostics blob format has been fixed by media libraries for that version.
                        // Until then the exception is continuable.
                        function postMediaDiagnosticsData(reason) {
                            if (!reportMediaDiagnosticsUrl)
                                return;
                            var blob = getDiagnosticsBlob();
                            if (blob) {
                                // at minimum empty data is a must, else ucwa fails input validation
                                var content = { data: {}, nobatch: true };
                                content.headers = { 'X-MS-MediaDiagnostics': blob };
                                if (reason) {
                                    if (reason.code)
                                        content.data.errorCode = reason.code;
                                    if (reason.subcode)
                                        content.data.errorSubcode = reason.subcode;
                                }
                                ucwa.send('POST', reportMediaDiagnosticsUrl, content);
                                // reset so it doesn't get sent again for this session
                                reportMediaDiagnosticsUrl = null;
                            }
                        }
                        function postCallQualityFeedback() {
                            if (!publishCallQualityFeedbackUrl)
                                return;
                            var qoe;
                            try {
                                qoe = pcAV.invoke('GetQoeXml');
                            }
                            catch (err) {
                                log('GetQoeXml FAILURE', err);
                            }
                            if (qoe && qoe[0] === 0) {
                                if (qoe.length < 3) {
                                    log('Unexpected GetQoeXml result', qoe);
                                    return;
                                }
                                ucwa.send('POST', publishCallQualityFeedbackUrl, {
                                    data: {
                                        mediaEndpoint: qoe[1],
                                        mediaQualityOfExperience: qoe[2]
                                    },
                                    nobatch: true
                                });
                                // reset so it doesn't get sent again for this session
                                publishCallQualityFeedbackUrl = null;
                            }
                        }
                        // The publishTelemetry link only appears for meeting join scenarios, not even during escalations
                        function postPublishTelemetry(avResourceWhenConnected) {
                            if (avResourceWhenConnected.hasLink('publishTelemetry')) {
                                ucwa.send('POST', avResourceWhenConnected.link('publishTelemetry').href, {
                                    nobatch: true,
                                    headers: { 'Content-Type': 'application/json' },
                                    // Search online for 'ASP.NET AJAX: Inside JSON date and time string'
                                    // By JSON rules, "\/Date(ticks)\/" is technically equivalent to "/Date(ticks)/" but 
                                    // the JavaScriptSerializer (in UCWA) will deserialize the former as a DateTime and the latter as a String.
                                    // Hence, forced to build content as a string to prevent JSON.stringify in our Endpoint from removing the '\'
                                    // Also:
                                    // endTime should be greater than startTime else UCWA will fail
                                    data: '{startTime:"\\/Date(' + currentUTCms() + ')\\/", '
                                        + 'endTime:"\\/Date(' + (currentUTCms() + 1) + ')\\/"}'
                                });
                            }
                        }
                        //#endregion
                        //#region public methods
                        //#region start
                        /**
                         * Starts an outgoing Audio/Video call
                         *
                         *  @param {String} remoteUri
                         *  @param {MediaEnum.MediaConfig} audioConfig
                         *  @param {MediaEnum.MediaConfig} mainVideoConfig
                         *  @param {Object} [video]
                         *
                         *  @returns {Promise}
                         *
                         *  Starting a P2P audio call
                         *  - Creates an AVComponent in the media plugin.
                         *  - Invokes AVComponent::SetCallConfig.
                         *  - Invokes AVComponent::SetMediaConfig.
                         *  - Gets an OFFER_READY event from the AVComponent.
                         *  - Sends a POST request to startAudioVideo link with the SDP offer.
                         *  - Gets an "audioVideoInvitation started" event from UCWA.
                         *  - Gets an "audioVideoNegotiation started" event from UCWA with a provisional SDP answer.
                         *  - Invokes AVComponent::SetProvisionalAnswer.
                         *  -  Gets an "audioVideoSession added" event.
                         *  -  Gets an "audioVideoNegotiation completed" event with a final SDP answer.
                         *  -  Invokes AVComponent::SetFinalAnswer.
                         *  -  Gets a "audioVideoInvitation completed" event from UCWA.
                         *  -  Invokes AVComponent::CompleteNegotiation.
                         *  -  Gets a "audioVideoRenegotiation started" event from UCWA.
                         *  -  Gets a OFFER_READY event from AVComponent with a new SDP answer.
                         *  -  Sends a POST request to audioVideoSession/renegotiations link.
                         *  -  Gets a "audioVideoRenegotiation completed" event from UCWA with a new SDP answer.
                         *  -  Invokes AVComponent::SetFinalAnswer.
                         *  -  Invokes AVComponent::CompleteNegotiation.
                         *
                         *  Joining an audio conference call the client follows the same sequence with one exception:
                         *  there is no initial negotiation - all "audioVideoNegotiation" events are absent.
                         *
                         *  If the client calls an invalid sip uri, it receives a single "audioVideoInvitation
                         *  completed" event with failure status and appropriate error code.
                         */
                        function start(options) {
                            // prohibit start of audio or video when that modality is already started
                            if ((options.mainVideoConfig == 3 /* BOTH */ && activeModalities.video) ||
                                (options.mainVideoConfig == 0 /* NOT_PRESENT */ &&
                                    options.audioConfig == 3 /* BOTH */ && activeModalities.audio))
                                return Task.wait('already started');
                            check.state(onHold(), false);
                            var audioConfig = options.audioConfig, previewContainer = options.video && options.video.previewContainer, videoContainer = options.video && options.video.container, startsVideo = options.mainVideoConfig != 0 /* NOT_PRESENT */;
                            mainVideoConfig = options.mainVideoConfig;
                            // start is allowed to be called twice only when the first call starts audio,
                            // and the second call adds video. So a different options.remoteUri for adding
                            // video does not make sense
                            remoteUri = remoteUri || options.remoteUri;
                            options = null;
                            check.state(state(), [
                                Internal.Modality.State.Disconnected,
                                Internal.Modality.State.Notified,
                                Internal.Modality.State.Connected
                            ]);
                            if (state() == Internal.Modality.State.Disconnected ||
                                state() == Internal.Modality.State.Notified) {
                                state(Internal.Modality.State.Connecting);
                            }
                            // to keep parity with Skype not only we need to set the local participant AV state
                            // in a 1:1 call but also to fake the remote participant AV state; and we always check
                            // for the remote participant existence because the call can be started with the
                            // empty participants collection by specifying the remote sip uri.
                            if (audioState() == Internal.Modality.State.Disconnected ||
                                audioState() == Internal.Modality.State.Notified) {
                                audioState(Internal.Modality.State.Connecting);
                                if (!isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                            }
                            if (videoState() == Internal.Modality.State.Disconnected && startsVideo ||
                                videoState() == Internal.Modality.State.Notified) {
                                videoState(Internal.Modality.State.Connecting);
                                if (!isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                            }
                            return initMedia().then(function () {
                                if (!pcAV) {
                                    pcAV = mediaPlugin.createComponent({
                                        type: 'AVComponent',
                                        hide: true
                                    });
                                    pcAV.event(onPluginComponentEvent, 'async');
                                    return pcAV.load(localUri, isConferencing() ? guid() : remoteUri, conversation.threadId(), isConferencing(), 
                                    // max num of video channels - use 1 for P2P, otherwise the media
                                    // manager will fail the call constructed by the media plugin.
                                    isConferencing() ? mediaConfig.maxVideoChannelCount() : 1, mediaConfig.audioVideoSecurityLevel());
                                }
                            }).then(function () {
                                var moreChannels = mainVideoConfig != 0 /* NOT_PRESENT */ && isConferencing();
                                // select default devices if we have not selected a device explicitly
                                if (devices && !devices.selectedMicrophone())
                                    mediaConfig.setDefaultDevices();
                                pcAV.invoke('SetCallConfig', mediaConfig.isInternal() ?
                                    Internal.MediaEnum.PreferredMediaAddressType.Direct :
                                    Internal.MediaEnum.PreferredMediaAddressType.Relay);
                                // hook up the preview video stream - this will retain the video container if it was set for
                                // self participant.
                                // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                                // receive another invitiation (it's a renegotiation of an established AV connection), so
                                // we won't have a chance to call accept method again.
                                selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                                if (videoContainer)
                                    mainVideoStream.source.sink.container(videoContainer);
                                if (previewContainer)
                                    selfVideoStream.source.sink.container(previewContainer);
                                pcAV.invoke('SetMediaConfig', audioConfig, // audio configuration
                                mainVideoConfig, // main video configuration
                                moreChannels ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                                moreChannels ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                                0 /* NOT_PRESENT */); // panoVideoConfig
                                if (audioState() == Internal.Modality.State.Connecting && !isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Ringing);
                                // expect an OFFER_READY event from the media plugin
                                dfdStart = new Task('waiting for an OFFER_READY event from the media plugin');
                                return dfdStart.promise;
                            }).catch(function (error) {
                                if (!rAVInvitation) {
                                    // if the AV invitation was not sent (rAVInvitation is undefined) release the plugin component.
                                    cleanup();
                                }
                                else if (rAVInvitation.hasLink('cancel')) {
                                    // if the AV invitation was sent and the "audioVideoInvitation started" event was received we have
                                    // the cancel link and we can terminate the call here.
                                    postMediaDiagnosticsData();
                                    ucwa.send('POST', rAVInvitation.link('cancel').href, { nobatch: true });
                                }
                                else {
                                }
                                state(Internal.Modality.State.Disconnected);
                                audioState(Internal.Modality.State.Disconnected);
                                videoState(Internal.Modality.State.Disconnected);
                                throw error;
                            });
                        }
                        //#endregion
                        //#region accept
                        /**
                         * Accepts an incoming Audio/Video invitation.
                         *
                         * @param {Dictionary} [video] - The video window container holder.
                         * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                         *
                         * @returns {Promise}
                         *
                         * Accepting an incoming call invitation:
                         *
                         *  - Creates an AVComponent with the media plugin.
                         *  - Invokes AVComponent::Load and waits until it gets loaded.
                         *  - Invokes AVComponent::SetCallConfig.
                         *  - Invokes AVComponent::SetAcceptedMedia and specifies that no video is needed.
                         *  - Invokes AVComponent::SetOffer with the SDPs received from the remote party.
                         *  - Handles the ANSWER_READY event from the media plugin: the event contains an SDP.
                         *  - Sends a POST audioVideoInvitation/acceptWithAnswer with the SDP from the media plugin.
                         *  - Receives an "audioVideoinvitation completed" event from UCWA
                         *  - Receives an "audioVideoRenegotiation started" event with a new SDP from the remote party.
                         *  - Invokes AVComponent::SetAcceptedMedia.
                         *  - Invokes AVComponent::SetOffer with the new SDP given in the renegotiation event.
                         *  - Handles another ANSWER_READY event from the media plugin with an SDP answer.
                         *  - Sends a POST audioVideoRenegotiation/answer with the SDP answer.
                         *  - Receives a "audioVideoRenegotiation completed" event from UCWA.
                         *  - Invokes AVComponent::CompleteNegotiation
                         */
                        function accept(options) {
                            assert(invitation, 'This is an outgoing call, so it cannot be "accepted"');
                            assert(!isConferencing(), 'This is a conference'); // accept is used in P2P only
                            assert(participants.size() == 1, 'The caller is not in participants');
                            var video = options && options.video, videoContainer = video && video.container, previewContainer = video && video.previewContainer;
                            mainVideoConfig = video ? 3 /* BOTH */ :
                                2 /* RECEIVE */;
                            state(Internal.Modality.State.Connecting);
                            audioState(Internal.Modality.State.Connecting);
                            participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                            if (invitation.hasVideo()) {
                                videoState(Internal.Modality.State.Connecting);
                                participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                            }
                            return initMedia().then(function () {
                                // the caller has already hung up
                                if (state() == Internal.Modality.State.Disconnected)
                                    throw Internal.EInvitationFailed(state.reason);
                                assert(!pcAV);
                                pcAV = mediaPlugin.createComponent({
                                    type: 'AVComponent',
                                    hide: true
                                });
                                pcAV.event(onPluginComponentEvent, 'async');
                                return pcAV.load(localUri, invitation.from.uri(), invitation.resource.get('threadId'), false, // isConference - accept is used in P2P only
                                1, // max num of video channels - only the main video channel is used in P2P (don't change,
                                // otherwise the media manager will fail the call constructed by the media plugin)
                                mediaConfig.audioVideoSecurityLevel());
                            }).then(function () {
                                // the caller has already hung up
                                if (state() == Internal.Modality.State.Disconnected)
                                    throw Internal.EInvitationFailed(state.reason);
                                // select default devices if we have not selected a device explicitly
                                if (devices && !devices.selectedMicrophone())
                                    mediaConfig.setDefaultDevices();
                                // hook up the preview video stream - this will retain the video container if it was set for
                                // self participant.
                                // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                                // receive another invitiation (it's a renegotiation of an established AV connection), so
                                // we won't have a chance to call accept method again.
                                selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                                if (videoContainer)
                                    mainVideoStream.source.sink.container(videoContainer);
                                if (previewContainer)
                                    selfVideoStream.source.sink.container(previewContainer);
                                pcAV.invoke('SetCallConfig', mediaConfig.isInternal() ?
                                    Internal.MediaEnum.PreferredMediaAddressType.Direct :
                                    Internal.MediaEnum.PreferredMediaAddressType.Relay);
                                pcAV.invoke('SetAcceptedMedia', 3 /* BOTH */, // audio
                                video ?
                                    3 /* BOTH */ :
                                    2 /* RECEIVE */);
                                // expect the ANSWER_READY event from the plugin after this call
                                setOffer(invitation.offers);
                                assert(!dfdAccept);
                                dfdAccept = new Task();
                                dfdAccept.status('awaiting an ANSWER_READY event from the media plugin');
                                return dfdAccept.promise;
                            }).then(null, function (error) {
                                state(Internal.Modality.State.Disconnected);
                                audioState(Internal.Modality.State.Disconnected);
                                videoState(Internal.Modality.State.Disconnected);
                                postMediaDiagnosticsData();
                                cleanup();
                                throw error;
                            });
                        }
                        //#endregion
                        //#region stop
                        /**
                         * Stops Audio/Video session
                         *
                         * @param {String} [reason] - if equals 'video', only video is stopped, if omitted both audio and video are stopped.
                         */
                        function stop(reason) {
                            // cancel start if stop is called during connecting
                            if (state() == Internal.Modality.State.Connecting)
                                return dfdStart.promise.cancel();
                            if (reason == 'video') {
                                if (isConferencing()) {
                                    participants.each(function (p) {
                                        p.video.channels(0).isStarted(false);
                                    });
                                }
                                var audioConfig = onHold() ?
                                    4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                                mainVideoConfig = 0 /* NOT_PRESENT */;
                                pcAV.invoke('SetMediaConfig', audioConfig, // audio configuration
                                mainVideoConfig, // main video configuration
                                isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, // video channel count
                                0 /* NOT_PRESENT */, // videoConfig
                                0 /* NOT_PRESENT */); // panoVideoConfig
                            }
                            else if (reason === Internal.sEscalation) {
                                // if escalation do only cleanup
                                cleanup(reason);
                            }
                            else {
                                postCallQualityFeedback();
                                // if not escalation then it is a call getting stopped.
                                // In this case call stopAudioVideo on ucwa and then cleanup
                                return ucwa.send('GET', rConversation.link('audioVideo').href).then(function (rAudioVideo) {
                                    var content = { query: { reason: 'UserInitiatedAction' } };
                                    var blob = getDiagnosticsBlob();
                                    if (blob)
                                        extend(content, { headers: { 'X-MS-MediaDiagnostics': blob } });
                                    return ucwa.send('POST', rAudioVideo.link('stopAudioVideo').href, content);
                                }).finally(function () { return cleanup(reason); });
                            }
                        }
                        //#endregion
                        //#region sendDtmf
                        /**
                         * Sends a DTMF tone
                         *
                         * @param {String} tone - A DTMF tone from MediaEnum.DtmfTone enumeration
                         * @returns {String} - The sent tone
                         */
                        function sendDtmf(tone) {
                            if (isNotEmptyString(tone)) {
                                tone = tone.trim().toLowerCase();
                                tone = tone.substr(0, 1).toUpperCase() + tone.substr(1);
                                if (Internal.MediaEnum.DtmfTone[tone] !== undefined) {
                                    pcAV.invoke('SendDTMF', Internal.MediaEnum.DtmfTone[tone]);
                                    return tone;
                                }
                            }
                            throw EInvalidArgument('tone', 'out of range');
                        }
                        //#endregion
                        //#region showParticipantVideo
                        function showParticipantVideo(participant) {
                            var isFound = false, videoStream, dfd;
                            if (videoState() != Internal.Modality.State.Connected)
                                throw EInvalidState(videoState(), Internal.Modality.State.Connected);
                            if (onHold())
                                throw Exception('OnHold');
                            if (participant[Internal.sInternal].isLocal()) {
                                // undefined means that we just started video, no need to renegotiate
                                if (participant.video.channels(0).isStarted() === false) {
                                    mainVideoConfig = 3 /* BOTH */;
                                    pcAV.invoke('SetMediaConfig', 3 /* BOTH */, // audio configuration
                                    mainVideoConfig, // main video configuration
                                    isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                                    isConferencing() ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                                    0 /* NOT_PRESENT */); // panoVideoConfig
                                }
                                return new Task().resolve().promise;
                            }
                            else if (isConferencing()) {
                                // find available stream
                                if (!mainVideoStream._isAttached()) {
                                    videoStream = mainVideoStream;
                                }
                                else {
                                    videoStreams.each(function (vs) {
                                        if (!isFound && !vs._isAttached()) {
                                            videoStream = vs;
                                            isFound = true;
                                        }
                                    });
                                }
                                if (!videoStream) {
                                    log('Cannot find available stream');
                                    throw EDoesNotExist('No available stream');
                                }
                                participant[Internal.sInternal].setVideoStream(videoStream);
                                videoStream._isAttached(true);
                                dfd = showVideo(videoStream, false).then(function () {
                                    try {
                                        pcAV.invoke('Subscribe', videoStream._id(), participant[Internal.sInternal].videoSourceId());
                                    }
                                    catch (err) {
                                        log('SUBSCRIBE ERROR: ' + err);
                                        throw err;
                                    }
                                }).then(function () {
                                    var sink = videoStream.source.sink;
                                    sink._c(sink.container.changed(function (newVal, reason, oldVal) {
                                        if (oldVal)
                                            removeParticipantVideo(participant).then(function () {
                                                if (newVal)
                                                    showParticipantVideo(participant);
                                                else
                                                    participant[Internal.sInternal].setVideoStarted(false);
                                            });
                                    }));
                                    sink._c(sink.format.changed(function (v) {
                                        if (v && videoStream._id() && sink._videoWindow()) {
                                            pcAV.invoke('SetVideoDisplayOptions', Internal.MediaEnum.MediaDeviceType.RENDER, sink._videoWindow(), sink._format(), 1 /* SmartCrop */);
                                        }
                                    }));
                                });
                            }
                            else {
                                dfd = new Task().reject(ENotSupported('cannot start remote video in 1:1 conversation')).promise;
                            }
                            return dfd;
                        }
                        //#endregion showParticipantVideo
                        //#region removeParticipantVideo
                        function removeParticipantVideo(participant) {
                            var dfd;
                            if (onHold())
                                throw Exception('OnHold');
                            if (participant[Internal.sInternal].isLocal()) {
                                mainVideoConfig = 2 /* RECEIVE */;
                                pcAV.invoke('SetMediaConfig', 3 /* BOTH */, // audio configuration
                                mainVideoConfig, // main video configuration
                                isConferencing() ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                                isConferencing() ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                                0 /* NOT_PRESENT */); // panoVideoConfig
                                return new Task().resolve().promise;
                            }
                            else if (isConferencing()) {
                                dfd = Task.wait(null, 'sync').then(function () {
                                    // NB: this is a sourced stream
                                    var videoStream = participant.video.channels(0).stream;
                                    var sink = videoStream.source.sink;
                                    if (sink._c())
                                        sink._c().dispose();
                                    if (videoStream._isAttached()) {
                                        try {
                                            pcAV.invoke('Unsubscribe', videoStream._id());
                                        }
                                        catch (err) {
                                            log('UNSUBSCRIBE ERROR: ' + err);
                                        }
                                        removeVideo(videoStream, false);
                                        videoStream._isAttached(false);
                                        participant[Internal.sInternal].setVideoStream(null);
                                    }
                                });
                            }
                            else {
                                // in 1:1 we can't remove remote video without stopping video altogether
                                dfd = new Task().reject(ENotSupported('cannot remove remote video in 1:1 conversation')).promise;
                            }
                            return dfd;
                        }
                        //#endregion removeParticipantVideo
                        //#endregion public methods
                        //#region cleanup
                        // Unsubscribes from server and plugin component events and unloads the plugin component
                        function cleanup(reason) {
                            var cDisconnected = Internal.Modality.State.Disconnected;
                            ucwa.event.off(onServerEvent);
                            if (pcAV) {
                                pcAV.event.off(onPluginComponentEvent);
                                removeAllVideo();
                                pcAV.invoke('Terminate');
                                pcAV.unload();
                                pcAV = null;
                            }
                            participants.each(function (p) {
                                // reset the participant video stream source to an empty stream
                                p[Internal.sInternal].setVideoStream(null);
                                if (!isConferencing()) {
                                    p[Internal.sInternal].audioState(cDisconnected);
                                    p[Internal.sInternal].videoState(cDisconnected);
                                }
                            });
                            audioState(cDisconnected /*, reason*/);
                            videoState(cDisconnected, reason);
                            if (selectedCameraChangedSubscription) {
                                selectedCameraChangedSubscription.dispose();
                                selectedCameraChangedSubscription = null;
                            }
                            reportMediaDiagnosticsUrl = null;
                            publishCallQualityFeedbackUrl = null;
                        }
                        //#endregion
                        //#region videoWindow
                        /**
                         * Creates a video window and anchors it in the parent DOM element
                         *
                         * The whole area of the parent element will be occupied by the video. Video preview window sized to
                         * 1/3rd of the remote window and is placed in the lower-right corner. Currently, its flicker makes
                         * the preview unusable
                         */
                        function showVideo(vs, isPreview) {
                            var sink = vs.source.sink;
                            if (vs._id() && sink.container()) {
                                // TODO: this is a temporary check to avoid repeated window creation
                                // when this method is called more than once ('participantVideo updated')
                                if (sink._state() == PluginComponent.State.Unloaded) {
                                    return sink._init().then(function () {
                                        pcAV.invoke('SetVideoWindow', vs._id(), isPreview ? Internal.MediaEnum.MediaDeviceType.PREVIEW : Internal.MediaEnum.MediaDeviceType.RENDER, sink._videoWindow(), sink._format(), 1 /* SmartCrop */);
                                    });
                                }
                            }
                        }
                        /**
                         * Removes the video window from the parent DOM element
                         */
                        function removeVideo(vs, isPreview) {
                            var sink = vs.source.sink;
                            if (vs._id() && sink._videoWindow()) {
                                pcAV.invoke('RemoveVideoWindow', vs._id(), isPreview ? Internal.MediaEnum.MediaDeviceType.PREVIEW : Internal.MediaEnum.MediaDeviceType.RENDER, sink._videoWindow());
                                sink._uninit();
                            }
                        }
                        //#endregion videoWindow
                        //#region server events
                        function onServerEvent(event) {
                            var id = event.target.rel + ' ' + event.type;
                            var handler = ucwaEventHandlers[id];
                            if (handler) {
                                // debugger; // this is to let debug the handler of the event
                                handler(event.status, event.resource, event);
                            }
                        }
                        var ucwaEventHandlers = {
                            // this is the first event received in any AV call setup (except calling an invalid SIP uri,
                            // in which case UCWA sends the 'audioVideoInvitation completed' event only).
                            'audioVideoInvitation started': function (status, resource) {
                                // set the invitation resource for the outgoing AV session (for the incoming call
                                // audioVideoSession is initialized with the received invitation resource)
                                if (resource.get('direction') == 'Outgoing' &&
                                    resource.get('sessionContext') == sessionContext) {
                                    // if the user canceled the call before we received this event terminate the call
                                    // on the server and unload the AV component.
                                    if (state() == Internal.Modality.State.Disconnected) {
                                        if (resource.hasLink('cancel'))
                                            ucwa.send('POST', resource.link('cancel').href, { nobatch: true });
                                        cleanup();
                                    }
                                    else {
                                        rAVInvitation = resource;
                                        // when we make the outgoing invite we get a reportMediaDiagnostics link, save it.
                                        // if the call is declined by the remote party or timed out use this link to post media diag
                                        if (resource.hasLink('reportMediaDiagnostics'))
                                            reportMediaDiagnosticsUrl = resource.link('reportMediaDiagnostics').href;
                                        dfdStart.status('awaiting "audioVideoNegotiation started or completed" event from UCWA');
                                    }
                                }
                            },
                            // this event is received if we started an outgoing AV call as the first conversation modality
                            // using the global startAudioVideo link
                            'conversation added': function (status, resource) {
                                if (resource.get('threadId') == conversation.threadId())
                                    rConversation = resource;
                            },
                            // this event is received during outgoing P2P AV call setup (early media?)
                            'audioVideoNegotiation started': function (status, resource, event) {
                                if (event.sender.href == rAVInvitation.href) {
                                    setProvisionalAnswer(resource.link('mediaProvisionalAnswer').href, resource.get('remoteEndpoint'));
                                    dfdStart.status('awaiting "audioVideoNegotiation completed" event from UCWA');
                                }
                            },
                            // this event is received during outgoing P2P or conference call setup.
                            // If the negotiation completed successfully the event resource contains session context,
                            // a link to matching audioVideoSession and the remoteEndpoint of that session.
                            // If the call was declined or not answered we have negotiation href only.
                            'audioVideoNegotiation completed': function (status, resource, event) {
                                var href;
                                if (event.sender.href == rAVInvitation.href) {
                                    switch (status) {
                                        case 'Success':
                                            // "audioVideoNegotiation completed" may arrive before the corresponding
                                            // "audioVideoSession added" event when the call is forwarded to voice mail.
                                            // in this case we create an entry in avSessions and expect to fill it out
                                            // after the session added event arrives.
                                            href = resource.link('audioVideoSession').href;
                                            avSessions[href] = avSessions[href] || {};
                                            avSessions[href].negotiated = true;
                                            setFinalAnswer(resource.link('mediaAnswer').href, resource.get('remoteEndpoint'));
                                            dfdStart.status('awaiting "audioVideoInvitation completed" event from UCWA');
                                            break;
                                        case 'Failure':
                                            if (event.reason.subcode != 'Ended' && event.reason.subcode != 'ConnectedElsewhere')
                                                dfdStart.status(event.reason && event.reason.message);
                                            postMediaDiagnosticsData(event.reason);
                                            break;
                                    }
                                }
                            },
                            // during an outgoing call the server may set up more than one audioVideoSession, because
                            // the remote sip uri that we are calling may be signed in on more than one endpoint.
                            // Also, if the remote party does not accept the call the UCWA server may redirect the
                            // client to a media server so that the client may leave a voice mail; during this process
                            // the UCWA server will create another audioVideoSession and delete the original session.
                            // The next two handlers keep track of audioVideoSessions.
                            'audioVideoSession added': function (status, resource) {
                                var href = resource.href;
                                if (resource.get('sessionContext') == sessionContext) {
                                    avSessions[href] = avSessions[href] || {};
                                    avSessions[href].resource = resource;
                                    if (resource.hasLink('publishCallQualityFeedback'))
                                        publishCallQualityFeedbackUrl = resource.link('publishCallQualityFeedback').href;
                                }
                            },
                            'audioVideoSession updated': function (status, resource) {
                                if (resource.get('sessionContext') == sessionContext) {
                                    if (resource.hasLink('publishCallQualityFeedback'))
                                        publishCallQualityFeedbackUrl = resource.link('publishCallQualityFeedback').href;
                                }
                            },
                            'audioVideoSession deleted': function (status, resource, event) {
                                delete avSessions[event.target.href];
                                // this event is the only indication of a failed escalation; we need to notify
                                // AudioVideoModality so it can force the cleanup of this session (technically there
                                // a "participantInvitation completed" event with code == ServiceFailure and
                                // subcode == EscalationFailed but it is received by the client that issued the
                                // invitation only).
                                if (fEscalation && isEmptyObject(avSessions)) {
                                    escalated.fire('failure');
                                    fEscalation = false;
                                }
                            },
                            // this event is received during any AV call setup
                            'audioVideoInvitation completed': function (status, resource, event) {
                                // check for rAVInvitation is needed because this event may arrive before we
                                // even get a response to startAudioVideo post if we call an invalid SIP uri,
                                // so rAVInvitation may be undefined.
                                // Note that completion of an outgoing invitation is handled by sendOffer method
                                if (rAVInvitation && rAVInvitation.href == resource.href &&
                                    resource.get('direction') == 'Incoming') {
                                    if (status == 'Success') {
                                        try {
                                            // there are no audioVideoNegotiation events in the incoming P2P call setup,
                                            // so we set negotiated flag for the cached audioVideoSession here
                                            setNegotiatedSession(resource.get('sessionContext'));
                                            completeNegotiation(status, event.reason);
                                            // if AV is added by a remote participant in a 1:1 conversation which already
                                            // has another modality (messaging) then "participantAudio/Video added" events
                                            // arrive before "audioVideoInvitation started" event, i.e. before this
                                            // AudioVideoSession object exists. So we need to set the AV properties of the
                                            // remote participant here:
                                            // TODO: check if they were not set before : Accepting the AV invitation that created the call
                                            assert(!isConferencing());
                                            var p = participants(0);
                                            if (p) {
                                                p[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                                if (videoState() == Internal.Modality.State.Connected) {
                                                    p[Internal.sInternal].setVideoStream(mainVideoStream);
                                                    p[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                            }
                                            dfdAccept.resolve();
                                            state(Internal.Modality.State.Connected);
                                        }
                                        catch (error) {
                                            dfdAccept.reject(error);
                                            state(Internal.Modality.State.Disconnected);
                                        }
                                    }
                                    else {
                                        // the caller (remote party) hung up while the call setup was not completed.
                                        if (dfdAccept)
                                            dfdAccept.reject(event.reason);
                                        state(Internal.Modality.State.Disconnected, event.reason);
                                    }
                                }
                            },
                            'audioVideoRenegotiation started': function (status, resource) {
                                if (resource.link('audioVideoSession').href in avSessions) {
                                    if (resource.get('direction') == 'Incoming') {
                                        var sdp = DataUri(resource.link('mediaOffer').href).data;
                                        if (!isConferencing() && participants.size() > 0) {
                                            remoteHoldState = isHoldRequest(sdp) ?
                                                RemoteHoldState.HoldOffered : RemoteHoldState.ResumeOffered;
                                        }
                                        setRenegotiationOffer(sdp);
                                        rAVRenegotiation = resource;
                                    }
                                    else if (dfdStart && dfdStart.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by the second start() call
                                        // to add video to an audio conversation
                                        dfdStart.status('Waiting for audioVideoRenegotiation completed event');
                                    }
                                }
                            },
                            'audioVideoRenegotiation completed': function (status, resource, event) {
                                var href = resource.link('audioVideoSession').href;
                                if (href in avSessions) {
                                    if (resource.get('direction') == 'Outgoing') {
                                        assert(resource.get('operationId') in outAvRenegoOpIds);
                                        delete outAvRenegoOpIds[resource.get('operationId')];
                                        if (status == 'Success') {
                                            avSessions[href].renegotiated = true;
                                            setFinalAnswer(resource.link('mediaAnswer').href, avSessions[href].resource.get('remoteEndpoint'));
                                        }
                                        completeNegotiation(status, event.reason);
                                        if (dfdStart && dfdStart.state() == 'pending') {
                                            // this is an outgoing renegotiation caused by the second start() call
                                            // to add video to an audio conversation
                                            if (status == 'Success')
                                                dfdStart.resolve();
                                            else
                                                dfdStart.reject();
                                        }
                                    }
                                    else {
                                        // the renegotiation may be in response to remote participant hold/resume
                                        if (!isConferencing()) {
                                            if (remoteHoldState == RemoteHoldState.HoldAnswered)
                                                remoteHoldState = RemoteHoldState.HoldCompleted;
                                            else if (remoteHoldState == RemoteHoldState.ResumeAnswered)
                                                remoteHoldState = RemoteHoldState.ResumeCompleted;
                                        }
                                        completeNegotiation(status, event.reason);
                                    }
                                }
                            },
                            'audioVideo updated': function (status, resource, event) {
                                if (rAVInvitation && resource.href == rAVInvitation.link('audioVideo').href) {
                                    if (resource.get('state') == 'Disconnected') {
                                        postMediaDiagnosticsData(event.reason);
                                        postCallQualityFeedback();
                                        if (rAVInvitation.get('state') == 'Connected') {
                                            // This is our chance to clean up the established call that is terminated by
                                            // the remote party. The local party terminates the established call via modality.stop()
                                            // and hang-ups by either party during call setup are processed by audioVideoInvitation
                                            // started/completed event handlers.
                                            cleanup();
                                            // setting this modality state to disconnected will cause its removal from
                                            // the conversation
                                            state(Internal.Modality.State.Disconnected);
                                        }
                                    }
                                    else if (resource.get('state') == 'Connected') {
                                        // when audiovideo is connected pick up the reportMediaDiagnostics url and save it
                                        // when audiovideo gets disconnected use the saved link to send media diagnostics
                                        if (resource.hasLink('reportMediaDiagnostics'))
                                            reportMediaDiagnosticsUrl = resource.link('reportMediaDiagnostics').href;
                                        if (isConferencing())
                                            postPublishTelemetry(resource);
                                        if (event.reason && event.reason.subcode == 'SessionSwitched' &&
                                            resource.link('audioVideoSession').href in avSessions) {
                                            // this is the escalation confirmation, i.e. this AV session replaced the
                                            // original P2P AV session
                                            escalated.fire('success');
                                            fEscalation = false;
                                        }
                                    }
                                }
                            },
                            // participantAudio/Video added/deleted events for a localParticipant are used to
                            // track active modalities of this client
                            'participantAudio added': onParticipantAudio,
                            'participantAudio updated': onParticipantAudio,
                            'participantAudio deleted': onParticipantAudio,
                            'participantVideo added': onParticipantVideo,
                            'participantVideo updated': onParticipantVideo,
                            'participantVideo deleted': onParticipantVideo,
                            'escalateAudio deleted': function (status, resource, event) {
                                if (event.target.href == escalateAudioVideoUri)
                                    escalateAudioVideoUri = null;
                            },
                            // these events are fired in the later phase of the escalation when the setup of our inactive AV call
                            // to a conference is finished and we may activate (resume) it.
                            'resumeAudio added': onResumeAudioVideoAdded,
                            'resumeAudioVideo added': onResumeAudioVideoAdded,
                            'resumeAudio deleted': onResumeAudioVideoDeleted,
                            'resumeAudioVideo deleted': onResumeAudioVideoDeleted
                        };
                        // returns a participant object from a participants collection
                        function getParticipant(href) {
                            var participant = find(participants(), function (p) { return p[Internal.sHref] == href; });
                            if (participant)
                                return participant;
                            // shortcut for a 1:1 conversation with a participant added to the conversation beforehand
                            //
                            // The check for participant size is needed because if the AV conversation is started not with the
                            // participant from a person model but using the sip uri as a parameter, we would have to rely on
                            // "participant added" event for the remote guy to become a member of participants collection.
                            // If miraculously this event arrives after "participantAudio/Video added" we would have an empty
                            // participants collection here.
                            if (!isConferencing() && participants.size() == 1)
                                return participants(0);
                            // "participantAudio/Video added" event arrives right after "participant added" event. If the
                            // participant was added to the conversation's participant collection using its contact href,
                            // the "participant added" event handler is doing another server lookup to match that contact href
                            // to the participant href. So we can't find that participant here either and we need to do the
                            // same lookup.
                            return ucwa.send('GET', href).then(function (r) {
                                return getParticipant(r.link('contact').href);
                            });
                        }
                        function isInMediaRoster(participant) {
                            var p = participant[Internal.sInternal];
                            return pcAV && p.isInMediaRoster[pcAV.id()];
                        }
                        function updateMediaRoster(participant, type) {
                            try {
                                var method = type == 'add' ? 'AddParticipantInfo' :
                                    type == 'remove' ? 'RemoveParticipantInfo' :
                                        type == 'update' ? 'UpdateParticipantInfo' :
                                            assert(false);
                                var p = participant[Internal.sInternal];
                                // pcAV may not exist yet when we join the meeting which participants are already on the AV call.
                                // In this case 'participantVideo added' events for such participants may come before we finish
                                // joining the meeting so we have not loaded the plugin AVComponent.
                                // This may also happen during escalation on the 'almost obsolete' avs object (i.e., the pcAV
                                // object has just been deleted but the avs event handler has picked up the "participantVideo updated"
                                // event and arrived here.
                                if (!pcAV)
                                    return false;
                                pcAV.invoke(method, p.audioSourceId(), p.videoSourceId(), -1);
                                p.isInMediaRoster[pcAV.id()] = type != 'remove';
                                return true;
                            }
                            catch (err) {
                                log('Media Roster ERROR: ' + err);
                                return false;
                            }
                        }
                        // event handler for "participantAudio added/updated/deleted in participant|localParticipant" events
                        //  - tracks session audio state (on/off) and participant audio state.
                        function onParticipantAudio(status, resource, event) {
                            var scope = event['in'];
                            if (event.sender.href == rConversation.href && scope) {
                                if (scope.rel == 'localParticipant') {
                                    switch (event.type) {
                                        case 'added': // signal for the initial AV session
                                        case 'updated':
                                            if (isConferencing())
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                            activeModalities.audio = true;
                                            audioState(Internal.Modality.State.Connected);
                                            break;
                                        case 'deleted':
                                            activeModalities.audio = false;
                                            audioState(Internal.Modality.State.Disconnected);
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                }
                                else if (scope.rel == 'participant') {
                                    Task.wait(getParticipant(scope.href)).then(function (participant) {
                                        switch (event.type) {
                                            case 'added':
                                            case 'updated':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    // In conference mode, the indication of a remote
                                                    // participant hold/resume or mute/unmute is
                                                    // "participantAudio updated" event. We need to
                                                    // reload "participantAudio" resource and set the
                                                    // properties accordingly
                                                    if (event.type == 'updated') {
                                                        ucwa.send('GET', event.target.href).then(function (r) {
                                                            if (r.has('audioDirection')) {
                                                                participant[Internal.sInternal].audioOnHold(r.get('audioDirection') ==
                                                                    AudioVideoDirection.Inactive);
                                                            }
                                                            if (r.has('audioMuted'))
                                                                participant[Internal.sInternal].audioMuted(r.get('audioMuted'));
                                                        });
                                                    }
                                                }
                                                participant[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                                break;
                                            case 'deleted':
                                                participant[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                                                break;
                                            default:
                                                assert(false, 'unexpected event type');
                                        }
                                    });
                                }
                            }
                        }
                        // event handler for "participantVideo added/updated/deleted in participant|localParticipant" events
                        //  - tracks session video state (on/off), participant video state and shows/removes video
                        //    when video modality is activated/deactivated.
                        function onParticipantVideo(status, resource, event) {
                            var scope = event['in'];
                            if (event.sender.href == rConversation.href && scope) {
                                if (scope.rel == 'localParticipant') {
                                    switch (event.type) {
                                        case 'added':
                                        case 'updated':
                                            activeModalities.video = true;
                                            if (isConferencing()) {
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                                updateMediaRoster(selfParticipant, isInMediaRoster(selfParticipant) ? 'update' : 'add');
                                                // check participants that are already in the conference - we need their msis
                                                // because we won't receive "participantVideo added" events for them.
                                                participants.each(function (p) {
                                                    if (!isInMediaRoster(p) && p[Internal.sInternal].audioSourceId() != -1)
                                                        updateMediaRoster(p, 'add');
                                                });
                                                updateVideoState(selfParticipant, event, true);
                                            }
                                            else {
                                                videoState(Internal.Modality.State.Connected);
                                                selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                            }
                                            break;
                                        case 'deleted':
                                            removeVideo(selfVideoStream, true);
                                            activeModalities.video = false;
                                            if (isConferencing()) {
                                                if (isInMediaRoster(selfParticipant))
                                                    updateMediaRoster(selfParticipant, 'remove');
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                                selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                            }
                                            videoState(Internal.Modality.State.Disconnected);
                                            selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                }
                                else if (scope.rel == 'participant') {
                                    Task.wait(getParticipant(scope.href)).then(function (participant) {
                                        switch (event.type) {
                                            case 'added':
                                            case 'updated':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    updateMediaRoster(participant, isInMediaRoster(participant) ? 'update' : 'add');
                                                    updateVideoState(participant, event);
                                                }
                                                else {
                                                    participant[Internal.sInternal].setVideoStream(mainVideoStream);
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                                break;
                                            case 'deleted':
                                                if (isConferencing()) {
                                                    if (isInMediaRoster(participant))
                                                        updateMediaRoster(participant, 'remove');
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    participant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                                    removeParticipantVideo(participant);
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                                    // if participant video is deleted not because we stopped video
                                                    // subscription explicitly (via isStarted(false)) but because 
                                                    // participant left the AV call then we need to reset isStarted.
                                                    participant[Internal.sInternal].setVideoStarted(false);
                                                }
                                                else {
                                                    participant[Internal.sInternal].setVideoStream(null);
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                                }
                                                break;
                                            default:
                                                assert(false, 'unexpected event type');
                                        }
                                    });
                                }
                            }
                        }
                        /**
                         * Do a GET on participantVideo and connect the video state if the
                         * resource has active videoDirection.
                         */
                        function updateVideoState(participant, event, isSelf) {
                            var resource = event.resource;
                            var target = event.target;
                            Task.run(function () {
                                return resource && resource.has('videoDirection') ? resource : ucwa.send('GET', target.href);
                            }).then(function (res) {
                                if (res.has('videoDirection')) {
                                    var rVideoDirection = res.get('videoDirection');
                                    participant.video.channels(0)[Internal.sInternal].isVideoOn(rVideoDirection === AudioVideoDirection.SendOnly
                                        || rVideoDirection === AudioVideoDirection.SendReceive);
                                    if (!contains([AudioVideoDirection.Inactive, AudioVideoDirection.Unknown], function (d) { return d == rVideoDirection; })) {
                                        if (isSelf)
                                            videoState(Internal.Modality.State.Connected);
                                        participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                    }
                                }
                            });
                        }
                        // event handler for 'resumeAudio/resumeAudioVideo added' event
                        //   - activates the inactive conference session created during escalation
                        function onResumeAudioVideoAdded(status, resource, event) {
                            var scope = event['in'], href;
                            if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions) {
                                href = scope.href;
                                // Currently UCWA returns the 'renegotiations' link of the audioVideoSession as resumeAudio uri,
                                // i.e. avSessions[event.in.href].resource.link('renegotiations').href == event.target.href,
                                // but we cache it separately just in case
                                avSessions[href].resumeAudioVideoUri = event.target.href;
                                Task.wait(null).then(function () {
                                    if (!avSessions[href].renegotiated) {
                                        return ucwa.wait({
                                            type: 'completed',
                                            target: { rel: 'audioVideoRenegotiation' },
                                            resource: function (r) {
                                                // r.get('operationId') in outAvRenegoOpIds;
                                                return r.get('direction') == 'Outgoing' && r.link('audioVideoSession').href in avSessions;
                                            }
                                        });
                                    }
                                }).then(function () {
                                    resumeAudioVideo();
                                });
                            }
                        }
                        function onResumeAudioVideoDeleted(status, resource, event) {
                            var scope = event['in'];
                            if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions &&
                                event.target.href == avSessions[scope.href].resumeAudioVideoUri) {
                                delete avSessions[scope.href].resumeAudioVideoUri;
                            }
                        }
                        //#endregion server events
                        //#region plugin events
                        function onPluginComponentEvent(event) {
                            var handler = pluginEventHandlers[event.type];
                            if (handler) {
                                // debugger; // this is to let debug the handler of the event
                                handler.apply(null, event.args);
                            }
                        }
                        var pluginEventHandlers = {
                            'CHANNEL_CREATED': function (channelType, channelId, isMain) {
                                switch (channelType) {
                                    case 1 /* AUDIO */:
                                        audioChannel = { channelType: channelType, channelId: channelId };
                                        break;
                                    case 2 /* VIDEO */:
                                        if (isMain) {
                                            mainVideoStream._id(channelId);
                                            selfVideoStream._id(channelId);
                                        }
                                        else {
                                            assert(isConferencing());
                                            videoStreams.add(new Internal.MediaStream({
                                                mediaPlugin: mediaPlugin,
                                                type: Internal.MediaEnum.StreamType.Render,
                                                id: channelId
                                            }));
                                            // max number of remote participant video streams in a meeting
                                            // = max num of plugin channels excluding the main channel
                                            assert(videoStreams.size() < mediaConfig.maxVideoChannelCount());
                                            log('Num streams created: ' + videoStreams.size());
                                        }
                                        break;
                                    default:
                                        log('Created a channel of unknown type ' + channelType);
                                        // debugger;
                                        break;
                                }
                            },
                            'CHANNEL_DISCONNECTED': function (channelType, channelId, reason) {
                                if (channelType === 2 /* VIDEO */
                                    && mainVideoStream._id() === channelId
                                    && !isConferencing()) {
                                    selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                    participants(0).video.channels(0)[Internal.sInternal].isVideoOn(false);
                                    // For an outgoing p2p video call if remote user accepts with audio only
                                    // we need to disconnect video.
                                    // We don't get any localparticipant video events from ucwa so without below
                                    // the videoState remains connecting.
                                    videoState(Internal.Modality.State.Disconnected);
                                }
                            },
                            'CHANNEL_DIRECTION_CHANGED': function (channelType, channelId, direction) {
                                // wire participant.audio.isOnHold to direction:
                                //   - MediaEnum.MediaConfig.NO_ACTIVE_MEDIA: hold
                                //   - otherwise (likely MediaEnum.MediaConfig.BOTH): resume
                                if (remoteHoldState == RemoteHoldState.HoldCompleted) {
                                    if (direction == 4 /* NO_ACTIVE_MEDIA */ && !isConferencing())
                                        participants(0)[Internal.sInternal].audioOnHold(true);
                                    remoteHoldState = RemoteHoldState.Unknown;
                                }
                                else if (remoteHoldState == RemoteHoldState.ResumeCompleted) {
                                    if (!isConferencing()) {
                                        // note: direction can be MediaConfig.NO_ACTIVE_MEDIA
                                        // if local participant is on hold
                                        participants(0)[Internal.sInternal].audioOnHold(false);
                                    }
                                    remoteHoldState = RemoteHoldState.Unknown;
                                }
                                // CHANNEL_DIRECTION_CHANGED is a good hint for detecting...
                                if (channelType == 2 /* VIDEO */ &&
                                    selfVideoStream._id() == channelId) {
                                    // ... if self participant is streaming video
                                    switch (direction) {
                                        case 1 /* SEND */:
                                        case 3 /* BOTH */:
                                            selfParticipant[Internal.sInternal].setVideoStarted(true);
                                            selfVideoStream._isFlowing(true);
                                            selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(true);
                                            break;
                                        case 2 /* RECEIVE */:
                                            selfParticipant[Internal.sInternal].setVideoStarted(false);
                                            selfVideoStream._isFlowing(false);
                                            selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                            break;
                                        default:
                                            selfParticipant.video.channels(0)[Internal.sInternal].isVideoOn(false);
                                            break;
                                    }
                                    // ... and if remote participant in a 1:1 conversation is streaming video
                                    if (!isConferencing()) {
                                        assert(mainVideoStream._id() == channelId);
                                        switch (direction) {
                                            case 1 /* SEND */:
                                                participants(0)[Internal.sInternal].setVideoStarted(false);
                                                mainVideoStream._isFlowing(false);
                                                participants(0).video.channels(0)[Internal.sInternal].isVideoOn(false);
                                                break;
                                            case 2 /* RECEIVE */:
                                            case 3 /* BOTH */:
                                                participants(0)[Internal.sInternal].setVideoStarted(true);
                                                mainVideoStream._isFlowing(true);
                                                participants(0).video.channels(0)[Internal.sInternal].isVideoOn(true);
                                                break;
                                            default:
                                                participants(0).video.channels(0)[Internal.sInternal].isVideoOn(false);
                                                break;
                                        }
                                    }
                                }
                            },
                            'MEDIA_CHANGED': function (channelType, channelId, direction, mediaEvent) {
                                var streamState;
                                if (channelType == 2 /* VIDEO */) {
                                    streamState = enumcastStreamState(mediaEvent);
                                    if (mainVideoStream._id() == channelId && direction == 2 /* RENDER */)
                                        mainVideoStream._state(streamState);
                                    else if (selfVideoStream._id() == channelId && direction == 1 /* CAPTURE */) {
                                        selfVideoStream._state(streamState);
                                        if (1 /* STREAM_STARTED */ === mediaEvent) {
                                            selectedCameraChangedSubscription = devices.selectedCamera.changed(function (camera) {
                                                try {
                                                    if (camera && pcAV)
                                                        pcAV.invoke('SetCameraDevice', camera.name());
                                                }
                                                catch (err) {
                                                    log('AudioVideoSession(' + modelId + ') error handling selectedcamera changed ' + err);
                                                }
                                            }, 'async');
                                        }
                                        else if (4 /* STREAM_STOPPED */ === mediaEvent && selectedCameraChangedSubscription) {
                                            selectedCameraChangedSubscription.dispose();
                                            selectedCameraChangedSubscription = null;
                                        }
                                    }
                                    else {
                                        videoStreams.each(function (vs) {
                                            if (vs._id() == channelId)
                                                vs._state(streamState);
                                        });
                                    }
                                }
                            },
                            // yes, it's not a typo but a plugin bug
                            'DOMINANT_SPEKAER_CHANGED': function () {
                                // arguments - num of speakers, msi0, msi1, ... 
                                //   the most recent speaker is the first in the list; 
                                //   if msi0 == -1, nobody is speaking
                                var msi = arguments[1], cur, prev = recentActiveSpeakers[activeSourceId];
                                if (prev)
                                    prev[Internal.sInternal].isSpeaking(false);
                                if (msi == -1) {
                                    activeSourceId = msi;
                                    return;
                                }
                                cur = recentActiveSpeakers[msi];
                                if (!cur) {
                                    // we have a new speaker who has not talked before
                                    if (selfParticipant[Internal.sInternal].audioSourceId() == msi) {
                                        cur = selfParticipant;
                                    }
                                    else {
                                        participants.each(function (p) {
                                            if (p[Internal.sInternal].audioSourceId() == msi)
                                                cur = p;
                                        });
                                    }
                                    if (cur)
                                        recentActiveSpeakers[msi] = cur;
                                }
                                if (cur) {
                                    cur[Internal.sInternal].isSpeaking(true);
                                    activeSourceId = msi;
                                }
                            },
                            'OFFER_READY': function (hasOffer, diagCode, sdpCount) {
                                var i, offers = [], renegoHref;
                                try {
                                    for (i = 0; i < sdpCount; i++) {
                                        offers.push({
                                            sdp: arguments[3 + i * 2],
                                            id: arguments[3 + i * 2 + 1]
                                        });
                                    }
                                    if (offers.length == 0)
                                        throw Exception('NoSdpOffers', { diagCode: diagCode });
                                    renegoHref = getRenegotiationsHref();
                                    if (renegoHref) {
                                        // A negotiated AudioVideoSession already exists, the client starts renegotiation -
                                        // expect an "audioVideoRenegotiation completed" event from UCWA after
                                        // sending renegotiation offer
                                        sendRenegotiationOffer(offers[0].sdp, renegoHref);
                                    }
                                    else {
                                        // The client starts AV session - expect an "audioVideoInvitation completed"
                                        // event from UCWA after sending the invitation
                                        sendOffer(offers).then(function () {
                                            dfdStart.resolve();
                                            state(Internal.Modality.State.Connected);
                                        }, function (error) {
                                            // if the caller hangs up by canceling this promise explicitly we wind up
                                            // here with the rejected promise
                                            if (dfdStart.state() == 'pending')
                                                dfdStart.reject(error);
                                            state(Internal.Modality.State.Disconnected, error);
                                            audioState(Internal.Modality.State.Disconnected);
                                            videoState(Internal.Modality.State.Disconnected);
                                            postMediaDiagnosticsData();
                                            cleanup();
                                        }, dfdStart.status);
                                    }
                                }
                                catch (error) {
                                    log(error);
                                    if (dfdStart && dfdStart.state() == 'pending')
                                        dfdStart.reject(error);
                                }
                            },
                            'ANSWER_READY': function (_arg0, sdp) {
                                log('SDP Answer:\n' + sdp);
                                if (rAVRenegotiation) {
                                    if (!isConferencing()) {
                                        if (remoteHoldState == RemoteHoldState.HoldOffered)
                                            remoteHoldState = RemoteHoldState.HoldAnswered;
                                        else if (remoteHoldState == RemoteHoldState.ResumeOffered)
                                            remoteHoldState = RemoteHoldState.ResumeAnswered;
                                    }
                                    // the client answers the incoming renegotiation request
                                    // expect an "audioVideoRenegotiation completed" after this call
                                    ucwa.send('POST', rAVRenegotiation.link('answer').href, {
                                        headers: { 'Content-Type': 'application/sdp' },
                                        data: sdp,
                                        nobatch: true
                                    });
                                }
                                else {
                                    // the client answers the incoming invitation
                                    dfdAccept.status('sending answer to UCWA');
                                    invitation.acceptWithAnswer(sdp, sessionContext).then(function () {
                                        dfdAccept.status('awaiting an "audioVideoInvitation completed" event from UCWA');
                                    }, function (error) {
                                        dfdAccept.reject(error);
                                        state(Internal.Modality.State.Disconnected, error);
                                        audioState(Internal.Modality.State.Disconnected);
                                        videoState(Internal.Modality.State.Disconnected);
                                    }, dfdAccept.status);
                                }
                            }
                        };
                        //#endregion plugin events
                        //#region sendOffer
                        /**
                        * Composes an SDP offer from the OFFER_READY media plugin event data and
                        * sends it to the server to start an AV session.
                        *
                        * The returned promise is resolved only when we get a reply to the post and
                        * and audioVideoInvitation completed event
                        */
                        function sendOffer(offers) {
                            assert(offers.length > 0);
                            // construct content that contains all offers given by the media plugin
                            function createOfferOptions(context) {
                                var boundary = '9BCE36B8-2C70-44CA-AAA6-D3D332ADBD3F', mediaOffer, options = { nobatch: true };
                                if (isConferencing()) {
                                    if (escalateAudioVideoUri) {
                                        mediaOffer = Internal.multipartSDP(offers, boundary);
                                        options = {
                                            headers: {
                                                'Content-Type': 'multipart/alternative;boundary=' + boundary +
                                                    ';type="application/sdp"',
                                                'Content-Length': '' + mediaOffer.length
                                            },
                                            query: {
                                                operationId: operationId,
                                                sessionContext: sessionContext
                                            },
                                            data: mediaOffer,
                                            nobatch: true
                                        };
                                    }
                                    else {
                                        options.data = Internal.multipartJsonAndSDP({
                                            offers: offers,
                                            boundary: boundary,
                                            operationId: operationId,
                                            sessionContext: sessionContext,
                                            threadId: conversation.threadId(),
                                            context: context
                                        });
                                        options.headers = {
                                            'Content-Type': 'multipart/related;boundary=' + boundary +
                                                ';type="application/vnd.microsoft.com.ucwa+json"'
                                        };
                                    }
                                }
                                else {
                                    // P2P mode
                                    options.data = Internal.multipartJsonAndSDP({
                                        to: remoteUri,
                                        offers: offers,
                                        boundary: boundary,
                                        operationId: operationId,
                                        sessionContext: sessionContext,
                                        threadId: conversation.threadId(),
                                        context: context
                                    });
                                    options.headers = {
                                        'Content-Type': 'multipart/related;boundary=' + boundary +
                                            ';type="application/vnd.microsoft.com.ucwa+json"'
                                    };
                                }
                                if (context)
                                    extend(options.headers, { 'X-MS-RequiresMinResourceVersion': 2 });
                                return options;
                            }
                            return async(getStartAudioVideoLink).call(null).then(function (link) {
                                var options = createOfferOptions(link.revision >= 2 && invitationContext), dfdPost, dfdCompleted;
                                dfdPost = ucwa.send('POST', link.href, options).then(function (r) {
                                    // POST to startAudioVideo/addAudioVideo returns an empty response with an AV invitation
                                    // URI in the Location header. The UCWA stack constructs and returns an empty resource
                                    // with href set to that URI.
                                    if (!rAVInvitation)
                                        rAVInvitation = r;
                                });
                                // wait for the "audioVideoInvitation completed" event that corresponds to the given conversation
                                dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'audioVideoInvitation' },
                                    resource: { direction: 'Outgoing', threadId: conversation.threadId(), operationId: operationId, sessionContext: sessionContext }
                                }).then(function (event) {
                                    if (event.status == 'Failure') {
                                        // if remote SIP uri is invalid we won't receive "audioVideoInvitation started" event,
                                        // thus we won't have a full rAVInvitation resource cached. It will be either undefined or
                                        // just an empty resource with an href returned by a response to startAudioVideo POST (if
                                        // that response arrived before this event). So we cache the invitation resource here,
                                        // since it may be used by other event handlers.
                                        rAVInvitation = event.resource;
                                        // Technically we may need to complete the negotiation if it was started (i.e. if the call
                                        // reached the remote party and was declined).
                                        completeNegotiation(event.status, event.reason);
                                        throw Internal.EInvitationFailed(event.reason);
                                    }
                                    completeNegotiation(event.status, event.reason);
                                });
                                return Task.waitAll([dfdPost, dfdCompleted]);
                            });
                        }
                        //#endregion
                        //#region sendRenegotiationOffer
                        /**
                         * Composes an SDP offer from the OFFER_READY media plugin event data and
                         * sends it to the server to renegotiate the AV session.
                         */
                        function sendRenegotiationOffer(sdp, url) {
                            log('Renegotiation SDP offer:\n', sdp);
                            // cache operation id
                            var operationId = guid();
                            outAvRenegoOpIds[operationId] = "";
                            return ucwa.send('POST', url, {
                                headers: { 'Content-Type': 'application/sdp' },
                                query: { operationId: operationId },
                                data: sdp,
                                nobatch: true
                            });
                        }
                        //#endregion
                        //#region setOffer
                        /**
                         * Invokes pcAV.invoke("SetOffer", ...) with the given set of SDPs,
                         * e.g. pcAV.invoke("SetOffer", false, 2, sdp1, id1, sdp2, id2).
                         *
                         * @param {Object[]} offers
                         * @returns Whatever pcAV returns.
                         */
                        function setOffer(offers) {
                            assert(offers.length >= 0);
                            var i, offer, args = ['SetOffer', false, offers.length];
                            for (i = 0; i < offers.length; i++) {
                                offer = offers[i];
                                assert('sdp' in offer);
                                assert('id' in offer);
                                args.push(offer.sdp);
                                args.push(offer.id);
                            }
                            return pcAV.invoke.apply(pcAV, args);
                        }
                        //#endregion
                        //#region resumeAudioVideo
                        /**
                         * Activates (resumes) the AV conference call created in inactive state
                         * when a p2p call is escalated to a conference.
                         */
                        function resumeAudioVideo() {
                            var audioConfig = onHold() ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */;
                            mainVideoConfig = activeModalities.video ?
                                (onHold() ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */) :
                                0 /* NOT_PRESENT */;
                            var moreChannels = mainVideoConfig != 0 /* NOT_PRESENT */;
                            pcAV.invoke('SetMediaConfig', audioConfig, // audio configuration
                            mainVideoConfig, // main video configuration
                            moreChannels ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                            moreChannels ? 2 /* RECEIVE */ : 0 /* NOT_PRESENT */, // additional video config
                            0 /* NOT_PRESENT */); // panoVideoConfig
                        }
                        //#endregion
                        //#region setRenegotiationOffer
                        function setRenegotiationOffer(sdp) {
                            // LWA uses the empty string as the Content-ID for the SDP in the case of renegotiation
                            var id = '';
                            var audioConfig = onHold() ? 4 /* NO_ACTIVE_MEDIA */ :
                                3 /* BOTH */;
                            // When the remote participant adds video to an audio conversation, we auto-accept incoming
                            // video only. The local participant can turn their video on later via video.channels(0).isStarted(true).
                            var videoConfig = onHold() ? 4 /* NO_ACTIVE_MEDIA */ :
                                videoState() != Internal.Modality.State.Connected && /\bm=video\b/gmi.test(sdp) ? 2 /* RECEIVE */ :
                                    3 /* BOTH */;
                            log('Incoming SDP offer:\n' + sdp);
                            pcAV.invoke('SetAcceptedMedia', audioConfig, videoConfig);
                            pcAV.invoke('SetOffer', false, 1, sdp, id);
                        }
                        //#endregion
                        //#region setProvisionalAnswer
                        /**
                         * Sets the provisional SDP answer from the remote party
                         */
                        function setProvisionalAnswer(mediaAnswer, remoteEndpoint) {
                            var sdp = DataUri(mediaAnswer).data;
                            log('Provisional answer from the remote party:\n' + sdp);
                            pcAV.invoke('SetProvisionalAnswer', true, true, remoteEndpoint, sdp);
                        }
                        //#endregion
                        //#region setFinalAnswer
                        /**
                         * Sets the final SDP answer from the remote party
                         */
                        function setFinalAnswer(mediaAnswer, remoteEndpoint) {
                            var sdp = DataUri(mediaAnswer).data;
                            log('Final answer from the remote party:\n' + sdp);
                            pcAV.invoke('SetFinalAnswer', remoteEndpoint, sdp);
                        }
                        //#endregion
                        //#region completeNegotiation
                        /**
                         * Completes SDP negotiation
                         */
                        function completeNegotiation(eventStatus, reason) {
                            var errCode;
                            // the component may have already been cleaned up (the caller canceled the call
                            // while it was connecting)
                            if (pcAV) {
                                errCode = eventStatus == 'Success' ?
                                    Internal.MediaEnum.NegotiationStatus.NS_SUCCESS :
                                    (reason && reason.code == 'RemoteFailure') ?
                                        Internal.MediaEnum.NegotiationStatus.NS_REMOTE_INTERNAL_ERROR :
                                        Internal.MediaEnum.NegotiationStatus.NS_LOCAL_INTERNAL_ERROR;
                                pcAV.invoke('CompleteNegotiation', errCode);
                            }
                        }
                        //#endregion
                        //#region getStartAudioVideoUri
                        /**
                         * The first SDP offer is sent to the link given by this function.
                         */
                        function getStartAudioVideoLink() {
                            // if the AV modality is the 1-st modality in the conversation,
                            // send a request to the global startAudioVideo link
                            if (!rConversation)
                                return ucwa.get({ rel: 'communication' }).link('startAudioVideo');
                            // if this is an escalation from P2P to a conference, send the
                            // request to the escalation link
                            if (escalateAudioVideoUri)
                                return ucwa.get(escalateAudioVideoUri); // TODO: .link('self')?
                            // if the AV modality gets added to an existing conversation,
                            // send the request to its addAudioVideo link
                            return ucwa.send('GET', rConversation.link('audioVideo').href).then(function (rAV) {
                                return rAV.link('addAudioVideo');
                            });
                        }
                        //#endregion
                        return self;
                    }
                    return AudioVideoSession;
                })();
                Internal.AudioVideoSession = AudioVideoSession;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var map = Web.Utils.map;
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var contains = Web.Utils.contains;
                var DataUri = Web.Utils.DataUri;
                var HttpHeaders = Web.Utils.HttpHeaders;
                var parseMultipartRelatedResponse = Web.Stack.parseMultipartRelatedResponse;
                /**
                 * This model represents an audioVideoInvitation resource.
                 *
                 * An audioVideoInvitation resource may have the following form:
                 *
                 *      {
                 *          "rel": "audioVideoInvitation",
                 *          "bandwidthControlId": "...",
                 *          "direction": "Incoming",
                 *          "importance": "Normal",
                 *          "threadId": "...",
                 *          "state": "Connecting",
                 *          "privateLine": false,
                 *          "subject": "...",
                 *          "_links": {
                 *              "self": ...,
                 *              "to":
                 *              "conversation": ...,
                 *              "acceptWithAnswer": ...,
                 *              "sendProvisionalAnswer": ...,
                 *              "decline": ...,
                 *              "audioVideo": ...,
                 *              "mediaOffer": ...
                 *          },
                 *          "_embedded": {
                 *              "from": {
                 *                  "rel": "participant",
                 *                  ...
                 *              }
                 *          }
                 *      }
                 *
                 * @param {Resource} resource - A resource with rel=audioVideoInvitation.
                 * @param {UCWA} ucwa
                 *
                 * @member {Participant} from
                 * @member {Object[]} offers - An array of media offers.
                 *
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @method {Promise} decline
                 * @method {Promise} acceptWithAnswer(sdp, sessionContext)
                 *
                 * @created antonkh, Oct 2013
                 */
                function AudioVideoInvitation(options) {
                    var resource = options.resource, ucwa = options.ucwa, from = options.from;
                    check.equals(resource.rel, 'audioVideoInvitation');
                    var offers = getMediaOffers();
                    var self = {
                        resource: resource,
                        acceptWithAnswer: async(acceptWithAnswer),
                        decline: async(decline),
                        offers: offers,
                        from: from,
                        hasVideo: function () {
                            return contains(offers, function (offer) {
                                return /\bm=video\b/gmi.test(offer.sdp);
                            });
                        }
                    };
                    /**
                     * Reads the "mediaOffer" link and converts it to a collection SDPs.
                     *
                     * The "mediaOffer" link may have the following form:
                     *
                     *  data:multipart/alternative;charset=utf-8;boundary=e47d80f2,
                     *  --e47d80f2
                     *  Content-Type:+application/sdp
                     *  Content-ID:+<9544aa8a8ac9dfe08fad74893bd1095e@contoso.com>
                     *  Content-Disposition:+session;+handling=optional;+proxy-fallback
                     *
                     *  v=0
                     *  o=-+0+0+IN+IP4+127.0.0.1
                     *  s=session
                     *  ...
                     *
                     *  --e47d80f2
                     *  Content-Type:+application/sdp
                     *  Content-ID:+<cdfd6188fd977372c577873b03dd580d@contoso.com>
                     *  Content-Disposition:+session;+handling=optional
                     *
                     *  v=0
                     *  o=-+0+1+IN+IP4+127.0.0.1
                     *  s=session
                     *  c=IN+IP4+127.0.0.1
                     *  ...
                     *
                     *  --e47d80f2
                     */
                    function getMediaOffers() {
                        var href, dataUri, responses;
                        href = resource.relatedHref('mediaOffer');
                        if (!href)
                            return [];
                        dataUri = DataUri(href);
                        try {
                            responses = parseMultipartRelatedResponse({
                                status: null,
                                responseText: dataUri.data,
                                headers: 'Content-Type:multipart/related;boundary=' + dataUri.attributes.boundary
                            });
                            return map(responses, function (response) {
                                var headers = HttpHeaders(response.headers);
                                return {
                                    sdp: response.responseText,
                                    id: headers.get('Content-ID')
                                };
                            });
                        }
                        catch (error) {
                            // if the media offer is not a multipart/alternate-encoded
                            // set of SDPs, consider it as a single SDP
                            return [{
                                    sdp: dataUri.data,
                                    id: ''
                                }];
                        }
                    }
                    function acceptWithAnswer(sdp, sessionContext) {
                        var url = resource.link('acceptWithAnswer').href;
                        return ucwa.send('POST', url, {
                            headers: { 'Content-Type': 'application/sdp' },
                            query: { sessionContext: sessionContext },
                            data: sdp,
                            nobatch: true
                        });
                    }
                    function decline(reason) {
                        // We don't send media diagnostics header here because the plugin isn't loaded
                        // and its overkill to load the plugin just to retrieve media diag for a call that isn't connected
                        return ucwa.send('POST', resource.link('decline').href, {
                            data: { reason: reason },
                            nobatch: true
                        });
                    }
                    return self;
                }
                Internal.AudioVideoInvitation = AudioVideoInvitation;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="MediaAgent.d.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Media;
        (function (Media) {
            'use strict';
            var WeakMap = Web.Utils.WeakMap;
            /**
             *  Media Relay Manager for MediaAgent
             *
             *  @created Nov 2015
             *  @blame sosobov
             */
            var UcwaRelayManager = (function () {
                function UcwaRelayManager(ucwa) {
                    var rComm = ucwa.get({ rel: 'communication' });
                    var rMrasToken = ucwa.get(rComm.link('mediaRelayAccessToken').href);
                    var isInternal = !!ucwa.get({ rel: 'root' }).get('internal', false);
                    // relays implementing the standard IETF TURN protocol (used by WebRTC in Chrome/FF)
                    // TODO: remove, here just for testing
                    var turnRelays = [{
                            addresses: ['coturn-mdn.cloudapp.net'],
                            udpPort: 3478,
                            tcpPort: 3478,
                            username: '3Yn68DDj',
                            password: 'h02POuDfqYNc3RPa',
                            type: 'turn'
                        }];
                    // relays implementing MS TURN protocol (used by ORTC in Microsoft Edge) 
                    var msturnRelays = [];
                    var initPromise = ucwa.send('GET', { rel: 'mediaRelayAccessToken' }).then(function () {
                        var username = rMrasToken.get('userName');
                        var password = rMrasToken.get('password');
                        var mediaRelayLinks = rMrasToken.links('mediaRelay');
                        for (var _i = 0; _i < mediaRelayLinks.length; _i++) {
                            var link = mediaRelayLinks[_i];
                            var relay = ucwa.get(link.href);
                            if (!isInternal && relay.get('location') == 'Internet' ||
                                isInternal && relay.get('location') == 'Intranet') {
                                msturnRelays.push({
                                    addresses: [relay.get('host')],
                                    udpPort: relay.get('udpPort'),
                                    tcpPort: relay.get('tcpPort'),
                                    password: password,
                                    username: username,
                                    type: 'msturn'
                                });
                            }
                        }
                        // TODO: remove 
                        // an alternative test relay from Tallinn
                        // msturnRelays.push({
                        //    addresses: ['13.107.8.2'],
                        //    udpPort: 3478,
                        //    tcpPort: 473,
                        //    password: 'lbuXKVLnEsVwYDF0vRAYUtlysmU=',
                        //    username: 'AgAAJH6Ic+AB0dL0qIxA4WNskU2Mmd8id32lnFC/x0cAAAAAdoiQ9OL6qIkTiA33XKwuKlvUN5k=',
                        //    type: 'msturn'
                        // });
                    });
                    return {
                        queryRelaysAsync: function (type) {
                            if (type === void 0) { type = 'msturn'; }
                            return initPromise.then(function () { return type == 'turn' ? turnRelays : msturnRelays; });
                        }
                    };
                }
                return UcwaRelayManager;
            })();
            var ConsoleLogger = (function () {
                function ConsoleLogger() {
                    var fn = Media.log;
                    this.log = fn;
                    this.info = fn;
                    this.warn = fn;
                    this.error = fn;
                    this.debug = fn;
                    this.createChild = function (namespace, debug) { return this; };
                }
                return ConsoleLogger;
            })();
            var wm = new WeakMap();
            /**
             * Create or get the media agent for given stack instance
             * @param ucwa: UCWA
             */
            function getMediaAgent(ucwa) {
                if (!wm.has(ucwa)) {
                    var logger = new ConsoleLogger;
                    var relayManager = new UcwaRelayManager(ucwa);
                    var maContext = {
                        getLogger: function () { return logger; },
                        getRelayManager: function () { return relayManager; },
                        settings: {
                            debug: true
                        }
                    };
                    // TODO: should be moved out to DevicesManager
                    var deviceMgrCb = {
                        onDevicesChanged: function (device) { }
                    };
                    var ma = Media.MediaAgent.build(maContext, deviceMgrCb);
                    wm.set(ucwa, ma);
                }
                return wm.get(ucwa);
            }
            Media.getMediaAgent = getMediaAgent;
        })(Media = Web.Media || (Web.Media = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="../../media/webRtc/MediaAgentInit.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var guid = Web.Utils.guid;
                var check = Web.Utils.check;
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var values = Web.Utils.values;
                var filter = Web.Utils.filter;
                var foreach = Web.Utils.foreach;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var Task = Web.Utils.Task;
                var Event = Web.Utils.Event;
                var DataUri = Web.Utils.DataUri;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var EDoesNotExist = Web.Utils.EDoesNotExist;
                var EInvalidState = Web.Utils.EInvalidState;
                var ENotSupported = Web.Utils.ENotSupported;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var log = Web.Media.log;
                var PluginComponent = Web.Media.PluginComponent;
                /**
                 * Created by AudioVideoModality to represent an AudioVideo session (call). Can be either
                 * peer-to-peer or multi-party (conference). Only one such session exists when the call is
                 * established. When a P2P conversation is escalated to a conference, a second session
                 * linking this client to the conference is created. Once escalation succeeds, the second
                 * session replaces the original P2P session.
                 *
                 * Uses ORTC in Microsoft Edge or WebRTC in Chrome/FF
                 *
                 * @created Nov 2015
                 * @blame sosobov
                 */
                var WebRtcAudioVideoSession = (function () {
                    //#endregion
                    function WebRtcAudioVideoSession(options) {
                        var escalated = new Event(), self = {}, 
                        // devices = options.devices,
                        ucwa = options.ucwa, invitationContext = options.context, participants = options.participants, selfParticipant = options.selfParticipant, conversation = options.conversation, rConversation = options.rConversation, rAVInvitation = options.rAVInvitation, rAVRenegotiation, 
                        // During an outgoing call the server may set up more than one audioVideoSession, because
                        // the remote sip uri that we are calling may be signed in on more than one endpoint.
                        // Therefore we may see multiple pairs of audioVideoNegotiation - audioVideoSession events.
                        // Eventually, one of these sessions will be connected, others will be deleted. We keep
                        // track of these sessions in a dictionary of objects indexed by audioVideoSession hrefs,
                        // where these session objects may have properties:
                        //    resource:  audioVideoSession resource;
                        //    negotiated:  boolean (true if this session was successfully negotiated);
                        //    resumeAudioVideoUri:  present if this is an escalated conference session.
                        avSessions = {}, invitation = options.invitation, rInvitation = options.rInvitation, operationId = options.operationId || guid(), // provided by unittest or generated on the fly
                        sessionContext = options.sessionContext || guid(), // provided by unittest or generated on the fly
                        outAvRenegoOpIds = {}, // list of outgoing audioVideoRenegotiation operationId values
                        remoteUri, state = Property({
                            value: invitation || (rInvitation && rInvitation.rel == 'onlineMeetingInvitation') ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), audioState = Property({
                            value: isAudioInvitation() ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), videoState = Property({
                            value: isVideoInvitation() ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), activeSourceId, recentActiveSpeakers = {}, activeModalities = { audio: false, video: false }, mainVideoStream = new Internal.MediaStream({
                            type: Internal.MediaEnum.StreamType.MainRender
                        }), selfVideoStream = new Internal.MediaStream({
                            type: Internal.MediaEnum.StreamType.Preview
                        }), 
                        // remote video streams
                        videoStreams = Collection(), dfdStart, dfdAccept, 
                        // video config of the main media manager channel requested by either start or accept;
                        // is needed for setting the initial value of video channel's isStarted property for the
                        // self participant when start/accept is finished.
                        mainVideoConfig = 0 /* NOT_PRESENT */, 
                        // a unique id of this session - handy for debugging this session's
                        // server event subscription
                        modelId = random(), RemoteHoldState = {
                            Unknown: 0,
                            HoldOffered: 1,
                            HoldAnswered: 2,
                            HoldCompleted: 3,
                            ResumeOffered: 4,
                            ResumeAnswered: 5,
                            ResumeCompleted: 6
                        }, AudioVideoDirection = StringEnum('Inactive', // hold
                        'ReceiveOnly', 'SendOnly', 'SendReceive', // resume
                        'Unknown'), 
                        // A flag to track the renegotiation progress when a remote
                        // participant hold/resume the call in P2P mode.
                        //
                        // Steps to identify when remote participant hold/resume in P2P:
                        // 1. wait for audioVideo renegotiation offer.
                        // 2. if the offer has "a=inactive" field (for m=audio or m=video),
                        //    it is a HOLD request, mark it and expect ANSWER READY.
                        //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                        //    so mark it that way.
                        // 3. if answer has "a=inactive" field, it is a HOLD request, mark it
                        //    and expect "audioVideoRenegotiation completed".
                        //    Otherwise, it MIGHT be a RESUME request (but not necessarily),
                        //    so mark it that way.
                        // 4. when "audioVideoRenegotiation completed" event is received
                        //    with "Incoming" direction, progress the marker set in previous
                        //    steps; and expect CHANNEL_DIRECTION_CHANGED event.
                        // 5. if CHANNEL_DIRECTION_CHANGED event is received with direction
                        //    equal to NO_ACTIVE_MEDIA, and the HOLD marker was set in last
                        //    step, it completes a HOLD renegotiation, so we can set:
                        //    p.audioOnHold(true) for the remote participant.
                        // 6. if CHANNEL_DIRECTION_CHANGED event is received with direction
                        //    equal to other values (likely BOTH), and the RESUME marker was
                        //    set in last step, it completes a RESUME renegotiation, so set:
                        //    p.audioOnHold(false) for the remote participant.
                        remoteHoldState = RemoteHoldState.Unknown, escalateAudioVideoUri = options.escalateAudioVideoUri, fEscalation = isNotEmptyString(escalateAudioVideoUri);
                        assert(conversation);
                        // TODO: remove when every plugin call is replaced with JAMA 
                        var pcAV;
                        var mediaAgent = initMediaAgent(), mediaSession, mediaSessionCb;
                        //#region mute
                        // mutes/unmutes the audio channel or returns the mute status
                        var muted = Property({
                            value: false,
                            get: function () {
                                return muted();
                            },
                            set: function (val) {
                                // soft mute is applicable in conference mode
                                if (isConferencing()) {
                                    var rel = val ? 'muteAudio' : 'unmuteAudio', rAudio = selfParticipant[Internal.sInternal].rAudio;
                                    return Task.wait().then(function () {
                                        if (!rAudio.hasLink(rel))
                                            return ucwa.send('GET', rAudio.href);
                                    }).then(function () {
                                        return rAudio.link(rel).href;
                                    }).then(function (href) {
                                        return ucwa.send('POST', href);
                                    }).then(function () {
                                        return val;
                                    });
                                }
                                // TODO: jama: mute
                                return val;
                            }
                        });
                        //#endregion mute
                        //#region onHold
                        // holds/resumes audio/video or returns the onHold status
                        var onHold = Property({
                            value: false,
                            get: function () {
                                return onHold();
                            },
                            set: function (val) {
                                if (!isConferencing() && participants.size() > 0) {
                                    // the call is on hold when the remote puts on hold; so when
                                    // the local participant requests hold, the plugin will not
                                    // renegotiate, and no need to wait for renegotiation result
                                    if (participants(0).audio.isOnHold() && !onHold())
                                        return val;
                                }
                                // var audioConfig = val ? MediaEnum.MediaConfig.NO_ACTIVE_MEDIA : MediaEnum.MediaConfig.BOTH;
                                // var moreChannels = activeModalities.video && isConferencing();
                                mainVideoConfig = activeModalities.video ?
                                    (val ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */) :
                                    0 /* NOT_PRESENT */;
                                // TODO: jama: onHold 
                                return ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'audioVideoRenegotiation' },
                                    resource: function (r) {
                                        return r.get('direction') == 'Outgoing' && r.link('audioVideoSession').href in avSessions;
                                    }
                                }).then(function (event) {
                                    if (event.status == 'Success')
                                        return val;
                                    throw Exception('RenegotiationFailed', { reason: event.reason });
                                });
                            }
                        });
                        //#endregion onHold
                        options = null;
                        ucwa.event(onServerEvent);
                        state.changed(function (newState, reason, oldState) {
                            log('AudioVideoSession(' + modelId + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        audioState.changed(function (newState, reason, oldState) {
                            log('AudioVideoSession(' + modelId + ')::audioState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        videoState.changed(function (newState, reason, oldState) {
                            log('AudioVideoSession(' + modelId + ')::videoState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        state.when(Internal.Modality.State.Disconnected, function () {
                            audioState(Internal.Modality.State.Disconnected);
                            videoState(Internal.Modality.State.Disconnected);
                        });
                        // note that both reset* methods will be called with the "reason" parameter if the
                        // reason was set when property values were changed.
                        videoState.when(Internal.Modality.State.Disconnected, resetVideo);
                        audioState.when(Internal.Modality.State.Disconnected, resetAudio);
                        participants.removed(function (p) {
                            var id = p[Internal.sInternal].audioSourceId();
                            delete recentActiveSpeakers[id];
                            if (activeSourceId == id)
                                activeSourceId = -1;
                        });
                        setVideoRendering(selfVideoStream, true);
                        if (!isConferencing())
                            setVideoRendering(mainVideoStream, false);
                        //#region self
                        extend(self, {
                            state: state.asReadOnly(),
                            audioState: audioState.asReadOnly(),
                            videoState: videoState.asReadOnly(),
                            start: async(start),
                            stop: async(stop),
                            sendDtmf: sendDtmf,
                            escalated: escalated.observer,
                            muted: muted,
                            onHold: onHold,
                            selfVideoStream: selfVideoStream,
                            showParticipantVideo: showParticipantVideo,
                            removeParticipantVideo: removeParticipantVideo,
                            removeVideo: async(removeAllVideo)
                        });
                        if (invitation) {
                            // incoming call
                            extend(self, {
                                from: invitation.from,
                                accept: async(accept)
                            });
                        }
                        //#endregion
                        //#region private utilities
                        function initMediaAgent() {
                            mediaSessionCb = {
                                onNegotiationRequired: function () {
                                    var renegoHref = getRenegotiationsHref();
                                    if (renegoHref) {
                                        // A negotiated AudioVideoSession already exists, the client starts renegotiation -
                                        // expect an "audioVideoRenegotiation completed" event from UCWA after
                                        // sending renegotiation offer
                                        log('RENEGO REQUIRED');
                                        mediaSession.createOfferAsync().then(function (offer) {
                                            return sendRenegotiationOffer(offer, renegoHref);
                                        });
                                    }
                                    else {
                                        // usually caused by the call to configureModalitiesAsync in avs.start() 
                                        // we don't create an offer here because it is created in the start method
                                        log('NEGO REQUIRED');
                                    }
                                },
                                onDominantSpeakersChanged: function (speakers) { },
                                onActiveSpeakersChanged: function (speakers) { },
                                onSessionErrorOccurred: function (error) { }
                            };
                            return Web.Media.getMediaAgent(ucwa);
                        }
                        function enumcastMediaConfig(mc) {
                            // fortunately MediaConfig enumerates media in the same order:
                            // { NOT_PRESENT, SEND, RECEIVE, BOTH, NO_ACTIVE_MEDIA }
                            return ['', 'sendonly', 'recvonly', 'sendrecv', 'inactive'][mc];
                        }
                        function isConferencing() {
                            var convState = rConversation && rConversation.get('state', '');
                            // TODO: move Conversation.State to model.common.js and use enum here
                            return convState == 'Conferencing' || convState == 'Conferenced';
                        }
                        function getRenegotiationsHref() {
                            var renegoHref, negoSession, negotiated = filter(values(avSessions), function (session) {
                                return session.negotiated;
                            });
                            if (negotiated.length > 0) {
                                assert(negotiated.length == 1);
                                negoSession = negotiated[0];
                                renegoHref = negoSession.resumeAudioVideoUri ||
                                    negoSession.resource.link('renegotiations').href;
                                assert(renegoHref);
                            }
                            return renegoHref;
                        }
                        function setNegotiatedSession(sctx) {
                            foreach(avSessions, function (session) {
                                if (session.resource.get('sessionContext') == sctx)
                                    session.negotiated = true;
                            });
                        }
                        // switches video rendering on/off for 1:1 conversations when video starts/stops streaming 
                        // and when video container is set/changed/nulled
                        function setVideoRendering(videoStream, isPreview) {
                            videoStream._isFlowing.changed(function (val) {
                                if (val)
                                    showVideo(videoStream, isPreview);
                                else
                                    removeVideo(videoStream, isPreview);
                            });
                            videoStream.source.sink.container.changed(function (newVal, reason, oldVal) {
                                if (videoStream._isFlowing()) {
                                    if (oldVal)
                                        removeVideo(videoStream, isPreview);
                                    if (newVal)
                                        showVideo(videoStream, isPreview);
                                }
                            });
                        }
                        // called when we stop 1:1 video (including escalation to a meeting)
                        function removeAllVideo() {
                            removeVideo(mainVideoStream, false);
                            removeVideo(selfVideoStream, true);
                            mainVideoStream._isFlowing(false);
                            selfVideoStream._isFlowing(false);
                            selfParticipant[Internal.sInternal].setVideoStream(null);
                            if (participants.size() > 0) {
                                participants(0)[Internal.sInternal].setVideoStream(null);
                                participants(0)[Internal.sInternal].setVideoStarted(void 0);
                            }
                        }
                        function resetVideo(reason) {
                            participants.each(function (p) {
                                // reset the participant video stream source to an empty stream
                                p[Internal.sInternal].setVideoStream(null);
                                if (!isConferencing())
                                    p[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                            });
                            mainVideoStream._isFlowing(false);
                            selfVideoStream._isFlowing(false);
                            videoStreams.empty();
                            selfParticipant[Internal.sInternal].setVideoStream(null);
                            if (reason !== Internal.sEscalation)
                                selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                        }
                        function resetAudio() {
                            if (!isConferencing() && participants(0))
                                participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                            // The audio state of self participant is replaced by AudioVideoModality::audioState 
                            // in the conversation ctor, so resetting it as we do in resetVideo is useless:
                            // if (reason !== sEscalation)
                            //    selfParticipant[sInternal].audioState(Modality.State.Disconnected);
                        }
                        // function enumcastStreamState(meState) {
                        //   var ss = MediaEnum.StreamState,
                        //       state;
                        //   switch (meState) {
                        //       case MediaEnum.MediaStreamEvent.STREAM_STARTED: state = ss.Started; break;
                        //       case MediaEnum.MediaStreamEvent.STREAM_ACTIVE: state = ss.Active; break;
                        //       case MediaEnum.MediaStreamEvent.STREAM_INACTIVE: state = ss.Inactive; break;
                        //       case MediaEnum.MediaStreamEvent.STREAM_STOPPED: state = ss.Stopped; break;
                        //   }
                        //   return state;
                        // }
                        // Check if the SDP offer/answer contains a=inactive field,
                        // which indicates it is a renegotiation triggered when a
                        // participant holds a call.
                        function isHoldRequest(sdp) {
                            return /\ba=inactive\b/gmi.test(sdp);
                        }
                        function isAudioInvitation() {
                            return invitation && !invitation.hasVideo() ||
                                rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                    conversation.meeting.availableModalities.audio() &&
                                    !conversation.meeting.availableModalities.video();
                        }
                        function isVideoInvitation() {
                            return invitation && invitation.hasVideo() ||
                                rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                                    conversation.meeting.availableModalities.video();
                        }
                        //#endregion
                        //#region public methods
                        //#region start
                        /**
                         * Starts an outgoing Audio/Video call
                         *
                         *  @param {String} remoteUri
                         *  @param {MediaEnum.MediaConfig} audioConfig
                         *  @param {MediaEnum.MediaConfig} mainVideoConfig
                         *  @param {Object} [video]
                         *
                         *  @returns {Promise}
                         *
                         *  Starting a P2P audio call
                         *  - Generates an SDP offer
                         *  - Sends a POST request to startAudioVideo link with the SDP offer.
                         *  - Gets an "audioVideoInvitation started" event from UCWA.
                         *  - Gets an "audioVideoNegotiation started" event from UCWA with a provisional SDP answer.
                         *  - Ignores the provisional answer
                         *  - Gets an "audioVideoSession added" event.
                         *  - Gets an "audioVideoNegotiation completed" event with a final SDP answer.
                         *  - Sets the final answer
                         *  - Gets a "audioVideoInvitation completed" event from UCWA.
                         *  - Completes negotiation.
                         *
                         *  Joining an audio conference call the client follows the same sequence with one exception:
                         *  there is no initial negotiation - all "audioVideoNegotiation" events are absent.
                         *
                         *  If the client calls an invalid sip uri, it receives a single "audioVideoInvitation
                         *  completed" event with failure status and appropriate error code.
                         */
                        function start(options) {
                            // TODO: remove when video is implemented
                            if (options.video)
                                return new Task().reject('video not implemented').promise;
                            // prohibit start of audio or video when that modality is already started
                            if ((options.mainVideoConfig == 3 /* BOTH */ && activeModalities.video) ||
                                (options.mainVideoConfig == 0 /* NOT_PRESENT */ &&
                                    options.audioConfig == 3 /* BOTH */ && activeModalities.audio))
                                return Task.wait('already started');
                            check.state(onHold(), false);
                            var audioConfig = options.audioConfig, previewContainer = options.video && options.video.previewContainer, videoContainer = options.video && options.video.container, startsVideo = options.mainVideoConfig != 0 /* NOT_PRESENT */;
                            mainVideoConfig = options.mainVideoConfig;
                            // start is allowed to be called twice only when the first call starts audio,
                            // and the second call adds video. So a different options.remoteUri for adding
                            // video does not make sense
                            remoteUri = remoteUri || options.remoteUri;
                            options = null;
                            check.state(state(), [
                                Internal.Modality.State.Disconnected,
                                Internal.Modality.State.Notified,
                                Internal.Modality.State.Connected
                            ]);
                            if (state() == Internal.Modality.State.Disconnected ||
                                state() == Internal.Modality.State.Notified) {
                                state(Internal.Modality.State.Connecting);
                            }
                            // to keep parity with Skype not only we need to set the local participant AV state
                            // in a 1:1 call but also to fake the remote participant AV state; and we always check
                            // for the remote participant existence because the call can be started with the
                            // empty participants collection by specifying the remote sip uri.
                            if (audioState() == Internal.Modality.State.Disconnected ||
                                audioState() == Internal.Modality.State.Notified) {
                                audioState(Internal.Modality.State.Connecting);
                                if (!isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                            }
                            if (videoState() == Internal.Modality.State.Disconnected && startsVideo ||
                                videoState() == Internal.Modality.State.Notified) {
                                videoState(Internal.Modality.State.Connecting);
                                if (!isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                            }
                            dfdStart = new Task('starting a call');
                            var promise = Task.run(function () {
                                mediaSession = mediaAgent.createSession(mediaSessionCb, guid(), {
                                    isRemoteClientLync: true,
                                    isConference: isConferencing()
                                });
                                return mediaSession.configureModalitiesAsync({
                                    audio: enumcastMediaConfig(audioConfig)
                                });
                            }).then(function () {
                                // var moreChannels = mainVideoConfig != MediaEnum.MediaConfig.NOT_PRESENT && isConferencing();
                                // hook up the preview video stream - this will retain the video container if it was set for
                                // self participant.
                                // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                                // receive another invitiation (it's a renegotiation of an established AV connection), so
                                // we won't have a chance to call accept method again.
                                selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                                if (videoContainer)
                                    mainVideoStream.source.sink.container(videoContainer);
                                if (previewContainer)
                                    selfVideoStream.source.sink.container(previewContainer);
                                if (audioState() == Internal.Modality.State.Connecting && !isConferencing() && participants.size() > 0)
                                    participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Ringing);
                                return mediaSession.createOfferAsync();
                            }).then(function (offer) {
                                return sendOffer([{ sdp: offer, id: 1 }]);
                            }).then(function () {
                                state(Internal.Modality.State.Connected);
                                return dfdStart.resolve().promise;
                            }).catch(function (error) {
                                if (!rAVInvitation) {
                                }
                                else if (rAVInvitation.hasLink('cancel')) {
                                    // if the AV invitation was sent and the "audioVideoInvitation started" event was received we have
                                    // the cancel link and we can terminate the call here.
                                    ucwa.send('POST', rAVInvitation.link('cancel').href, { nobatch: true });
                                }
                                else {
                                }
                                // if the caller hangs up by canceling the promise returned by this method
                                if (dfdStart.state() == 'pending')
                                    dfdStart.reject(error);
                                state(Internal.Modality.State.Disconnected, error);
                                audioState(Internal.Modality.State.Disconnected);
                                videoState(Internal.Modality.State.Disconnected);
                                throw error;
                            });
                            return Task.waitAll([promise, dfdStart.promise]);
                        }
                        //#endregion
                        //#region accept
                        /**
                         * Accepts an incoming Audio/Video invitation.
                         *
                         * @param {Dictionary} [video] - The video window container holder.
                         * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                         *
                         * @returns {Promise}
                         *
                         * Accepting an incoming call invitation:
                         *
                         *  - Creates a media session and sets the SDP offer from the remote party.
                         *  - Generates an SDP answer.
                         *  - Sends a POST audioVideoInvitation/acceptWithAnswer with the generated SDP answer.
                         *  - Receives an "audioVideoinvitation completed" event from UCWA
                         *  - Completes negotiation.
                         *  - Receives an "audioVideoRenegotiation started" event with a new SDP offer from the remote party.
                         *  - Generates an SDP answer.
                         *  - Sends a POST audioVideoRenegotiation/answer with the SDP answer.
                         *  - Receives a "audioVideoRenegotiation completed" event from UCWA.
                         *  - Completes renegotiation.
                         */
                        function accept(options) {
                            assert(invitation, 'This is an outgoing call, so it cannot be "accepted"');
                            assert(!isConferencing(), 'This is a conference'); // accept is used in P2P only
                            assert(participants.size() == 1, 'The caller is not in participants');
                            // TODO: remove when video is implemented
                            assert(!options.video, 'video not implemented');
                            var video = options && options.video, videoContainer = video && video.container, previewContainer = video && video.previewContainer;
                            mainVideoConfig = video ? 3 /* BOTH */ :
                                2 /* RECEIVE */;
                            state(Internal.Modality.State.Connecting);
                            audioState(Internal.Modality.State.Connecting);
                            participants(0)[Internal.sInternal].audioState(Internal.Modality.State.Connecting);
                            if (invitation.hasVideo()) {
                                videoState(Internal.Modality.State.Connecting);
                                participants(0)[Internal.sInternal].videoState(Internal.Modality.State.Connecting);
                            }
                            dfdAccept = new Task('accepting a call');
                            var promise = Task.run(function () {
                                // the caller has already hung up
                                if (state() == Internal.Modality.State.Disconnected)
                                    throw Internal.EInvitationFailed(state.reason);
                                // hook up the preview video stream - this will retain the video container if it was set for
                                // self participant.
                                // NB: we need to do it even if it's just an audio call. If the video is added later we won't
                                // receive another invitiation (it's a renegotiation of an established AV connection), so
                                // we won't have a chance to call accept method again.
                                selfParticipant[Internal.sInternal].setVideoStream(selfVideoStream);
                                if (videoContainer)
                                    mainVideoStream.source.sink.container(videoContainer);
                                if (previewContainer)
                                    selfVideoStream.source.sink.container(previewContainer);
                                mediaSession = mediaAgent.createSession(mediaSessionCb, guid(), {
                                    isRemoteClientLync: true,
                                    isConference: isConferencing()
                                });
                                return mediaSession.processOfferAsync(invitation.offers[0].sdp);
                            }).then(function (modalities) {
                                return mediaSession.configureModalitiesAsync(modalities);
                            }).then(function () {
                                return mediaSession.createAnswerAsync(false);
                            }).then(function (answer) {
                                return invitation.acceptWithAnswer(answer, sessionContext);
                            }).catch(function (error) {
                                state(Internal.Modality.State.Disconnected);
                                audioState(Internal.Modality.State.Disconnected);
                                videoState(Internal.Modality.State.Disconnected);
                                cleanup();
                                if (dfdAccept.state() == 'pending')
                                    dfdAccept.reject(error);
                                throw error;
                            });
                            return Task.waitAll([promise, dfdAccept.promise]);
                        }
                        //#endregion
                        //#region stop
                        /**
                         * Stops Audio/Video session
                         *
                         * @param {String} [reason] - if equals 'video', only video is stopped, if omitted both audio and video are stopped.
                         */
                        function stop(reason) {
                            // cancel start if stop is called during connecting
                            if (state() == Internal.Modality.State.Connecting) {
                                dfdStart.promise.cancel();
                                return new Task().resolve().promise;
                            }
                            var task = new Task;
                            if (reason == 'video') {
                                if (isConferencing()) {
                                    participants.each(function (p) {
                                        p.video.channels(0).isStarted(false);
                                    });
                                }
                                // var audioConfig = onHold() ?
                                //    MediaEnum.MediaConfig.NO_ACTIVE_MEDIA : MediaEnum.MediaConfig.BOTH;
                                mainVideoConfig = 0 /* NOT_PRESENT */;
                                // TODO: jama: turn off video
                                task.resolve();
                            }
                            else if (reason === Internal.sEscalation) {
                                // if escalation do cleanup only
                                cleanup(reason);
                                task.resolve();
                            }
                            else {
                                // if not escalation then it is a call getting stopped explicitly 
                                task.from(ucwa.send('GET', rConversation.link('audioVideo').href).then(function (rAudioVideo) {
                                    return ucwa.send('POST', rAudioVideo.link('stopAudioVideo').href, { query: { reason: 'UserInitiatedAction' } });
                                }).finally(function () { return cleanup(reason); }));
                            }
                            return task.promise;
                        }
                        //#endregion
                        //#region sendDtmf
                        /**
                         * Sends a DTMF tone
                         *
                         * @param {String} tone - A DTMF tone from MediaEnum.DtmfTone enumeration
                         * @returns {String} - The sent tone
                         */
                        function sendDtmf(tone) {
                            if (isNotEmptyString(tone)) {
                                tone = tone.trim().toLowerCase();
                                tone = tone.substr(0, 1).toUpperCase() + tone.substr(1);
                                if (Internal.MediaEnum.DtmfTone[tone] !== undefined) {
                                    // TODO: jama: send dtmf
                                    return tone;
                                }
                            }
                            throw EInvalidArgument('tone', 'out of range');
                        }
                        //#endregion
                        //#region showParticipantVideo
                        function showParticipantVideo(participant) {
                            var isFound = false, videoStream, dfd;
                            if (videoState() != Internal.Modality.State.Connected)
                                throw EInvalidState(videoState(), Internal.Modality.State.Connected);
                            if (onHold())
                                throw Exception('OnHold');
                            if (participant[Internal.sInternal].isLocal()) {
                                // undefined means that we just started video, no need to renegotiate
                                if (participant.video.channels(0).isStarted() === false) {
                                    mainVideoConfig = 3 /* BOTH */;
                                }
                                return new Task().resolve().promise;
                            }
                            else if (isConferencing()) {
                                // find available stream
                                if (!mainVideoStream._isAttached()) {
                                    videoStream = mainVideoStream;
                                }
                                else {
                                    videoStreams.each(function (vs) {
                                        if (!isFound && !vs._isAttached()) {
                                            videoStream = vs;
                                            isFound = true;
                                        }
                                    });
                                }
                                if (!videoStream) {
                                    log('Cannot find available stream');
                                    throw EDoesNotExist('No available stream');
                                }
                                participant[Internal.sInternal].setVideoStream(videoStream);
                                videoStream._isAttached(true);
                                dfd = showVideo(videoStream, false).then(function () {
                                    // TODO: jama: video subscribe        
                                    // pcAV.invoke('Subscribe', videoStream._id(), participant[sInternal].videoSourceId());
                                }).then(function () {
                                    var sink = videoStream.source.sink;
                                    sink._c(sink.container.changed(function (newVal, reason, oldVal) {
                                        if (oldVal)
                                            removeParticipantVideo(participant).then(function () {
                                                if (newVal)
                                                    showParticipantVideo(participant);
                                                else
                                                    participant[Internal.sInternal].setVideoStarted(false);
                                            });
                                    }));
                                });
                            }
                            else {
                                dfd = new Task().reject(ENotSupported('cannot start remote video in 1:1 conversation')).promise;
                            }
                            return dfd;
                        }
                        //#endregion showParticipantVideo
                        //#region removeParticipantVideo
                        function removeParticipantVideo(participant) {
                            var dfd;
                            if (onHold())
                                throw Exception('OnHold');
                            if (participant[Internal.sInternal].isLocal()) {
                                mainVideoConfig = 2 /* RECEIVE */;
                                // TODO: jama: remove video
                                return new Task().resolve().promise;
                            }
                            else if (isConferencing()) {
                                dfd = Task.wait(null, 'sync').then(function () {
                                    // NB: this is a sourced stream
                                    var videoStream = participant.video.channels(0).stream;
                                    var sink = videoStream.source.sink;
                                    if (sink._c())
                                        sink._c().dispose();
                                    if (videoStream._isAttached()) {
                                        // TODO: jama: unsubscribe
                                        removeVideo(videoStream, false);
                                        videoStream._isAttached(false);
                                        participant[Internal.sInternal].setVideoStream(null);
                                    }
                                });
                            }
                            else {
                                // in 1:1 we can't remove remote video without stopping video altogether
                                dfd = new Task().reject(ENotSupported('cannot remove remote video in 1:1 conversation')).promise;
                            }
                            return dfd;
                        }
                        //#endregion removeParticipantVideo
                        //#endregion public methods
                        //#region cleanup
                        // Unsubscribes from server and terminates the media session
                        function cleanup(reason) {
                            var cDisconnected = Internal.Modality.State.Disconnected;
                            ucwa.event.off(onServerEvent);
                            // TODO: jama: 
                            // removeAllVideo();
                            if (mediaSession) {
                                mediaSession.terminate();
                                mediaSession = null;
                            }
                            participants.each(function (p) {
                                // reset the participant video stream source to an empty stream
                                p[Internal.sInternal].setVideoStream(null);
                                if (!isConferencing()) {
                                    p[Internal.sInternal].audioState(cDisconnected);
                                    p[Internal.sInternal].videoState(cDisconnected);
                                }
                            });
                            audioState(cDisconnected /*, reason*/);
                            videoState(cDisconnected, reason);
                        }
                        //#endregion
                        //#region videoWindow
                        /**
                         * Creates a video window and anchors it in the parent DOM element
                         *
                         * The whole area of the parent element will be occupied by the video. Video preview window sized to
                         * 1/3rd of the remote window and is placed in the lower-right corner. Currently, its flicker makes
                         * the preview unusable
                         */
                        function showVideo(vs, isPreview) {
                            var sink = vs.source.sink;
                            if (vs._id() && sink.container()) {
                                // TODO: this is a temporary check to avoid repeated window creation
                                // when this method is called more than once ('participantVideo updated')
                                if (sink._state() == PluginComponent.State.Unloaded) {
                                    return sink._init().then(function () {
                                        // TODO: jama: setVideoWindow
                                    });
                                }
                            }
                        }
                        /**
                         * Removes the video window from the parent DOM element
                         */
                        function removeVideo(vs, isPreview) {
                            var sink = vs.source.sink;
                            if (vs._id() && sink._videoWindow()) {
                                // TODO: jama: removeVideoWindow
                                sink._uninit();
                            }
                        }
                        //#endregion videoWindow
                        //#region server events
                        function onServerEvent(event) {
                            var id = event.target.rel + ' ' + event.type;
                            var handler = ucwaEventHandlers[id];
                            if (handler) {
                                // debugger; // this is to let debug the handler of the event
                                handler(event.status, event.resource, event);
                            }
                        }
                        var ucwaEventHandlers = {
                            // this is the first event received in any AV call setup (except calling an invalid SIP uri,
                            // in which case UCWA sends the 'audioVideoInvitation completed' event only).
                            'audioVideoInvitation started': function (status, resource) {
                                // set the invitation resource for the outgoing AV session (for the incoming call
                                // audioVideoSession is initialized with the received invitation resource)
                                if (resource.get('direction') == 'Outgoing' &&
                                    resource.get('sessionContext') == sessionContext) {
                                    // if the user canceled the call before we received this event terminate the call
                                    // on the server and unload the AV component.
                                    if (state() == Internal.Modality.State.Disconnected) {
                                        if (resource.hasLink('cancel'))
                                            ucwa.send('POST', resource.link('cancel').href, { nobatch: true });
                                        cleanup();
                                    }
                                    else {
                                        rAVInvitation = resource;
                                        dfdStart.status('awaiting "audioVideoNegotiation started or completed" event from UCWA');
                                    }
                                }
                            },
                            // this event is received if we started an outgoing AV call as the first conversation modality
                            // using the global startAudioVideo link
                            'conversation added': function (status, resource) {
                                if (resource.get('threadId') == conversation.threadId())
                                    rConversation = resource;
                            },
                            // this event is received during outgoing P2P AV call setup (early media?)
                            'audioVideoNegotiation started': function (status, resource, event) {
                                if (event.sender.href == rAVInvitation.href) {
                                    setProvisionalAnswer(resource.link('mediaProvisionalAnswer').href, resource.get('remoteEndpoint'));
                                    dfdStart.status('awaiting "audioVideoNegotiation completed" event from UCWA');
                                }
                            },
                            // this event is received during outgoing P2P or conference call setup.
                            // If the negotiation completed successfully the event resource contains session context,
                            // a link to matching audioVideoSession and the remoteEndpoint of that session.
                            // If the call was declined or not answered we have negotiation href only.
                            'audioVideoNegotiation completed': function (status, resource, event) {
                                var href;
                                if (event.sender.href == rAVInvitation.href) {
                                    switch (status) {
                                        case 'Success':
                                            // "audioVideoNegotiation completed" may arrive before the corresponding
                                            // "audioVideoSession added" event when the call is forwarded to voice mail.
                                            // in this case we create an entry in avSessions and expect to fill it out
                                            // after the session added event arrives.
                                            href = resource.link('audioVideoSession').href;
                                            avSessions[href] = avSessions[href] || {};
                                            avSessions[href].negotiated = true;
                                            setFinalAnswer(resource.link('mediaAnswer').href, resource.get('remoteEndpoint'));
                                            dfdStart.status('awaiting "audioVideoInvitation completed" event from UCWA');
                                            break;
                                        case 'Failure':
                                            if (event.reason.subcode != 'Ended' && event.reason.subcode != 'ConnectedElsewhere')
                                                dfdStart.status(event.reason && event.reason.message);
                                            break;
                                    }
                                }
                            },
                            // during an outgoing call the server may set up more than one audioVideoSession, because
                            // the remote sip uri that we are calling may be signed in on more than one endpoint.
                            // Also, if the remote party does not accept the call the UCWA server may redirect the
                            // client to a media server so that the client may leave a voice mail; during this process
                            // the UCWA server will create another audioVideoSession and delete the original session.
                            // The next two handlers keep track of audioVideoSessions.
                            'audioVideoSession added': function (status, resource) {
                                var href = resource.href;
                                if (resource.get('sessionContext') == sessionContext) {
                                    avSessions[href] = avSessions[href] || {};
                                    avSessions[href].resource = resource;
                                }
                            },
                            'audioVideoSession deleted': function (status, resource, event) {
                                delete avSessions[event.target.href];
                                // this event is the only indication of a failed escalation; we need to notify
                                // AudioVideoModality so it can force the cleanup of this session (technically there
                                // a "participantInvitation completed" event with code == ServiceFailure and
                                // subcode == EscalationFailed but it is received by the client that issued the
                                // invitation only).
                                if (fEscalation && isEmptyObject(avSessions)) {
                                    escalated.fire('failure');
                                    fEscalation = false;
                                }
                            },
                            // this event is received during any AV call setup
                            'audioVideoInvitation completed': function (status, resource, event) {
                                // check for rAVInvitation is needed because this event may arrive before we
                                // even get a response to startAudioVideo post if we call an invalid SIP uri,
                                // so rAVInvitation may be undefined.
                                // Note that completion of an outgoing invitation is handled by sendOffer method
                                if (rAVInvitation && rAVInvitation.href == resource.href &&
                                    resource.get('direction') == 'Incoming') {
                                    if (status == 'Success') {
                                        try {
                                            // there are no audioVideoNegotiation events in the incoming P2P call setup,
                                            // so we set negotiated flag for the cached audioVideoSession here
                                            setNegotiatedSession(resource.get('sessionContext'));
                                            completeNegotiation(status, event.reason);
                                            // if AV is added by a remote participant in a 1:1 conversation which already
                                            // has another modality (messaging) then "participantAudio/Video added" events
                                            // arrive before "audioVideoInvitation started" event, i.e. before this
                                            // AudioVideoSession object exists. So we need to set the AV properties of the
                                            // remote participant here:
                                            // TODO: check if they were not set before : Accepting the AV invitation that created the call
                                            assert(!isConferencing());
                                            var p = participants(0);
                                            if (p) {
                                                p[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                                if (videoState() == Internal.Modality.State.Connected) {
                                                    p[Internal.sInternal].setVideoStream(mainVideoStream);
                                                    p[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                            }
                                            dfdAccept.resolve();
                                            state(Internal.Modality.State.Connected);
                                        }
                                        catch (error) {
                                            dfdAccept.reject(error);
                                            state(Internal.Modality.State.Disconnected);
                                        }
                                    }
                                    else {
                                        // the caller (remote party) hung up while the call setup was not completed.
                                        if (dfdAccept)
                                            dfdAccept.reject(event.reason);
                                        state(Internal.Modality.State.Disconnected, event.reason);
                                    }
                                }
                            },
                            'audioVideoRenegotiation started': function (status, resource) {
                                if (resource.link('audioVideoSession').href in avSessions) {
                                    if (resource.get('direction') == 'Incoming') {
                                        var sdp = DataUri(resource.link('mediaOffer').href).data;
                                        if (!isConferencing() && participants.size() > 0) {
                                            remoteHoldState = isHoldRequest(sdp) ?
                                                RemoteHoldState.HoldOffered : RemoteHoldState.ResumeOffered;
                                        }
                                        rAVRenegotiation = resource;
                                        setRenegotiationOffer(sdp);
                                    }
                                    else if (dfdStart && dfdStart.state() == 'pending') {
                                        // this is an outgoing renegotiation caused by the second start() call
                                        // to add video to an audio conversation
                                        dfdStart.status('Waiting for audioVideoRenegotiation completed event');
                                    }
                                }
                            },
                            'audioVideoRenegotiation completed': function (status, resource, event) {
                                var href = resource.link('audioVideoSession').href;
                                if (href in avSessions) {
                                    if (resource.get('direction') == 'Outgoing') {
                                        assert(resource.get('operationId') in outAvRenegoOpIds);
                                        delete outAvRenegoOpIds[resource.get('operationId')];
                                        if (status == 'Success') {
                                            avSessions[href].renegotiated = true;
                                            setFinalAnswer(resource.link('mediaAnswer').href, avSessions[href].resource.get('remoteEndpoint'));
                                        }
                                        completeNegotiation(status, event.reason);
                                        if (dfdStart && dfdStart.state() == 'pending') {
                                            // this is an outgoing renegotiation caused by the second start() call
                                            // to add video to an audio conversation
                                            if (status == 'Success')
                                                dfdStart.resolve();
                                            else
                                                dfdStart.reject();
                                        }
                                    }
                                    else {
                                        // the renegotiation may be in response to remote participant hold/resume
                                        if (!isConferencing()) {
                                            if (remoteHoldState == RemoteHoldState.HoldAnswered)
                                                remoteHoldState = RemoteHoldState.HoldCompleted;
                                            else if (remoteHoldState == RemoteHoldState.ResumeAnswered)
                                                remoteHoldState = RemoteHoldState.ResumeCompleted;
                                        }
                                        completeNegotiation(status, event.reason);
                                    }
                                }
                            },
                            'audioVideo updated': function (status, resource, event) {
                                if (rAVInvitation && resource.href == rAVInvitation.link('audioVideo').href) {
                                    if (resource.get('state') == 'Disconnected') {
                                        if (rAVInvitation.get('state') == 'Connected') {
                                            // This is our chance to clean up the established call that is terminated by
                                            // the remote party. The local party terminates the established call via modality.stop()
                                            // and hang-ups by either party during call setup are processed by audioVideoInvitation
                                            // started/completed event handlers.
                                            cleanup();
                                            // setting this modality state to disconnected will cause its removal from
                                            // the conversation
                                            state(Internal.Modality.State.Disconnected);
                                        }
                                    }
                                    else if (resource.get('state') == 'Connected' &&
                                        event.reason && event.reason.subcode == 'SessionSwitched' &&
                                        resource.link('audioVideoSession').href in avSessions) {
                                        // this is the escalation confirmation, i.e. this AV session replaced the
                                        // original P2P AV session
                                        escalated.fire('success');
                                        fEscalation = false;
                                    }
                                }
                            },
                            // participantAudio/Video added/deleted events for a localParticipant are used to
                            // track active modalities of this client
                            'participantAudio added': onParticipantAudio,
                            'participantAudio updated': onParticipantAudio,
                            'participantAudio deleted': onParticipantAudio,
                            'participantVideo added': onParticipantVideo,
                            'participantVideo updated': onParticipantVideo,
                            'participantVideo deleted': onParticipantVideo,
                            'escalateAudio deleted': function (status, resource, event) {
                                if (event.target.href == escalateAudioVideoUri)
                                    escalateAudioVideoUri = null;
                            },
                            // these events are fired in the later phase of the escalation when the setup of our inactive AV call
                            // to a conference is finished and we may activate (resume) it.
                            'resumeAudio added': onResumeAudioVideoAdded,
                            'resumeAudioVideo added': onResumeAudioVideoAdded,
                            'resumeAudio deleted': onResumeAudioVideoDeleted,
                            'resumeAudioVideo deleted': onResumeAudioVideoDeleted
                        };
                        // returns a participant object from a participants collection
                        function getParticipant(href) {
                            var participant = find(participants(), function (p) { return p[Internal.sHref] == href; });
                            if (participant)
                                return participant;
                            // shortcut for a 1:1 conversation with a participant added to the conversation beforehand
                            //
                            // The check for participant size is needed because if the AV conversation is started not with the
                            // participant from a person model but using the sip uri as a parameter, we would have to rely on
                            // "participant added" event for the remote guy to become a member of participants collection.
                            // If miraculously this event arrives after "participantAudio/Video added" we would have an empty
                            // participants collection here.
                            if (!isConferencing() && participants.size() == 1)
                                return participants(0);
                            // "participantAudio/Video added" event arrives right after "participant added" event. If the
                            // participant was added to the conversation's participant collection using its contact href,
                            // the "participant added" event handler is doing another server lookup to match that contact href
                            // to the participant href. So we can't find that participant here either and we need to do the
                            // same lookup.
                            return ucwa.send('GET', href).then(function (r) {
                                return getParticipant(r.link('contact').href);
                            });
                        }
                        function isInMediaRoster(participant) {
                            var p = participant[Internal.sInternal];
                            return pcAV && p.isInMediaRoster[pcAV.id()];
                        }
                        function updateMediaRoster(participant, type) {
                            try {
                                var method = type == 'add' ? 'AddParticipantInfo' :
                                    type == 'remove' ? 'RemoveParticipantInfo' :
                                        type == 'update' ? 'UpdateParticipantInfo' :
                                            assert(false);
                                var p = participant[Internal.sInternal];
                                // pcAV may not exist yet when when we join the meeting which participants are already on the AV call.
                                // In this case 'participantVideo added' events for such participants may come before we finish
                                // joining the meeting so we have not loaded the plugin AVComponent.
                                pcAV.invoke(method, p.audioSourceId(), p.videoSourceId(), -1);
                                p.isInMediaRoster[pcAV.id()] = type != 'remove';
                                return true;
                            }
                            catch (err) {
                                log('Media Roster ERROR: ' + err);
                                return false;
                            }
                        }
                        // event handler for "participantAudio added/updated/deleted in participant|localParticipant" events
                        //  - tracks session audio state (on/off) and participant audio state.
                        function onParticipantAudio(status, resource, event) {
                            var scope = event['in'];
                            if (event.sender.href == rConversation.href && scope) {
                                if (scope.rel == 'localParticipant') {
                                    switch (event.type) {
                                        case 'added': // signal for the initial AV session
                                        case 'updated':
                                            if (isConferencing())
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                            activeModalities.audio = true;
                                            audioState(Internal.Modality.State.Connected);
                                            break;
                                        case 'deleted':
                                            activeModalities.audio = false;
                                            audioState(Internal.Modality.State.Disconnected);
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                }
                                else if (scope.rel == 'participant') {
                                    Task.wait(getParticipant(scope.href)).then(function (participant) {
                                        switch (event.type) {
                                            case 'added':
                                            case 'updated':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    // In conference mode, the indication of a remote
                                                    // participant hold/resume or mute/unmute is
                                                    // "participantAudio updated" event. We need to
                                                    // reload "participantAudio" resource and set the
                                                    // properties accordingly
                                                    if (event.type == 'updated') {
                                                        ucwa.send('GET', event.target.href).then(function (r) {
                                                            if (r.has('audioDirection')) {
                                                                participant[Internal.sInternal].audioOnHold(r.get('audioDirection') ==
                                                                    AudioVideoDirection.Inactive);
                                                            }
                                                            if (r.has('audioMuted'))
                                                                participant[Internal.sInternal].audioMuted(r.get('audioMuted'));
                                                        });
                                                    }
                                                }
                                                participant[Internal.sInternal].audioState(Internal.Modality.State.Connected);
                                                break;
                                            case 'deleted':
                                                participant[Internal.sInternal].audioState(Internal.Modality.State.Disconnected);
                                                break;
                                            default:
                                                assert(false, 'unexpected event type');
                                        }
                                    });
                                }
                            }
                        }
                        // event handler for "participantVideo added/updated/deleted in participant|localParticipant" events
                        //  - tracks session video state (on/off), participant video state and shows/removes video
                        //    when video modality is activated/deactivated.
                        function onParticipantVideo(status, resource, event) {
                            var scope = event['in'];
                            if (event.sender.href == rConversation.href && scope) {
                                if (scope.rel == 'localParticipant') {
                                    switch (event.type) {
                                        case 'added':
                                        case 'updated':
                                            activeModalities.video = true;
                                            if (isConferencing()) {
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                                updateMediaRoster(selfParticipant, isInMediaRoster(selfParticipant) ? 'update' : 'add');
                                                // check participants that are already in the conference - we need their msis
                                                // because we won't receive "participantVideo added" events for them.
                                                participants.each(function (p) {
                                                    if (!isInMediaRoster(p) && p[Internal.sInternal].audioSourceId() != -1)
                                                        updateMediaRoster(p, 'add');
                                                });
                                            }
                                            videoState(Internal.Modality.State.Connected);
                                            selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                            break;
                                        case 'deleted':
                                            removeVideo(selfVideoStream, true);
                                            activeModalities.video = false;
                                            if (isConferencing()) {
                                                if (isInMediaRoster(selfParticipant))
                                                    updateMediaRoster(selfParticipant, 'remove');
                                                selfParticipant[Internal.sInternal].setMediaSourceId(event);
                                            }
                                            videoState(Internal.Modality.State.Disconnected);
                                            selfParticipant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                            break;
                                        default:
                                            assert(false, 'unexpected event type');
                                    }
                                }
                                else if (scope.rel == 'participant') {
                                    Task.wait(getParticipant(scope.href)).then(function (participant) {
                                        switch (event.type) {
                                            case 'added':
                                            case 'updated':
                                                if (isConferencing()) {
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    updateMediaRoster(participant, isInMediaRoster(participant) ? 'update' : 'add');
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                                else {
                                                    participant[Internal.sInternal].setVideoStream(mainVideoStream);
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Connected);
                                                }
                                                break;
                                            case 'deleted':
                                                if (isConferencing()) {
                                                    if (isInMediaRoster(participant))
                                                        updateMediaRoster(participant, 'remove');
                                                    participant[Internal.sInternal].setMediaSourceId(event);
                                                    removeParticipantVideo(participant);
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                                    // if participant video is deleted not because we stopped video
                                                    // subscription explicitly (via isStarted(false)) but because 
                                                    // participant left the AV call then we need to reset isStarted.
                                                    participant[Internal.sInternal].setVideoStarted(false);
                                                }
                                                else {
                                                    participant[Internal.sInternal].setVideoStream(null);
                                                    participant[Internal.sInternal].videoState(Internal.Modality.State.Disconnected);
                                                }
                                                break;
                                            default:
                                                assert(false, 'unexpected event type');
                                        }
                                    });
                                }
                            }
                        }
                        // event handler for 'resumeAudio/resumeAudioVideo added' event
                        //   - activates the inactive conference session created during escalation
                        function onResumeAudioVideoAdded(status, resource, event) {
                            var scope = event['in'], href;
                            if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions) {
                                href = scope.href;
                                // Currently UCWA returns the 'renegotiations' link of the audioVideoSession as resumeAudio uri,
                                // i.e. avSessions[event.in.href].resource.link('renegotiations').href == event.target.href,
                                // but we cache it separately just in case
                                avSessions[href].resumeAudioVideoUri = event.target.href;
                                Task.wait(null).then(function () {
                                    if (!avSessions[href].renegotiated) {
                                        return ucwa.wait({
                                            type: 'completed',
                                            target: { rel: 'audioVideoRenegotiation' },
                                            resource: function (r) {
                                                // r.get('operationId') in outAvRenegoOpIds;
                                                return r.get('direction') == 'Outgoing' && r.link('audioVideoSession').href in avSessions;
                                            }
                                        });
                                    }
                                }).then(function () {
                                    resumeAudioVideo();
                                });
                            }
                        }
                        function onResumeAudioVideoDeleted(status, resource, event) {
                            var scope = event['in'];
                            if (scope && scope.rel == 'audioVideoSession' && scope.href in avSessions &&
                                event.target.href == avSessions[scope.href].resumeAudioVideoUri) {
                                delete avSessions[scope.href].resumeAudioVideoUri;
                            }
                        }
                        //#endregion server events
                        //#region plugin events
                        // TODO: remove when all jama callbacks are implemented
                        // var pluginEventHandlers = {
                        //    'CHANNEL_CREATED': function (channelType, channelId, isMain) {
                        //        switch (channelType) {
                        //            case MediaEnum.ChannelType.AUDIO:
                        //                audioChannel = { channelType: channelType, channelId: channelId };
                        //                break;
                        //            case MediaEnum.ChannelType.VIDEO:
                        //                if (isMain) {
                        //                    mainVideoStream._id(channelId);
                        //                    selfVideoStream._id(channelId);
                        //                } else {
                        //                    assert(isConferencing());
                        //                    videoStreams.add(new MediaStream({
                        //                        mediaPlugin: mediaPlugin,
                        //                        type: MediaEnum.StreamType.Render,
                        //                        id: channelId
                        //                    }));
                        //                    // max number of remote participant video streams in a meeting
                        //                    // = max num of plugin channels excluding the main channel
                        //                    assert(videoStreams.size() < mediaConfig.maxVideoChannelCount());
                        //                    log('Num streams created: ' + videoStreams.size());
                        //                }
                        //                break;
                        //            default:
                        //                log('Created a channel of unknown type ' + channelType);
                        //                // debugger;
                        //                break;
                        //        }
                        //    },
                        //    'CHANNEL_DIRECTION_CHANGED': function (channelType, channelId, direction) {
                        //        // wire participant.audio.isOnHold to direction:
                        //        //   - MediaEnum.MediaConfig.NO_ACTIVE_MEDIA: hold
                        //        //   - otherwise (likely MediaEnum.MediaConfig.BOTH): resume
                        //        if (remoteHoldState == RemoteHoldState.HoldCompleted) {
                        //            if (direction == MediaEnum.MediaConfig.NO_ACTIVE_MEDIA && !isConferencing())
                        //                participants(0)[sInternal].audioOnHold(true);
                        //            remoteHoldState = RemoteHoldState.Unknown;
                        //        } else if (remoteHoldState == RemoteHoldState.ResumeCompleted) {
                        //            if (!isConferencing()) {
                        //                // note: direction can be MediaConfig.NO_ACTIVE_MEDIA
                        //                // if local participant is on hold
                        //                participants(0)[sInternal].audioOnHold(false);
                        //            }
                        //            remoteHoldState = RemoteHoldState.Unknown;
                        //        }
                        //        // CHANNEL_DIRECTION_CHANGED is a good hint for detecting...
                        //        if (channelType == MediaEnum.ChannelType.VIDEO &&
                        //            selfVideoStream._id() == channelId) {
                        //            // ... if self participant is streaming video
                        //            switch (direction) {
                        //                case MediaEnum.MediaConfig.SEND:
                        //                case MediaEnum.MediaConfig.BOTH:
                        //                    selfParticipant[sInternal].setVideoStarted(true);
                        //                    selfVideoStream._isFlowing(true);
                        //                    break;
                        //                case MediaEnum.MediaConfig.RECEIVE:
                        //                    selfParticipant[sInternal].setVideoStarted(false);
                        //                    selfVideoStream._isFlowing(false);
                        //                    break;
                        //            }
                        //            // ... and if remote participant in a 1:1 conversation is streaming video
                        //            if (!isConferencing()) {
                        //                assert(mainVideoStream._id() == channelId);
                        //                switch (direction) {
                        //                    case MediaEnum.MediaConfig.SEND:
                        //                        participants(0)[sInternal].setVideoStarted(false);
                        //                        mainVideoStream._isFlowing(false);
                        //                        break;
                        //                    case MediaEnum.MediaConfig.RECEIVE:
                        //                    case MediaEnum.MediaConfig.BOTH:
                        //                        participants(0)[sInternal].setVideoStarted(true);
                        //                        mainVideoStream._isFlowing(true);
                        //                        break;
                        //                }
                        //            }
                        //        }
                        //    },
                        //    'MEDIA_CHANGED': function (channelType, channelId, direction, mediaEvent) {
                        //        var streamState;
                        //        if (channelType == MediaEnum.ChannelType.VIDEO) {
                        //            streamState = enumcastStreamState(mediaEvent);
                        //            if (mainVideoStream._id() == channelId && direction == MediaEnum.MediaDirection.RENDER)
                        //                mainVideoStream._state(streamState);
                        //            else if (selfVideoStream._id() == channelId && direction == MediaEnum.MediaDirection.CAPTURE)
                        //                selfVideoStream._state(streamState);
                        //            else {
                        //                videoStreams.each(function (vs) {
                        //                    if (vs._id() == channelId)
                        //                        vs._state(streamState);
                        //                });
                        //            }
                        //        }
                        //    },
                        //    // yes, it's not a typo but a plugin bug
                        //    'DOMINANT_SPEKAER_CHANGED': function () {
                        //        // arguments - num of speakers, msi0, msi1, ... 
                        //        //   the most recent speaker is the first in the list; 
                        //        //   if msi0 == -1, nobody is speaking
                        //        var msi = arguments[1],
                        //            cur, prev = recentActiveSpeakers[activeSourceId];
                        //        if (prev)
                        //            prev[sInternal].isSpeaking(false);
                        //        if (msi == -1) {
                        //            activeSourceId = msi;
                        //            return;
                        //        }
                        //        cur = recentActiveSpeakers[msi];
                        //        if (!cur) {
                        //            // we have a new speaker who has not talked before
                        //            if (selfParticipant[sInternal].audioSourceId() == msi) {
                        //                cur = selfParticipant;
                        //            } else {
                        //                participants.each(function (p) {
                        //                    if (p[sInternal].audioSourceId() == msi)
                        //                        cur = p;
                        //                });
                        //            }
                        //            if (cur)
                        //                recentActiveSpeakers[msi] = cur;
                        //        }
                        //        if (cur) {
                        //            cur[sInternal].isSpeaking(true);
                        //            activeSourceId = msi;
                        //        }
                        //    },
                        //    'OFFER_READY': function (hasOffer, diagCode, sdpCount) {
                        //        var i, offers = [], renegoHref;
                        //        try {
                        //            for (i = 0; i < sdpCount; i++) {
                        //                offers.push({
                        //                    sdp: arguments[3 + i * 2],
                        //                    id: arguments[3 + i * 2 + 1]
                        //                });
                        //            }
                        //            if (offers.length == 0)
                        //                throw Exception('NoSdpOffers', { diagCode: diagCode });
                        //            renegoHref = getRenegotiationsHref();
                        //            if (renegoHref) {
                        //                // A negotiated AudioVideoSession already exists, the client starts renegotiation -
                        //                // expect an "audioVideoRenegotiation completed" event from UCWA after
                        //                // sending renegotiation offer
                        //                sendRenegotiationOffer(offers[0].sdp, renegoHref);
                        //            } else {
                        //                // The client starts AV session - expect an "audioVideoInvitation completed"
                        //                // event from UCWA after sending the invitation
                        //                sendOffer(offers).then(
                        //                    function () {
                        //                        dfdStart.resolve();
                        //                        state(Modality.State.Connected);
                        //                    },
                        //                    function (error) {
                        //                        // if the caller hangs up by canceling this promise explicitly we wind up
                        //                        // here with the rejected promise
                        //                        if (dfdStart.promise.state() == 'pending')
                        //                            dfdStart.reject(error);
                        //                        state(Modality.State.Disconnected, error);
                        //                        audioState(Modality.State.Disconnected);
                        //                        videoState(Modality.State.Disconnected);
                        //                        cleanup();
                        //                    },
                        //                    dfdStart.status);
                        //            }
                        //        } catch (error) {
                        //            if (dfdStart)
                        //                dfdStart.reject(error);
                        //        }
                        //    },
                        //    'ANSWER_READY': function (_arg0, sdp) {
                        //        log('SDP Answer:\n' + sdp);
                        //        if (rAVRenegotiation) {
                        //            if (!isConferencing()) {
                        //                if (remoteHoldState == RemoteHoldState.HoldOffered)
                        //                    remoteHoldState = RemoteHoldState.HoldAnswered;
                        //                else if (remoteHoldState == RemoteHoldState.ResumeOffered)
                        //                    remoteHoldState = RemoteHoldState.ResumeAnswered;
                        //            }
                        //            // the client answers the incoming renegotiation request
                        //            // expect an "audioVideoRenegotiation completed" after this call
                        //            ucwa.send('POST', rAVRenegotiation.link('answer').href, {
                        //                headers: { 'Content-Type': 'application/sdp' },
                        //                data: sdp,
                        //                nobatch: true
                        //            });
                        //        } else {
                        //            // the client answers the incoming invitation
                        //            dfdAccept.status('sending answer to UCWA');
                        //            invitation.acceptWithAnswer(sdp, sessionContext).then(
                        //                function () {
                        //                    dfdAccept.status('awaiting an "audioVideoInvitation completed" event from UCWA');
                        //                },
                        //                function (error) {
                        //                    dfdAccept.reject(error);
                        //                    state(Modality.State.Disconnected, error);
                        //                    audioState(Modality.State.Disconnected);
                        //                    videoState(Modality.State.Disconnected);
                        //                },
                        //                dfdAccept.status);
                        //        }
                        //    }
                        // };
                        //#endregion plugin events
                        //#region sendOffer
                        /**
                        * Composes an SDP offer from the OFFER_READY media plugin event data and
                        * sends it to the server to start an AV session.
                        *
                        * The returned promise is resolved only when we get a reply to the post and
                        * and audioVideoInvitation completed event
                        */
                        function sendOffer(offers) {
                            assert(offers.length > 0);
                            // construct content that contains all offers given by the media plugin
                            function createOfferOptions(context) {
                                var boundary = '9BCE36B8-2C70-44CA-AAA6-D3D332ADBD3F', mediaOffer, options = { nobatch: true };
                                if (isConferencing()) {
                                    if (escalateAudioVideoUri) {
                                        mediaOffer = Internal.multipartSDP(offers, boundary);
                                        options = {
                                            headers: {
                                                'Content-Type': 'multipart/alternative;boundary=' + boundary +
                                                    ';type="application/sdp"',
                                                'Content-Length': '' + mediaOffer.length
                                            },
                                            query: {
                                                operationId: operationId,
                                                sessionContext: sessionContext
                                            },
                                            data: mediaOffer,
                                            nobatch: true
                                        };
                                    }
                                    else {
                                        options.data = Internal.multipartJsonAndSDP({
                                            offers: offers,
                                            boundary: boundary,
                                            operationId: operationId,
                                            sessionContext: sessionContext,
                                            threadId: conversation.threadId(),
                                            context: context
                                        });
                                        options.headers = {
                                            'Content-Type': 'multipart/related;boundary=' + boundary +
                                                ';type="application/vnd.microsoft.com.ucwa+json"'
                                        };
                                    }
                                }
                                else {
                                    // P2P mode
                                    options.data = Internal.multipartJsonAndSDP({
                                        to: remoteUri,
                                        offers: offers,
                                        boundary: boundary,
                                        operationId: operationId,
                                        sessionContext: sessionContext,
                                        threadId: conversation.threadId(),
                                        context: context
                                    });
                                    options.headers = {
                                        'Content-Type': 'multipart/related;boundary=' + boundary +
                                            ';type="application/vnd.microsoft.com.ucwa+json"'
                                    };
                                }
                                if (context)
                                    extend(options.headers, { 'X-MS-RequiresMinResourceVersion': 2 });
                                return options;
                            }
                            return async(getStartAudioVideoLink).call(null).then(function (link) {
                                var options = createOfferOptions(link.revision >= 2 && invitationContext), dfdPost, dfdCompleted;
                                dfdPost = ucwa.send('POST', link.href, options).then(function (r) {
                                    // POST to startAudioVideo/addAudioVideo returns an empty response with an AV invitation
                                    // URI in the Location header. The UCWA stack constructs and returns an empty resource
                                    // with href set to that URI.
                                    if (!rAVInvitation)
                                        rAVInvitation = r;
                                });
                                // wait for the "audioVideoInvitation completed" event that corresponds to the given conversation
                                dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'audioVideoInvitation' },
                                    resource: { direction: 'Outgoing', threadId: conversation.threadId(), operationId: operationId, sessionContext: sessionContext }
                                }).then(function (event) {
                                    if (event.status == 'Failure') {
                                        // if remote SIP uri is invalid we won't receive "audioVideoInvitation started" event,
                                        // thus we won't have a full rAVInvitation resource cached. It will be either undefined or
                                        // just an empty resource with an href returned by a response to startAudioVideo POST (if
                                        // that response arrived before this event). So we cache the invitation resource here,
                                        // since it may be used by other event handlers.
                                        rAVInvitation = event.resource;
                                        if (mediaSession) {
                                            mediaSession.terminate();
                                            mediaSession = null;
                                        }
                                        throw Internal.EInvitationFailed(event.reason);
                                    }
                                    completeNegotiation(event.status, event.reason);
                                });
                                return Task.waitAll([dfdPost, dfdCompleted]);
                            });
                        }
                        //#endregion
                        //#region sendRenegotiationOffer
                        /**
                         * Composes an SDP offer from the OFFER_READY media plugin event data and
                         * sends it to the server to renegotiate the AV session.
                         */
                        function sendRenegotiationOffer(sdp, url) {
                            log('Renegotiation SDP offer:\n', sdp);
                            // cache operation id
                            var operationId = guid();
                            outAvRenegoOpIds[operationId] = "";
                            return ucwa.send('POST', url, {
                                headers: { 'Content-Type': 'application/sdp' },
                                query: { operationId: operationId },
                                data: sdp,
                                nobatch: true
                            });
                        }
                        //#endregion
                        //#region resumeAudioVideo
                        /**
                         * Activates (resumes) the AV conference call created in inactive state
                         * when a p2p call is escalated to a conference.
                         */
                        function resumeAudioVideo() {
                            // var audioConfig = onHold() ? MediaEnum.MediaConfig.NO_ACTIVE_MEDIA : MediaEnum.MediaConfig.BOTH;
                            mainVideoConfig = activeModalities.video ?
                                (onHold() ? 4 /* NO_ACTIVE_MEDIA */ : 3 /* BOTH */) :
                                0 /* NOT_PRESENT */;
                            // var moreChannels = mainVideoConfig != MediaEnum.MediaConfig.NOT_PRESENT;
                            // TODO: jama: replace
                            // pcAV.invoke('SetMediaConfig',
                            //    audioConfig,                            // audio configuration
                            //    mainVideoConfig,                        // main video configuration
                            //    moreChannels ? mediaConfig.maxVideoChannelCount() - 1 : 0, // additional video channel count
                            //    moreChannels ? MediaEnum.MediaConfig.RECEIVE : MediaEnum.MediaConfig.NOT_PRESENT, // additional video config
                            //    MediaEnum.MediaConfig.NOT_PRESENT);     // panoVideoConfig
                        }
                        //#endregion
                        //#region setRenegotiationOffer
                        function setRenegotiationOffer(sdp) {
                            // var audioConfig = onHold() ? MediaEnum.MediaConfig.NO_ACTIVE_MEDIA :
                            //    MediaEnum.MediaConfig.BOTH;
                            // When the remote participant adds video to an audio conversation, we auto-accept incoming
                            // video only. The local participant can turn their video on later via video.channels(0).isStarted(true).
                            // var videoConfig = onHold() ? MediaEnum.MediaConfig.NO_ACTIVE_MEDIA :
                            //    videoState() != Modality.State.Connected && /\bm=video\b/gmi.test(sdp) ? MediaEnum.MediaConfig.RECEIVE :
                            //        MediaEnum.MediaConfig.BOTH;
                            log('Incoming SDP offer:\n' + sdp);
                            mediaSession.processOfferAsync(sdp).then(function (modalities) {
                                // TODO: remove this line once video is implemented
                                delete modalities.video;
                                return mediaSession.configureModalitiesAsync(modalities);
                            }).then(function () {
                                return mediaSession.createAnswerAsync(false);
                            }).then(function (answer) {
                                return ucwa.send('POST', rAVRenegotiation.link('answer').href, {
                                    headers: { 'Content-Type': 'application/sdp' },
                                    data: answer,
                                    nobatch: true
                                });
                            });
                        }
                        //#endregion
                        //#region setProvisionalAnswer
                        /**
                         * Sets the provisional SDP answer from the remote party
                         */
                        function setProvisionalAnswer(mediaAnswer, remoteEndpoint) {
                            var sdp = DataUri(mediaAnswer).data;
                            log('Provisional answer from the remote party:\n' + sdp);
                            return mediaSession.processAnswerAsync(sdp, true);
                        }
                        //#endregion
                        //#region setFinalAnswer
                        /**
                         * Sets the final SDP answer from the remote party
                         */
                        function setFinalAnswer(mediaAnswer, remoteEndpoint) {
                            var sdp = DataUri(mediaAnswer).data;
                            log('Final answer from the remote party:\n' + sdp);
                            return mediaSession.processAnswerAsync(sdp, false);
                        }
                        //#endregion
                        //#region completeNegotiation
                        /**
                         * Completes SDP negotiation
                         */
                        function completeNegotiation(eventStatus, reason) {
                            // TODO: do we still need this?
                            // var errCode = eventStatus == 'Success' ?
                            //    MediaEnum.NegotiationStatus.NS_SUCCESS :
                            //    (reason && reason.code == 'RemoteFailure') ?
                            //        MediaEnum.NegotiationStatus.NS_REMOTE_INTERNAL_ERROR :
                            //        MediaEnum.NegotiationStatus.NS_LOCAL_INTERNAL_ERROR;
                            return mediaSession.completeNegotiationAsync();
                        }
                        //#endregion
                        //#region getStartAudioVideoUri
                        /**
                         * The first SDP offer is sent to the link given by this function.
                         */
                        function getStartAudioVideoLink() {
                            // if the AV modality is the 1-st modality in the conversation,
                            // send a request to the global startAudioVideo link
                            if (!rConversation)
                                return ucwa.get({ rel: 'communication' }).link('startAudioVideo');
                            // if this is an escalation from P2P to a conference, send the
                            // request to the escalation link
                            if (escalateAudioVideoUri)
                                return ucwa.get(escalateAudioVideoUri); // TODO: .link('self')?
                            // if the AV modality gets added to an existing conversation,
                            // send the request to its addAudioVideo link
                            return ucwa.send('GET', rConversation.link('audioVideo').href).then(function (rAV) {
                                return rAV.link('addAudioVideo');
                            });
                        }
                        //#endregion
                        return self;
                    }
                    return WebRtcAudioVideoSession;
                })();
                Internal.WebRtcAudioVideoSession = WebRtcAudioVideoSession;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="AudioVideoSession.ts" />
/// <reference path="AudioVideoInvitation.ts" />
/// <reference path="WebRtcAudioVideoSession.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_6) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var check = Web.Utils.check;
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var isArray = Web.Utils.isArray;
                var contains = Web.Utils.contains;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var log = Web.Media.log;
                /**
                 * AudioVideo part of a multi-modal conversation.
                 *
                 * @created Oct 2013
                 * @blame sosobov
                 */
                var AudioVideoModality = (function () {
                    //#endregion
                    function AudioVideoModality(options) {
                        var self = Model(), ucwa = options.ucwa, rInvitation = options.rInvitation, participants = options.participants, guestName = options.guestName, selfParticipant = options.selfParticipant, localUri = options.me.id(), // SIP URI of the signed-in user
                        remoteUri, // SIP URI of the remote party in a P2P conversation
                        mediaPlugin = options.mediaPlugin, // MediaPlugin
                        devices = options.devices, // DevicesManager
                        tm = options.tm, conversation = options.conversation, rConversation = options.rConversation, // conversation resource
                        AVS = Web.Media.MediaAgent.isPlatformSupported() && !Web.Media.isFirefoxWebRtc() ?
                            Internal.WebRtcAudioVideoSession :
                            Internal.AudioVideoSession, avs, // the active AudioVideoSession in this conversation
                        avsEsc, // AudioVideoSession created when a P2P conversation is escalated to a
                        // multi-party conference
                        // a unique id of this modality - handy for debugging this modality's
                        // server event subscription
                        thisModalityId = random(), isAVInvitation = rInvitation && rInvitation.rel == 'audioVideoInvitation', 
                        // we are ignoring the AV part of the meeting invitation because we are 
                        // using the messaging part of the meeting invitation to accept/decline 
                        isMeetingInvitation = rInvitation && rInvitation.rel == 'onlineMeetingInvitation' &&
                            !conversation.meeting.availableModalities.messaging(), isAudioMeetingInvitation = isMeetingInvitation &&
                            conversation.meeting.availableModalities.audio(), isVideoMeetingInvitation = isMeetingInvitation &&
                            conversation.meeting.availableModalities.video(), 
                        // AudioVideoInvitation (for P2P incoming calls)
                        invitation = isAVInvitation && Internal.AudioVideoInvitation({
                            resource: rInvitation,
                            ucwa: ucwa,
                            from: getFrom(rInvitation)
                        }), rAVInvitation = isAVInvitation && rInvitation, // audioVideoInvitation resource
                        sStartingAV = {}, // serves as state.reason when state=Notified
                        state = Property({
                            value: invitation || isMeetingInvitation ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), audioState = Property({
                            value: invitation || isAudioMeetingInvitation ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        }), videoState = Property({
                            value: invitation && invitation.hasVideo() || isVideoMeetingInvitation ?
                                Internal.Modality.State.Notified :
                                Internal.Modality.State.Disconnected
                        });
                        assert(conversation);
                        // remove rInvitation if we are ignoring the AV part of the meeting invitation 
                        if (!invitation && !isMeetingInvitation)
                            rInvitation = null;
                        options = null;
                        //#region public properties
                        // mutes/unmutes the audio channel or returns the mute status
                        var muted = Property({
                            value: false,
                            get: function () { return avs ? avs.muted.get() : muted(); },
                            set: function (val) { return avs.muted.set(val); }
                        });
                        // holds/resumes audio/video or returns the onHold status
                        var onHold = Property({
                            value: false,
                            get: function () { return avs.onHold.get(); },
                            set: function (val) { return avs.onHold.set(val); }
                        });
                        //#endregion
                        function init() {
                            state.changed(function (newState, reason, oldState) {
                                log('AudioVideoModality(' + thisModalityId + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                            });
                            audioState.changed(function (newState, reason, oldState) {
                                log('AudioVideoModality(' + thisModalityId + ')::audioState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                            });
                            videoState.changed(function (newState, reason, oldState) {
                                log('AudioVideoModality(' + thisModalityId + ')::videoState: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                            });
                            state.when(Internal.Modality.State.Disconnected, reset);
                            // permanent audio/video state subscription to ensure that self-participant's
                            // audio/video state is in fact AVM's audio/video state.
                            // TODO: alternatively selfParticipant's audioState/videoState can be a sourced
                            // property of AVM.audioState / videoState.
                            audioState.changed(selfParticipant[Internal.sInternal].audioState);
                            videoState.changed(selfParticipant[Internal.sInternal].videoState);
                            extend(self, {
                                state: state.asReadOnly(),
                                audioState: audioState.asReadOnly(),
                                videoState: videoState.asReadOnly(),
                                muted: muted,
                                onHold: onHold,
                                showParticipantVideo: showParticipantVideo,
                                removeParticipantVideo: removeParticipantVideo
                            });
                            if (invitation)
                                self.from = invitation.from;
                            ucwa.event(onServerEvent);
                            log('AudioVideoModality(' + thisModalityId + ') created');
                        }
                        function reset() {
                            if (avs) {
                                avs.state.changed.off(state);
                                avs.audioState.changed.off(audioState);
                                avs.videoState.changed.off(videoState);
                            }
                            state(Internal.Modality.State.Disconnected);
                            audioState(Internal.Modality.State.Disconnected);
                            videoState(Internal.Modality.State.Disconnected);
                            invitation = null;
                            rAVInvitation = null;
                            avs = null;
                        }
                        //#region private utils and event handlers
                        function defineAsyncCommand(name, states, method) {
                            var enabled = Property();
                            self[name] = Command(async(method), enabled);
                            state.changed(function (value) {
                                var isEnabled = contains(states, function (s) {
                                    return isArray(s) ?
                                        value == s[0] && state.reason === s[1] :
                                        value == s;
                                });
                                enabled(isEnabled);
                            });
                        }
                        function isConferencing() {
                            var convState = rConversation && rConversation.get('state', '');
                            return convState == 'Conferencing' || convState == 'Conferenced';
                        }
                        // AudioVideoSession 'escalated' event handler
                        //   replaces the p2p session with the conference session if escalation succeeded;
                        //   destroys the conference session if escalation failed.
                        function onAVSessionEscalated(status) {
                            var fMuted;
                            if (status == 'success') {
                                fMuted = avs.muted();
                                // replace the old P2P AV session with the new AV conference session and
                                // delete the old session
                                avs.state.changed.off(state);
                                avs.audioState.changed.off(audioState);
                                avs.videoState.changed.off(videoState);
                                avs.stop(Internal.sEscalation);
                                avs = avsEsc;
                                avs.state.changed(state);
                                avs.audioState.changed(audioState);
                                avs.videoState.changed(videoState);
                                avsEsc.escalated.off(onAVSessionEscalated);
                                avsEsc = null;
                                if (fMuted)
                                    avs.muted(fMuted);
                            }
                            else if (status == 'failure') {
                                avsEsc.escalated.off(onAVSessionEscalated);
                                avsEsc.stop();
                                avsEsc = null;
                            }
                            else {
                                assert(false);
                            }
                        }
                        // UCWA events handler
                        function onServerEvent(event) {
                            var id = event.target.rel + ' ' + event.type;
                            var r = event.resource;
                            switch (id) {
                                // when a new AV conversation is started (using rel=startAudioVideo)
                                // the conversation is added after this object is created.
                                case 'conversation added':
                                    if (r.get('threadId') == conversation.threadId())
                                        rConversation = r;
                                    break;
                                case 'conversation deleted':
                                    if (rConversation && rConversation.href == event.target.href)
                                        rConversation = null;
                                    break;
                                case 'conversation updated':
                                    // add participants to a meeting created by this modality's start()
                                    if (rConversation && r.href == rConversation.href && isConferencing() &&
                                        rConversation.hasLink('addParticipant'))
                                        conversation[Internal.sInternal].inviteParticipants();
                                    break;
                                case 'escalateAudio added':
                                    if (event.sender.href == rConversation.href)
                                        startEscalation({
                                            uri: event.target.href
                                        });
                                    break;
                                case 'escalateAudioVideo added':
                                    if (event.sender.href == rConversation.href)
                                        startEscalation({
                                            uri: event.target.href,
                                            video: true // video container will be retained by the selfParticipant
                                        });
                                    break;
                                case 'audioVideoInvitation completed':
                                    // incoming invitation was canceled or timed out while this client ignored
                                    // the invitation (neither accepted nor declined)
                                    if (!avs && rAVInvitation && rAVInvitation.href == r.href &&
                                        r.get('direction') == 'Incoming' &&
                                        event.status == 'Failure') {
                                        state(Internal.Modality.State.Disconnected, event.reason);
                                    }
                                    break;
                                case 'audioVideoInvitation started':
                                    // audioVideo can be added to an existing 1:1 conversation by the remote participant
                                    if (r.has('direction') && r.get('direction') == 'Incoming') {
                                        rConversation = getConversationResource();
                                        if (r.link('conversation').href == rConversation.href) {
                                            rAVInvitation = r;
                                            invitation = Internal.AudioVideoInvitation({
                                                resource: r,
                                                ucwa: ucwa,
                                                from: getFrom(r)
                                            });
                                            state(Internal.Modality.State.Notified);
                                            if (invitation.hasVideo())
                                                videoState(Internal.Modality.State.Notified);
                                            else
                                                audioState(Internal.Modality.State.Notified);
                                        }
                                    }
                                    break;
                            }
                        }
                        function getConversationResource() {
                            var href = conversation[Internal.sHref];
                            return href ? ucwa.get(href) : null;
                        }
                        // Finds a participant object that represents the inviter in the incoming call
                        //   The participant key in the participants collection can be either the participant href or the contact href.
                        //   The "from" participant resource embedded in the invitation has the participant href and the uri, so
                        //   we use either one to match the inviter.
                        function getFrom(rInvitation) {
                            var from = find(participants(), function (p) { return p[Internal.sHref] == rInvitation.link('from').href; }), rFrom, fromUri;
                            if (!from) {
                                rFrom = ucwa.get(rInvitation.link('from').href);
                                fromUri = rFrom.get('uri');
                                participants.each(function (p) {
                                    if (p.person.id() == fromUri)
                                        from = p;
                                });
                            }
                            return from;
                        }
                        //#endregion
                        //#region public methods
                        //#region start
                        /**
                         * Starts an outgoing audio/video call
                         *
                         * @param {String} to - SIP URI of the remote participant.
                         * @param {Dictionary|Boolean} [video] - If present, start both audio and video, otherwise only audio is started,
                         *                                       e.g. av.start({video: true});
                         * @param {HTMLElement} video.container - A DOM element that serves as the video window container for remote video,
                         *                                        e.g. av.start({video: {container: myElement}});
                         * @param {Object} [context] - An invitation context can accompany the generated audiovideo invitation.
                         *
                         * @returns {Promise}
                         */
                        defineAsyncCommand('start', [Internal.Modality.State.Connected, [Internal.Modality.State.Notified, sStartingAV], Internal.Modality.State.Disconnected], function (options) {
                            var isMeeting = conversation.isGroupConversation();
                            options = options || {};
                            remoteUri = options.to;
                            // ensures telemetry for audio is not sent when video is added to existing audio call.
                            if (audioState() == 'Disconnected')
                                tm && tm.record('Audio_Start');
                            if (options.video)
                                tm && tm.record('Video_Start');
                            // in p2p mode take URI of the remote participant
                            if (!isMeeting) {
                                if (!remoteUri)
                                    remoteUri = participants(0).uri();
                                else
                                    check(participants.size() == 0, 'ambiguous remote party in 1:1 call');
                                check(remoteUri, 'the remote participant URI is not specified');
                            }
                            if (!avs) {
                                avs = new AVS({
                                    ucwa: ucwa,
                                    mediaPlugin: mediaPlugin,
                                    devices: devices,
                                    localUri: localUri,
                                    context: options.context,
                                    invitation: invitation,
                                    rInvitation: rInvitation,
                                    conversation: conversation,
                                    rConversation: rConversation,
                                    participants: participants,
                                    selfParticipant: selfParticipant,
                                    // these are given by unit tests:
                                    operationId: options.operationId,
                                    sessionContext: options.sessionContext
                                });
                                avs.state.changed(state);
                                avs.audioState.changed(audioState);
                                avs.videoState.changed(videoState);
                            }
                            return Task.wait(null).then(function () {
                                if (conversation.meeting) {
                                    if (conversation.meeting.state() == Internal.Modality.State.Created) {
                                        return conversation.meeting.start({
                                            name: guestName && guestName(),
                                            uri: conversation.uri()
                                        });
                                    }
                                }
                                else if (isMeeting) {
                                    return conversation.addMeeting().start({
                                        name: guestName && guestName(),
                                        uri: conversation.uri()
                                    });
                                }
                            }).then(function () {
                                return avs.start({
                                    remoteUri: remoteUri,
                                    audioConfig: 3 /* BOTH */,
                                    mainVideoConfig: options.video ?
                                        3 /* BOTH */ :
                                        0 /* NOT_PRESENT */,
                                    video: options.video
                                });
                            }).then(function () {
                                // the UI has a reasonable expectation that
                                // once AV is used, all AV stuff is properly
                                // initialized: the list of cams, mics and so on
                                return devices && devices.init().catch();
                            });
                        });
                        //#endregion
                        //#region stop
                        /**
                         * Stops audio/video call
                         *
                         * @param {String} [modality] - if equals 'video', stops only video, if omitted both audio and video are stopped.
                         * @returns {Promise}
                         */
                        defineAsyncCommand('stop', [Internal.Modality.State.Connected, Internal.Modality.State.Connecting], function (modality) {
                            if (!avs)
                                return;
                            if (state() == Internal.Modality.State.Connecting)
                                return avs.stop();
                            if (modality == 'video') {
                                avs.stop(modality);
                                if (avsEsc)
                                    avsEsc.stop(modality);
                            }
                            else if (!modality) {
                                var tasks = [];
                                tasks.push(avs.stop());
                                if (avsEsc) {
                                    avsEsc.escalated.off(onAVSessionEscalated);
                                    tasks.push(avsEsc.stop());
                                }
                                return Task.waitAll(tasks).finally(function () { return state(Internal.Modality.State.Disconnected); });
                            }
                            else {
                                throw EInvalidArgument('modality', 'must be omitted or contain `video`');
                            }
                        });
                        //#endregion
                        //#region accept
                        /**
                         * Accepts an incoming audio/video invitation.
                         *
                         * @param {Dictionary} [video] - The video window container holder.
                         * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                         *
                         * @returns {Promise}
                         */
                        defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (options) {
                            if (isMeetingInvitation) {
                                return conversation.meeting.accept().then(function () {
                                    state(Internal.Modality.State.Notified, sStartingAV);
                                    return self.start(options);
                                });
                            }
                            options = options || {};
                            assert(!avs);
                            avs = new AVS({
                                ucwa: ucwa,
                                mediaPlugin: mediaPlugin,
                                devices: devices,
                                localUri: localUri,
                                rAVInvitation: rAVInvitation,
                                conversation: conversation,
                                rConversation: rConversation,
                                participants: participants,
                                selfParticipant: selfParticipant,
                                invitation: invitation
                            });
                            avs.state.changed(state);
                            avs.audioState.changed(audioState);
                            avs.videoState.changed(videoState);
                            return avs.accept(options).then(function () {
                                // the UI has a reasonable expectation that
                                // once AV is used, all AV stuff is properly
                                // initialized: the list of cams, mics and so on
                                return devices && devices.init().catch();
                            });
                        });
                        //#endregion
                        //#region decline
                        /**
                         * Declines an incoming audio/video invitation.
                         * reason: 'Local' - reject just on this endpoint, 'Global' (default) - reject on all.
                         * @returns {Promise}
                         */
                        defineAsyncCommand('decline', [Internal.Modality.State.Notified], function (reason) {
                            if (reason === void 0) { reason = 'Global'; }
                            assert(invitation, 'This is an outgoing call, so it cannot be "declined"');
                            return invitation.decline(reason).then(function () {
                                state(Internal.Modality.State.Disconnected);
                            });
                        });
                        //#endregion
                        //#region sendDtmf
                        /**
                         * Sends a DTMF tone
                         *
                         * @param {String} tone - a DTMF tone from MediaEnum.DtmfTone enumeration
                         * @returns {Promise}
                         */
                        defineAsyncCommand('sendDtmf', [Internal.Modality.State.Connected], function (tone) {
                            // if avs is null the thrown exception will lead to promise rejection.
                            return avs.sendDtmf(tone);
                        });
                        //#endregion
                        /**
                         * Shows participant's video
                         *
                         * @param {Participant} participant
                         * @returns {Promise}
                         */
                        function showParticipantVideo(participant) {
                            return avs.showParticipantVideo(participant);
                        }
                        /**
                         * Removes participant's video
                         *
                         * @param {Participant} participant
                         * @returns {Promise}
                         */
                        function removeParticipantVideo(participant) {
                            return avs.removeParticipantVideo(participant);
                        }
                        //#endregion public methods
                        //#region private methods
                        /**
                         * Starts a new AudioVideoSession that joins an online meeting.
                         *
                         * @param {String} uri - the uri to which the first SDP offer should be sent ('escalateAudio' or 'escalateAudioVideo uri).
                         * @param {Dictionary} [video] - The video window container holder.
                         * @param {HTMLElement} [video.container] - A DOM element that serves as the video window container for remote video.
                         *
                         * @returns {Promise}
                         */
                        function startEscalation(options) {
                            assert(!avsEsc);
                            assert(isConferencing());
                            avsEsc = new Internal.AudioVideoSession({
                                ucwa: ucwa,
                                mediaPlugin: mediaPlugin,
                                devices: devices,
                                localUri: localUri,
                                conversation: conversation,
                                rConversation: rConversation,
                                participants: participants,
                                selfParticipant: selfParticipant,
                                escalateAudioVideoUri: options.uri
                            });
                            avsEsc.escalated(onAVSessionEscalated);
                            if (options.video)
                                avs.removeVideo();
                            return avsEsc.start({
                                remoteUri: remoteUri,
                                audioConfig: 4 /* NO_ACTIVE_MEDIA */,
                                mainVideoConfig: options.video ?
                                    4 /* NO_ACTIVE_MEDIA */ : 0 /* NOT_PRESENT */,
                                video: options.video
                            });
                        }
                        //#endregion
                        init();
                        return self;
                    }
                    return AudioVideoModality;
                })();
                Internal.AudioVideoModality = AudioVideoModality;
            })(Internal = Model_6.Internal || (Model_6.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var guid = Web.Utils.guid;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                //#region multipartJsonAndSDP
                /**
                 * This function constructs the message body of the audioVideoInvitation
                 * HTTP POST used in the multiparty conference situation. The multiparty
                 * SDP offer message body will contain all the SDP offers separated by
                 * some boundary mark.
                 *
                 * This is an example of the multiparty SDP offer message body:
                 *
                 * --09B8DAEF
                 * Content-Type: application/vnd.microsoft.com.ucwa+json
                 * Content-Length: 274
                 *
                 * {"operationId":"0D1DBA19","sessionContext":"6A6A17C9","mediaOffer":"cid:BC4833B8",
                 * "telemetryId":"c380da57","joinAudioMuted":true,"joinVideoMuted":false}
                 * --09B8DAEF
                 * Content-ID: BC4833B8
                 * Content-Type: multipart/alternative;boundary=CA93AA8F;type="application/sdp"
                 * Content-Length: 12464
                 *
                 *
                 * --CA93AA8F
                 * Content-Type: application/sdp
                 * Content-ID: <b4511a64f3e11159b46a38d4c54771c2@6485c71fa8ec29075dcec063a43a27ea>
                 * Content-Length: 3897
                 *
                 * ...(sdp offer 1 content start)...
                 * v=0
                 * o=- 0 0 IN IP4 131.107.255.94
                 * ...(sdp content end)...
                 *
                 * --CA93AA8F
                 * Content-Type: application/sdp
                 * Content-ID: <f8bea11cdb9fc648b471381edb8c1587@5215feaa2950a58d4a3749e7a071b402>
                 * Content-Length: 8167
                 *
                 * ...(sdp offer 2 content start)...
                 * v=0
                 * o=- 0 1 IN IP4 131.107.255.94
                 * ...(sdp content end)...
                 *
                 * --CA93AA8F
                 *
                 * --09B8DAEF
                 *
                 * Note: wherever Content-Length is needed in the header section, the
                 * content needs to be established beforehand in order to calculate the
                 * Content-Length.
                 *
                 * The caller of this function needs to generate the boundary mark, which
                 * needs to be inserted into the "Content-Type" header field of the HTTP
                 * POST message like this:
                 *      multipart/related;boundary=09B8DAEF;type="application/vnd.microsoft.com.ucwa+json"
                 *
                 * @param {Object[]} offers - An array of media offers.
                 *     - offers[i].sdp - SDP of the i-th offer.
                 *     - offers[i].id - Content ID of the i-th offer.
                 *
                 * @param {String} boundary - a guid that separates multiple SDP offers
                 * @param {String} operationId - a guid that represents the current operation
                 * @param {String} threadId - a guid that represents the current thread
                 * @param {String} sessionContext - a session-specific guid
                 * @param {String} [to] - remote uri if this method is called for a 1:1 conversation
                 * @param {Object} [context] - A context that can be serialized as one of multiparts in the
                 *                             http request for sending audiovideo invitation.
                 *
                 * @created yodu, Feb 2014
                 */
                function multipartJsonAndSDP(options) {
                    var offers = options.offers, boundary = options.boundary, operationId = options.operationId, threadId = options.threadId, sessionContext = options.sessionContext || guid(), context = options.context, sdpBoundary = 'D63E5F1E-56D8-4EC4-B51B-02762CEA97D9', mediaCid = '4EFFF0D8-65D2-4E52-9A1B-0FA835D4B478', contextCid = '2CAE7DF5 -0185-4FB8-84E7-AA6C57F10432', multipartBLine = '--' + boundary + '\r\n', // will be used multiple times
                    msg = multipartBLine, // msg to be constructed starts with a boundary line
                    params, strParams, sdps;
                    // construct the JSON part containing parameters
                    params = {
                        operationId: operationId,
                        threadId: threadId,
                        sessionContext: sessionContext,
                        mediaOffer: 'cid:' + mediaCid
                    };
                    if (context)
                        extend(params, { customContent: 'cid:' + contextCid });
                    if (options.to) {
                        params.to = options.to;
                    }
                    else {
                        params.telemetryId = guid();
                        params.joinAudioMuted = false;
                        params.joinVideoMuted = false;
                    }
                    strParams = JSON.stringify(params);
                    msg += 'Content-Type: application/vnd.microsoft.com.ucwa+json\r\n' +
                        'Content-Length: ' + strParams.length + '\r\n' +
                        '\r\n' +
                        strParams +
                        '\r\n';
                    // a boundary line
                    msg += multipartBLine;
                    // construct the multipart SDP part
                    sdps = multipartSDP(offers, sdpBoundary);
                    msg += 'Content-ID: ' + mediaCid + '\r\n' +
                        'Content-Type: multipart/alternative;boundary=' + sdpBoundary + ';type="application/sdp"\r\n' +
                        'Content-Length: ' + sdps.length + '\r\n' +
                        sdps;
                    if (context) {
                        msg += '\r\n';
                        // a boundary line
                        msg += multipartBLine;
                        // the specified Content-Disposition header allows this multipart content always
                        // processed to the end point, which may not regiser 'text/json' as its supported format.
                        msg += 'Content-ID: ' + contextCid + '\r\n' +
                            'Content-Type:text/json' + '\r\n' +
                            'Content-Disposition: render; handling=optional' + '\r\n' +
                            '\r\n' +
                            JSON.stringify(context);
                    }
                    // message is ended with a boundary ending line
                    return msg + '\r\n--' + boundary + '--\r\n';
                }
                Internal.multipartJsonAndSDP = multipartJsonAndSDP;
                //#endregion
                //#region multipartSDP
                /**
                 * Constructs the body of a multipart SDP message
                 *
                 * @param {Object} offers - SDP media offers.
                 *     - offer.sdp - SDP content of the offer.
                 *     - offer.id - Content ID of offer.
                 * @param {String} boundary - a boundary separating the parts.
                 *
                 * @created sosobov, Apr 2014
                 */
                function multipartSDP(offers, boundary) {
                    var s = '\r\n', i;
                    for (i = 0; i < offers.length; ++i)
                        s += constructSDP(offers[i], boundary);
                    s += ('\r\n--' + boundary + '--\r\n');
                    return s;
                }
                Internal.multipartSDP = multipartSDP;
                //#endregion
                //#region constructSDP
                /**
                 * This function constructs one SDP offer message to be embedded into
                 * the multipart SDP offer message body.
                 *
                 * The SDP offer message needs to follow the following format:
                 *
                 *      empty line
                 *      SDP section boundary line
                 *      header
                 *          Content-Type
                 *          Content-ID
                 *          Content-Length
                 *      SDP content
                 *
                 * @param {Object} offer - An SDP media offer.
                 *     - offer.sdp - SDP content of the offer.
                 *     - offer.id - Content ID of offer.
                 *
                 * @param {String} boundary - a guid that separates multiple SDP offers
                 *
                 * @created yodu, Feb 2014
                 */
                function constructSDP(offer, boundary) {
                    assert(offer && offer.sdp && offer.id && boundary);
                    return '\r\n' +
                        '--' + boundary + '\r\n' +
                        'Content-Type: application/sdp\r\n' +
                        'Content-ID: ' + offer.id + '\r\n' +
                        'Content-Length: ' + offer.sdp.length + '\r\n' +
                        '\r\n' +
                        offer.sdp;
                }
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var Event = Web.Utils.Event;
                var Property = Web.Utils.Property;
                var log = Web.Media.log;
                var PluginComponent = Web.Media.PluginComponent;
                /**
                 * UI can listen to channel state changes. When channel becomes active UI can call container(parent)
                 * to set the parent DOM element for the video window of this channel, for example:
                 *
                 *   videoChannel.state.when("Active", () => {
                 *       videoChannel.container(document.getElementById("myVideoWindow"));
                 *   });
                 *
                 * Alternatively, UI can set the video channel container ad-hoc to display the video window, and
                 * set it to null to remove the video window.
                 *
                 * @author sosobov
                 * @created Nov 2013
                 */
                var LocalVideoChannel = (function () {
                    //#endregion
                    function LocalVideoChannel(options) {
                        var id = options.channelId, mediaPlugin = options.mediaPlugin, container = options.container || Property(), windowState = Property({ value: PluginComponent.State.Unloaded }), resized = new Event(), pcVideoUI = null, // "VideoUI" plugin component
                        hRenderWindow = null, // render window handle (as BigInt)
                        channel = new Internal.VideoChannel({ name: 'local' });
                        function channelId(cid) {
                            if (arguments.length == 0) {
                                return id;
                            }
                            else {
                                id = cid;
                                return this;
                            }
                        }
                        /**
                         *  Creates a video window to render incoming video and places it in the parent DOM element
                         */
                        function createVideoWindow(parent) {
                            assert(!pcVideoUI);
                            parent = parent || container();
                            assert(parent);
                            pcVideoUI = mediaPlugin.createComponent({
                                type: 'VideoUI',
                                hide: false
                            });
                            pcVideoUI.state.changed(onPluginComponentState);
                            pcVideoUI.event(onPluginComponentEvent, 'async');
                            pcVideoUI.setContainer(parent);
                            return pcVideoUI.load().then(function () {
                                pcVideoUI.invoke('CreateVideoUI', false); // false == no preview window
                                hRenderWindow = getWindow('GetRenderWindow');
                            });
                        }
                        function destroyVideoWindow() {
                            if (pcVideoUI) {
                                pcVideoUI.invoke('DestroyVideoWindows');
                                pcVideoUI.unload();
                                pcVideoUI.event.off(onPluginComponentEvent);
                                pcVideoUI.state.changed.off(onPluginComponentState);
                                windowState(PluginComponent.State.Unloaded);
                                pcVideoUI = null;
                                hRenderWindow = null;
                            }
                        }
                        /**
                         * VideoUI component event listener - re-fires 'video size changed' event upon receiving
                         * it from the plugin component
                         */
                        function onPluginComponentEvent(ev) {
                            if (ev.type == 'VIDEO_SIZE_CHANGED') {
                                resized.fire({
                                    width: ev.args[0],
                                    height: ev.args[1]
                                });
                            }
                        }
                        /**
                         * Returns the window for rendering incoming video
                         */
                        function videoWindow() {
                            return hRenderWindow = hRenderWindow || getWindow('GetRenderWindow');
                        }
                        function getWindow(method) {
                            assert(method == 'GetRenderWindow');
                            if (pcVideoUI) {
                                var res = pcVideoUI.invoke(method);
                                if (res.succeeded)
                                    return res[1];
                            }
                            return null;
                        }
                        /**
                         * Resizes the video window so that it fits the parent DOM element
                         */
                        function resizeVideoWindow(parent) {
                            if (parent === void 0) { parent = container(); }
                            assert(parent);
                            pcVideoUI.invoke('ResizeWindow', parent.clientWidth, parent.clientHeight);
                        }
                        function onPluginComponentState(state) {
                            log('Video channel ' + id + ' ' + pcVideoUI.id() + ' pcVideoUI.state = ' + state);
                            // in destroyVideoWindow() we unsubscribe from the plugin component events right after
                            // we called unload(), so the last component state we see is Unloading. We make it
                            // the Unloaded state to enable the single check for the uninitialized (Unloaded) state
                            if (state == PluginComponent.State.Unloading)
                                state = PluginComponent.State.Unloaded;
                            windowState(state);
                        }
                        return {
                            container: container,
                            channelId: channelId,
                            createVideoWindow: async(createVideoWindow),
                            destroyVideoWindow: destroyVideoWindow,
                            videoWindow: videoWindow,
                            resizeVideoWindow: resizeVideoWindow,
                            videoWindowState: windowState.asReadOnly(),
                            resized: resized.observer,
                            channel: extend(channel, {
                                // TODO: overriding an existing member this way isn't nice
                                isStarted: Property({
                                    value: false,
                                    // .set(true) starts streaming the local video:
                                    //
                                    //  1. it takes the rendering element from the stream where it's supposed to have been already set
                                    //  2. then it invokes container.set that knows how to start streaming the local video
                                    //
                                    // .set(false) stops streaming the video:
                                    //
                                    //  1. it invokes container.set(null) that knows how to stop streaming
                                    //  2. and leaves the rendering element in the media stream untouched
                                    //
                                    set: function (x) { return container.set(x ? channel.stream.source.sink.container() : null).then(function () { return x; }); }
                                })
                            })
                        };
                    }
                    return LocalVideoChannel;
                })();
                Internal.LocalVideoChannel = LocalVideoChannel;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="LocalVideoChannel.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_7) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var assert = Web.Utils.assert;
                var inherit = Web.Utils.inherit;
                var foreach = Web.Utils.foreach;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var ConstProperty = Web.Utils.ConstProperty;
                /** matches the LWA plugin LWA_AUDIO_DEVICE_CATEGORIES enum */
                var categories = [
                    'Default',
                    'Mic and Speakers',
                    'Custom',
                    'Handset',
                    'Headset',
                    'Speaker',
                    'RoundTable'
                ];
                /**
                 * Holds collections of audio and video devices.
                 *
                 * @created Jan 2014
                 * @blame sosobov
                 * @blame antonkh
                 */
                var DevicesManager = (function () {
                    //#endregion
                    function DevicesManager(mediaPlugin) {
                        var pcTW = null; // "TuningWizard" plugin component
                        var isInitialized = false;
                        var microphones = Collection({ subscribed: init, get: init });
                        var speakers = Collection({ subscribed: init, get: init });
                        var cameras = Collection({ subscribed: init, get: init });
                        var selectedMicrophone = Property({
                            set: function (mic) {
                                selectAudioDevices(selectedSpeaker(), mic);
                                return mic;
                            }
                        });
                        var selectedSpeaker = Property({
                            set: function (spk) {
                                selectAudioDevices(spk, selectedMicrophone());
                                return spk;
                            }
                        });
                        var selectedCamera = Property({
                            set: function (cam) {
                                if (cam)
                                    pcTW.invoke('SetSelectedVideoDevice', cam.id());
                                return cam;
                            }
                        });
                        var localVideoChannel = new Internal.LocalVideoChannel({
                            mediaPlugin: mediaPlugin,
                            container: Property({
                                value: null,
                                set: function (parentElem) {
                                    // setting this to null while devices are not initialized should not
                                    // trigger plugin component initialization
                                    if (!isInitialized && !parentElem) {
                                        assert(this() === null);
                                        return this();
                                    }
                                    return init().then(function () {
                                        if (!localVideoChannel.videoWindow() && parentElem)
                                            return localVideoChannel.createVideoWindow(parentElem);
                                    }).then(function () {
                                        if (parentElem) {
                                            check(selectedCamera(), 'No video camera');
                                            pcTW.invoke('StartVideoPreview', localVideoChannel.videoWindow(), selectedCamera().name());
                                            localVideoChannel.resized(onLocalVideoResized);
                                        }
                                        else {
                                            pcTW.invoke('StopVideoPreview');
                                            localVideoChannel.destroyVideoWindow();
                                            localVideoChannel.resized.off(onLocalVideoResized);
                                        }
                                        return parentElem;
                                    });
                                }
                            })
                        });
                        /**
                         * Initializes the object by loading TuningWizard plugin component
                         * and enumerating available audio and video devices.
                         */
                        function init() {
                            return mediaPlugin.initMedia().then(function () {
                                if (pcTW)
                                    return;
                                pcTW = mediaPlugin.createComponent({
                                    type: 'TuningWizard',
                                    hide: true
                                });
                                pcTW.event(onPluginComponentEvent, 'async');
                                return pcTW.load().then(function () {
                                    updateAudioDevices(pcTW.invoke('GetTelephonyDevicesDetails'));
                                    updateVideoDevices(pcTW.invoke('GetVideoDevicesDescription'));
                                    // the plugin is extremely chatty - it fires a lot of TEL_DEVICES_CHANGED
                                    // events, so we postpone event handling until after we load the plugin
                                    // and get the initial device collection snapshot
                                    isInitialized = true;
                                });
                            });
                        }
                        function uninit() {
                            if (pcTW) {
                                pcTW.event.off(onPluginComponentEvent);
                                pcTW = null;
                            }
                            localVideoChannel.destroyVideoWindow();
                            localVideoChannel.resized.off(onLocalVideoResized);
                            isInitialized = false;
                        }
                        function onPluginComponentEvent(ev) {
                            if (!isInitialized)
                                return;
                            if (ev.type == 'TEL_DEVICES_CHANGED')
                                updateAudioDevices(pcTW.invoke('GetTelephonyDevicesDetails'));
                            else if (ev.type == 'VIDEO_DEVICES_CHANGED')
                                updateVideoDevices(pcTW.invoke('GetVideoDevicesDescription'));
                        }
                        function onLocalVideoResized(size) {
                            // notify the TuningWizard component that the video window size has changed
                            pcTW.invoke('ResizeWindow', localVideoChannel.videoWindow(), size.width, size.height);
                        }
                        function selectAudioDevices(spk, mic) {
                            if (spk && mic)
                                pcTW.invoke('SetSelectedAudioDevices', spk.id(), mic.id());
                        }
                        /**
                         * Updates the microphones and speakers collection after calling GetTelephonyDevicesDetails.
                         * This method returns the results array that enumerates audio devices;
                         * each device description is formatted as 5 sequential array elements:
                         *
                         *    - device category
                         *    - audio render device
                         *    - audio capture device
                         *    - display name
                         *    - is UC certified
                         *
                         * The last array element is the index of the currently selected device.
                         */
                        function updateAudioDevices(res) {
                            assert(res.succeeded);
                            var i, smic, sspk, mics = [], spks = [], ad, mic, spk;
                            // build the current device list
                            for (i = 1; i < res.length - 1; i += 5) {
                                // the mic and the speaker share these props
                                ad = Model({
                                    name: ConstProperty(res[i + 3]),
                                    // e.g. "Headset", "Handset", "Mic and Speakers", "Custom", etc.
                                    category: ConstProperty(categories[res[i]]),
                                    // whether it's UC certified
                                    certified: ConstProperty(res[i + 4])
                                });
                                spk = inherit(ad, {
                                    // e.g. "Headset Earphone (Plantronics C220 M)"
                                    id: ConstProperty(res[i + 1]),
                                    type: ConstProperty('Speaker')
                                });
                                mic = inherit(ad, {
                                    // e.g. "Headset Microphone (Plantronics C220 M)"
                                    id: ConstProperty(res[i + 2]),
                                    type: ConstProperty('Microphone')
                                });
                                spks.push(spk);
                                mics.push(mic);
                            }
                            // newly selected device (if there are no devices res = [0, -1])
                            sspk = spks[res[res.length - 1]];
                            smic = mics[res[res.length - 1]];
                            // replace device collection with a new device list
                            updateDeviceCollection(speakers, spks);
                            updateDeviceCollection(microphones, mics);
                            // TODO: note, that in some cases selectedSpeaker() != speakers(i) for any i
                            selectedSpeaker(sspk || null, Property.sUpdated);
                            // TODO: note, that in some cases selectedMicrophone() != microphones(i) for any i
                            selectedMicrophone(smic || null, Property.sUpdated);
                        }
                        /**
                         * Updates the cameras collection after calling GetVideoDevicesDescription
                         * This method returns the results array that enumerates all video devices;
                         * each array element is a string that describes a single device. The last array element
                         * is the index of the currently selected device.
                         */
                        function updateVideoDevices(res) {
                            assert(res.succeeded);
                            var i, scmr, cams = [], cam;
                            // build the current device list
                            for (i = 1; i < res.length - 1; i++) {
                                cam = Model({
                                    // the media plugin doesn't give a unique id for every
                                    // camera, so name is used as a reasonably unique id
                                    id: ConstProperty(res[i]),
                                    name: ConstProperty(res[i]),
                                    type: ConstProperty('Camera'),
                                    // TODO: this associates every camera with the same video channel,
                                    // while there should be multiple video channels
                                    localVideoChannel: localVideoChannel.channel
                                });
                                cams.push(cam);
                            }
                            // newly selected device (if there are no devices res = [0, -1])
                            scmr = cams[res[res.length - 1]];
                            // replace the device collection with the new device list
                            updateDeviceCollection(cameras, cams);
                            // TODO: note, that in some cases selectedCamera() != cameras(i) for any i
                            selectedCamera(scmr || null, Property.sUpdated);
                        }
                        /**
                         * Replaces the contents of devices collection with the new device list minimizing the number
                         * of collection events fired during the update. This is achieved by adding new devices and
                         * deleting removed devices (vs. emptying the collection and filling it up from scratch).
                         */
                        function updateDeviceCollection(collDevices, devices) {
                            var keysToDelete = [];
                            // compare current device collection with the newly built set;
                            // after this array devices should contain only new devices to be
                            // added to the devices collection and keysToDelete
                            // should contain keys of the devices to be deleted from the
                            // device collection
                            collDevices.each(function (device, key) {
                                var isPresent = false, i;
                                for (i = 0; i < devices.length; i++) {
                                    if (device.id() == devices[i].id()) {
                                        isPresent = true;
                                        devices.splice(i, 1);
                                        break;
                                    }
                                }
                                if (!isPresent)
                                    keysToDelete.push(key);
                            });
                            // remove deleted devices
                            foreach(keysToDelete, function (key) {
                                collDevices.remove(key);
                            });
                            // add new devices
                            foreach(devices, function (device) {
                                collDevices.add(device);
                            });
                        }
                        return Model({
                            init: async(init),
                            uninit: async(uninit),
                            speakers: speakers.asReadOnly(),
                            microphones: microphones.asReadOnly(),
                            cameras: cameras.asReadOnly(),
                            selectedSpeaker: selectedSpeaker,
                            selectedMicrophone: selectedMicrophone,
                            selectedCamera: selectedCamera,
                            localVideoChannel: localVideoChannel.channel
                        });
                    }
                    return DevicesManager;
                })();
                Internal.DevicesManager = DevicesManager;
            })(Internal = Model_7.Internal || (Model_7.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_8) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var SourcedModel = Web.Utils.SourcedModel;
                var ConstProperty = Web.Utils.ConstProperty;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var log = Web.Media.log;
                /**
                 * Video channel - represents a unidirectional video channel.
                 *
                 * @created Jan 2015
                 * @blame sosobov
                 */
                var VideoChannel = (function () {
                    //#endregion
                    function VideoChannel(options) {
                        if (options === void 0) { options = {}; }
                        var name = options.name, isStarted = Property(), isOnHold = Property(), isVideoOn = Property({ value: false }), streamEmpty = new Internal.MediaStream, stream = SourcedModel(streamEmpty);
                        var self = Model({
                            camera: ConstProperty('unknown'),
                            stream: stream,
                            isStarted: isStarted,
                            isVideoOn: isVideoOn.asReadOnly(),
                            isOnHold: isOnHold
                        });
                        stream.setSource(streamEmpty);
                        stream.state.changed(function (newState, reason, oldState) {
                            log('VideoChannel ' + name + ' (' +
                                '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        // nulling the rendering window while streaming stops the video
                        stream.source.sink.container.when(null, function () { return self.isStarted.set(false); });
                        setHiddenProperty(self, Internal.sInternal, {
                            isVideoOn: isVideoOn
                        });
                        return self;
                    }
                    return VideoChannel;
                })();
                Internal.VideoChannel = VideoChannel;
            })(Internal = Model_8.Internal || (Model_8.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_9) {
            var Internal;
            (function (Internal) {
                'use strict';
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var log = Web.Media.log;
                var PluginComponent = Web.Media.PluginComponent;
                /**
                 * Represents a video window used to render a video stream in a parent DOM element
                 *
                 * @created Jan 2015
                 * @blame sosobov
                 */
                var VideoSink = (function () {
                    //#endregion
                    // args are omitted to create dummy sink models
                    function VideoSink(options) {
                        if (options === void 0) { options = {}; }
                        var mediaPlugin = options.mediaPlugin, 
                        // video window plugin component state
                        pcState = Property({ value: PluginComponent.State.Unloaded }), 
                        // the DOM element that will host the video window
                        container = Property({
                            value: options.container,
                            set: Command(function (x) { return x; }, pcState.equalsAny(PluginComponent.State.Unloaded, PluginComponent.State.Loaded))
                        }), videoFormat = Property({
                            value: Internal.MediaEnum.VideoFormat.Crop,
                            set: Command(function (x) { return x; }, pcState.equalsAny(PluginComponent.State.Unloaded, PluginComponent.State.Loaded)),
                            check: function (v) {
                                if (!(v in Internal.MediaEnum.VideoFormat))
                                    throw EInvalidArgument('format', '`format` value is Fit, Crop or Stretch.');
                            }
                        }), windowSize = Property({ value: {} }), // video window size: { width, height }
                        hRenderWindow = Property(), // render window handle (as BigInt)
                        pcVideoUI = null; // "VideoUI" plugin component
                        options = null;
                        //#region semi-public methods
                        // converts API video format enum to the plugin enum
                        function enumcastVideoFormat(vf) {
                            // match keys are MediaEnum.VideoFormat values
                            return {
                                Fit: 0 /* LetterBoxing */,
                                Crop: 1 /* Cropping */,
                                Stretch: 2 /* Stretch */
                            }[vf];
                        }
                        // Creates a video window to render incoming video and places it in the parent DOM element
                        function createVideoWindow() {
                            assert(!pcVideoUI);
                            assert(container());
                            pcVideoUI = mediaPlugin.createComponent({
                                type: 'VideoUI',
                                hide: false
                            });
                            pcVideoUI.state.changed(onPluginComponentState);
                            pcVideoUI.event(onPluginComponentEvent, 'async');
                            pcVideoUI.setContainer(container());
                            return pcVideoUI.load().then(function () {
                                var res;
                                pcVideoUI.invoke('CreateVideoUI', false); // false == no preview window
                                res = pcVideoUI.invoke('GetRenderWindow');
                                hRenderWindow(res[1]);
                            });
                        }
                        // Destroys the rendering video window thus returning the sink to the uninitialied state
                        function destroyVideoWindow() {
                            if (pcVideoUI) {
                                pcVideoUI.invoke('DestroyVideoWindows');
                                pcVideoUI.unload();
                                pcVideoUI.event.off(onPluginComponentEvent);
                                pcVideoUI.state.changed.off(onPluginComponentState);
                                pcState(PluginComponent.State.Unloaded);
                                pcVideoUI = null;
                                hRenderWindow(null);
                            }
                        }
                        // Resizes the video window so that it fits the parent DOM element
                        function resizeVideoWindow() {
                            assert(container());
                            pcVideoUI.invoke('ResizeWindow', container().clientWidth, container().clientHeight);
                        }
                        //#endregion
                        //#region plugin event handlers
                        function onPluginComponentEvent(ev) {
                            if (ev.type == 'VIDEO_SIZE_CHANGED') {
                                windowSize({
                                    width: ev.args[0],
                                    height: ev.args[1]
                                });
                            }
                        }
                        function onPluginComponentState(state) {
                            log('Video sink ' + pcVideoUI.id() + ' pcVideoUI.state = ' + state);
                            // in destroyVideoWindow() we unsubscribe from the plugin component events right after
                            // we called unload(), so the last component state we see is Unloading. We make it
                            // the Unloaded state to enable the single check for the uninitialized (Unloaded) state
                            if (state == PluginComponent.State.Unloading)
                                state = PluginComponent.State.Unloaded;
                            pcState(state);
                        }
                        //#endregion
                        return Model({
                            container: container,
                            format: videoFormat,
                            _format: videoFormat.map(enumcastVideoFormat),
                            _init: EnabledCommand(async(createVideoWindow)),
                            _uninit: EnabledCommand(destroyVideoWindow),
                            _resize: EnabledCommand(resizeVideoWindow),
                            _videoWindow: hRenderWindow.asReadOnly(),
                            _state: pcState.asReadOnly(),
                            _size: windowSize.asReadOnly(),
                            _c: Property({ value: null }) // a placeholder for container subscription
                        });
                    }
                    return VideoSink;
                })();
                Internal.VideoSink = VideoSink;
            })(Internal = Model_9.Internal || (Model_9.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="VideoSink.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_10) {
            var Internal;
            (function (Internal) {
                'use strict';
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var BoolProperty = Web.Utils.BoolProperty;
                var log = Web.Media.log;
                /**
                 * Represents the video stream.
                 *
                 * @created Jan 2015
                 * @blame sosobov
                 */
                var MediaStream = (function () {
                    //#endregion
                    // args are omitted when creating dummy stream models
                    function MediaStream(options) {
                        if (options === void 0) { options = {}; }
                        var state = Property({ value: Internal.MediaEnum.StreamState.Stopped }), source = Model({ sink: new Internal.VideoSink(options) }), width = Property({ value: 0 }), height = Property({ value: 0 }), 
                        // is media flowing
                        isFlowing = BoolProperty(false), 
                        // media manager channel id
                        id = Property({ value: options.id }), 
                        // is this stream attached to a participant video source
                        isAttached = Property({ value: false });
                        var self = Model({
                            state: state.asReadOnly(),
                            source: source,
                            width: width.asReadOnly(),
                            height: height.asReadOnly(),
                            _id: id,
                            _isAttached: isAttached
                        });
                        setHiddenProperty(self, '_state', state);
                        setHiddenProperty(self, '_isFlowing', isFlowing);
                        state.changed(function (newState, reason, oldState) {
                            log('MediaStream (' + id() + '): stream state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        return self;
                    }
                    return MediaStream;
                })();
                Internal.MediaStream = MediaStream;
            })(Internal = Model_10.Internal || (Model_10.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                var MediaEnum;
                (function (MediaEnum) {
                    'use strict';
                    var Enum = Web.Utils.Enum;
                    var StringEnum = Web.Utils.StringEnum;
                    MediaEnum.PreferredMediaAddressType = Enum('None', 'Direct', 'Relay');
                    MediaEnum.MediaDeviceType = Enum('MIC', 'SPEAKER', 'PREVIEW', 'RENDER');
                    MediaEnum.VideoFormat = StringEnum('Fit', 'Crop', 'Stretch');
                    MediaEnum.NegotiationStatus = Enum('NS_SUCCESS', 'NS_LOCAL_INTERNAL_ERROR', 'NS_REMOTE_INTERNAL_ERROR', 'NS_OFFER_NOT_ACCEPTABLE', 'NS_OFFER_DECLINED', 'NS_LOCAL_CANCEL', 'NS_REMOTE_CANCEL', 'NS_REMOTE_MIME_UNSPPORTED');
                    MediaEnum.MediaEvent = StringEnum('OFFER_READY', 'CHANNEL_CREATED', 'CHANNEL_DELETED', 'ANSWER_READY', 'CONNECTIVITY_CHECK_STATUS', 'MEDIA_CHANGED', 'INVALID_PROXY_CREDENTIAL');
                    MediaEnum.AVEvent = StringEnum('DEVICE_INTENSITY_CHANGED', 'VIDEO_SIZE_CHANGED', 'NEG_STATUS', 'CHANNEL_DIRECTION_CHANGED', 'CHANNEL_DISCONNECTED', 'QUALITY_CHANGED', 'AUDIO_DEVICE_CHANGED', 'VIDEO_DEVICE_CHANGED', 'DOMINANT_SPEKAER_CHANGED', // do not correct: plugin returns this typo
                    'SUBSCRIPTION_STATE_CHANGED', 'CONTRIBUTING_SOURCES_CHANGED', 'VIDEO_CAPABILITY_CHANGED');
                    MediaEnum.StreamState = StringEnum('Stopped', 'Started', 'Inactive', 'Active');
                    MediaEnum.StreamType = Enum('Preview', // self camera capture (video sent on the main video channel)
                    'MainRender', // video received on the main video channel
                    'Render' // video received on an additional video channel
                    );
                    MediaEnum.DtmfTone = Enum('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'Star', 'Pound', 'A', 'B', 'C', 'D', 'Flash');
                })(MediaEnum = Internal.MediaEnum || (Internal.MediaEnum = {}));
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="ucwa.ts" />
/// <reference path="media.ts" />
/// <reference path="model.common.ts" />
/// <reference path="model/MediaPolicies.ts" />
/// <reference path="model/MediaPlugin.ts" />
/// <reference path="model/MediaConfig.ts" />
/// <reference path="model/as/AppSharingModality.ts" />
/// <reference path="model/as/Window.ts" />
/// <reference path="model/as/Monitor.ts" />
/// <reference path="model/as/SharedResources.ts" />
/// <reference path="model/as/Invitation.ts" />
/// <reference path="model/as/AppSharing.ts" />
/// <reference path="model/av/AudioVideoModality.ts" />
/// <reference path="model/av/SDP.ts" />
/// <reference path="model/av/DevicesManager.ts" />
/// <reference path="model/av/VideoChannel.ts" />
/// <reference path="model/av/MediaStream.ts" />
/// <reference path="model/av/MediaEnum.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                /**
                 * Wraps the rel=policies resource into an observable model.
                 *
                 * rel=policies represents the admin policies that can apply to a user's application.
                 * Policies include information such as whether emoticons are allowed in messages
                 * or photos are enabled for contacts in the user's organization. Note that policies
                 * are set by the admin; they cannot be changed by the user.
                 *
                 * @created Apr 2014
                 * @blame antonkh
                 */
                var GeneralPolicies = (function () {
                    //#endregion
                    function GeneralPolicies(ucwa) {
                        return Internal.ObservableResource(ucwa, { rel: 'policies' }, function ($) {
                            $.property('audioOnlyOnWifi');
                            $.property('callLogArchiving');
                            $.property('customerExperienceImprovementProgram');
                            $.property('emergencyDialMask');
                            $.property('emergencyDialString');
                            $.property('emoticons');
                            $.property('clientExchangeConnectivity');
                            $.property('exchangeUnifiedMessaging');
                            $.property('htmlMessaging');
                            $.property('logging');
                            $.property('loggingLevel');
                            $.property('messageArchiving');
                            $.property('messagingUrls');
                            $.property('multiViewJoin');
                            $.property('onlineFeedbackUrl');
                            $.property('photos');
                            $.property('saveCallLogs');
                            $.property('saveCredentials');
                            $.property('saveMessagingHistory');
                            $.property('sendFeedbackUrl');
                            $.property('sharingOnlyOnWifi');
                            $.property('softwareQualityMetrics');
                            $.property('telephonyMode');
                            $.property('videoOnlyOnWifi');
                            $.property('voicemailUri');
                        });
                    }
                    return GeneralPolicies;
                })();
                Internal.GeneralPolicies = GeneralPolicies;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_11) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var Task = Web.Utils.Task;
                var Property = Web.Utils.Property;
                var BoolProperty = Web.Utils.BoolProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var map = Web.Utils.map;
                var isVoid = Web.Utils.isVoid;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var foreach = Web.Utils.foreach;
                var extend = Web.Utils.extend;
                var async = Web.Utils.async;
                var bind = Web.Utils.bind;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                /**
                 * The base class for PersonOrGroupSearchQuery and ConversationSearchQuery
                 *
                 * @created October 2014
                 * @owner chfang
                 */
                var SearchQuery = (function () {
                    function SearchQuery() {
                        var Scope = StringEnum('AddressBook', 'SkypeDirectory', 'All');
                        var limit = Property({
                            value: 1,
                            check: function (value) {
                                if (!(value > 0 && (value | 0) == value))
                                    throw EInvalidArgument('limit', '`limit` must be a positive integer');
                            }
                        });
                        var text = Property({
                            check: function (value) {
                                if (!isNotEmptyString(value))
                                    throw EInvalidArgument('text', '`text` must be set as a no empty query string before searching.');
                            }
                        });
                        var sources = Property({
                            value: Scope.AddressBook,
                            check: function (value) {
                                if (!(value in Scope))
                                    throw EInvalidArgument('sources', '`sources` must be set as AddressBook, SkypeDirectory, or All.');
                            }
                        });
                        return Model({
                            text: text,
                            limit: limit,
                            sources: sources
                        });
                    }
                    return SearchQuery;
                })();
                Internal.SearchQuery = SearchQuery;
                /**
                 * Inherited from SearchQuery, it represents a search query for
                 * searching persons or groups. The search results will be provided
                 * after the request of searching query is resolved by server.
                 *
                 * var searchQuery = client.personsAndGroupsManager.createPersonSearchQuery();
                 * searchQuery.text("John");
                 * searchQuery.limit(10);
                 * searchQuery.getMore().then(function () {
                 *     if (searchQuery.getMore.enabled())
                 *         console.log("More results are available on the server");
                 *     else
                 *         console.log("No more results are available on the server");
                 *
                 *     searchQuery.results().forEach(function (r) {
                 *         console.log("person:", r.result.name());
                 *     });
                 * });
                 *
                 * @created October 2014
                 * @blame chfang
                 */
                var PersonOrGroupSearchQuery = (function () {
                    //#endregion
                    function PersonOrGroupSearchQuery(options) {
                        var ucwa = options.ucwa;
                        var type = options.type;
                        var contactmgr = options.contactmgr;
                        var psm = options.psm;
                        var me = options.me;
                        var self = new SearchQuery;
                        var supportedKeywords = Collection();
                        var keywords = Model();
                        var results = Collection();
                        var moreResultsAvailable = Property({ value: false });
                        var enabled = BoolProperty(true);
                        var tm = options.tm;
                        supportedKeywords.add('id');
                        function getMore() {
                            var sLink = ucwa.get({ rel: 'people' }).link('search');
                            var email = keywords['id'] || self.text() && self.text().slice(0, 3).toLowerCase() == 'id:' &&
                                self.text().slice(3);
                            var request = {};
                            var newResults = [];
                            function isMe(res) {
                                // we can use for comparison .uri property directly,
                                // as GET /search returns all found contacts with URI loaded
                                return res.properties['uri'] === me.id();
                            }
                            function addSearchResult(res) {
                                var item = Model({
                                    result: res,
                                    matches: {},
                                    relevance: ConstProperty(null)
                                });
                                results.add(item);
                                newResults.push(item);
                            }
                            enabled(false);
                            if (email && email.length >= 1) {
                                // starting from search.revision=2 UCWA supports lookup by email
                                if (sLink.revision >= 2) {
                                    request.headers = { 'X-MS-RequiresMinResourceVersion': 2 };
                                    request.query = { mail: email };
                                }
                                else {
                                    // fallback to lookup by query text.
                                    request.query = { query: email, limit: 1 };
                                }
                            }
                            else
                                request.query = { query: isVoid(self.text()) ? '' : self.text(), limit: self.limit() };
                            // GET /search?query=abcdef&limit=50
                            return ucwa.send('GET', sLink.href, request).then(function (sr) {
                                foreach(sr.embedded, function (resource) {
                                    if (type == 'person' && resource.rel == 'contact') {
                                        // if it's a contact (excluding yourself), create a Person model,
                                        // but do not put it in any cache, since most likely
                                        // this search result will be shown only once in
                                        // the UI and then will be dismissed
                                        if (!isMe(resource)) {
                                            var person = new Internal.Person({
                                                href: resource.href,
                                                ucwa: ucwa,
                                                psm: psm
                                            });
                                            addSearchResult(person);
                                        }
                                    }
                                    else if (type == 'group' && resource.rel == 'distributionGroup') {
                                        // if it's a group, create a group model,
                                        // but do not put it in any cache, since most likely
                                        // this search result will be shown only once in
                                        // the UI and then will be dismissed
                                        var group = new Internal.Group({
                                            ucwa: ucwa,
                                            contactmgr: contactmgr,
                                            source: resource.href,
                                            tm: tm
                                        });
                                        addSearchResult(group);
                                    }
                                });
                                moreResultsAvailable(!!sr.get('moreResultsAvailable', false));
                                return newResults;
                            }, function (error) {
                                enabled(true);
                                throw error;
                            });
                        }
                        return extend(self, {
                            supportedKeywords: supportedKeywords.asReadOnly(),
                            keywords: keywords,
                            moreResultsAvailable: moreResultsAvailable.asReadOnly(),
                            getMore: Command(tm ? tm.monitored(async(getMore), 'search') : async(getMore), enabled),
                            results: results.asReadOnly()
                        });
                    }
                    return PersonOrGroupSearchQuery;
                })();
                Internal.PersonOrGroupSearchQuery = PersonOrGroupSearchQuery;
                /**
                 * It represents a search query for searching persons.
                 *
                 * It inherits from class PersonOrGroupSearchQuery with
                 * an additional parameter type = 'person' in the 'options'.
                 *
                 * @created October 2014
                 * @blame chfang
                 */
                var PersonSearchQuery = (function () {
                    function PersonSearchQuery(options) {
                        options.type = 'person';
                        return new PersonOrGroupSearchQuery(options);
                    }
                    return PersonSearchQuery;
                })();
                Internal.PersonSearchQuery = PersonSearchQuery;
                /**
                 * It represents a search query for searching groups.
                 *
                 * It inherits from class PersonOrGroupSearchQuery with
                 * an additional parameter type = 'group' in the 'options'.
                 *
                 * @created October 2014
                 * @blame chfang
                 */
                var GroupSearchQuery = (function () {
                    function GroupSearchQuery(options) {
                        options.type = 'group';
                        return new PersonOrGroupSearchQuery(options);
                    }
                    return GroupSearchQuery;
                })();
                Internal.GroupSearchQuery = GroupSearchQuery;
                /**
                 * Inherited from SearchQuery, it represents a search query for searching conversations locally.
                 *
                 * var searchQuery = client.conversationsManager.createSearchQuery();
                 * searchQuery.text("scrum planning");
                 * searchQuery.keywords['participant'] = 'frank';
                 * searchQuery.getMore().then(function () {
                 *     searchQuery.results().forEach(function (r) {
                 *         console.log("conversation  uri:", r.result.id());
                 *     });
                 * });
                 *
                 * @created October 2014
                 * @blame chfang
                 */
                var ConversationSearchQuery = (function () {
                    //#endregion
                    function ConversationSearchQuery(conversations) {
                        var self = new SearchQuery;
                        var results = Collection();
                        var supportedKeywords = Collection();
                        var keywords = Model();
                        // It is a unique exception object to be thrown in the
                        // comparing function when no 'match' is found.
                        var ne = {};
                        // An array of dictionaries, each of which has one conversation's field as the key,
                        // and its corresponding searching functions as the value.
                        // To add a new searching field for the conversation in the future,
                        // simply add a new dictionary with a new supported key and its searching function.
                        var supportedInternal = [
                            {
                                key: 'uri',
                                call: function (conv, txt) {
                                    return containsStr(conv.uri.get(), txt);
                                }
                            },
                            {
                                key: 'topic',
                                call: function (conv, txt) {
                                    return containsStr(conv.topic.get(), txt);
                                }
                            },
                            {
                                key: 'participant',
                                call: function (conv, txt) {
                                    return containsAny(conv.participants().concat([conv.selfParticipant]), txt, function (value, participant) {
                                        return containsStr(participant.name.get(), value);
                                    });
                                }
                            },
                            {
                                key: 'group',
                                call: function (conv, boolFlag) {
                                    return Task.wait(conv.isGroupConversation() != boolFlag).then(function (result) {
                                        if (result)
                                            throw ne;
                                    });
                                }
                            }
                        ];
                        /**
                         * It returns a promise, which will be resolved when 'stringA' contains 'stringB'.
                         *
                         * @param {Promise|String} stringA - A promise to be resolved as a string, or a string object.
                         *
                         * @param {Promise|String} stringB - A promise to be resolved as a string, or a string object.
                         *
                         * @returns {Promise} - Resolved when 'stringA' contains 'stringB'
                         *
                         *      An unique exception 'ne' will be thrown if 'stringA' does not contain 'stringB'.
                         *
                         * @created October 2014
                         * @blame chfang
                         */
                        function containsStr(stringA, stringB) {
                            return Task.waitAll([stringA, stringB]).then(function (resolved) {
                                if (resolved[0].toLowerCase().indexOf(resolved[1].toLowerCase()) < 0)
                                    throw ne;
                            });
                        }
                        /**
                         * It returns a promise, which will be resolved if any one in 'objects' contains 'stringA'
                         *
                         * @param {Promise|Collection} objects - A promise to be resolved a collection, or a collection object.
                         *
                         * @param {Promise|String} stringA - A promise to be resolved as a string,  or a object string.
                         *
                         * @param {Function} compareFunction - A function to compare the  one object's property with 'stringA'
                         *
                         *      It should throw the 'ne' exception if the object's property does not contain 'stringA'.
                         *
                         * @returns {Promise} - Resolved if any object contains 'stringA'.
                         *
                         *      An unique exception 'ne' will be thrown if none of objects contains 'stringA'.
                         *
                         * @created October 2014
                         * @blame chfang
                         */
                        function containsAny(objects, stringA, compareFunction) {
                            return Task.waitAll([objects, stringA]).then(function (resolved) {
                                // if objects is null, consider it as there is no 'match' found.
                                if (resolved[0].length == 0)
                                    throw ne;
                                return Task.waitAny(map(resolved[0], bind(compareFunction, resolved[1])));
                            });
                        }
                        // Returns a promise, which will be resolved if the conversation
                        // has a 'match' for the search query and keywords. Otherwise,
                        // it throws the unique 'ne' exception.
                        function compareConversation(conv) {
                            // check whether any one of conversation's fields contains 'text'
                            var pText = Task.waitAny(map(supportedInternal, function (field) {
                                return field.call(conv, self.text());
                            }));
                            // check whether each conversation's field contains its corresponding keyword's value if provided.
                            var pKW = Task.waitAll(map(supportedInternal, function (field) {
                                if (!isVoid(keywords[field.key])) {
                                    return field.call(conv, keywords[field.key]);
                                }
                            }));
                            // wait for both a 'match' in text property AND a 'match' in all provided keywords
                            return Task.waitAll([pText, pKW]);
                        }
                        function getMore() {
                            var newResults = [];
                            var convs = conversations();
                            var mConvs = map(convs, function (conv) {
                                return compareConversation(conv).then(function () {
                                    var item = {
                                        result: conv,
                                        matches: {},
                                        relevance: ConstProperty(null)
                                    };
                                    results.add(item);
                                    newResults.push(item);
                                }, function (error) {
                                    if (error != ne)
                                        throw error;
                                });
                            });
                            return Task.waitAll(mConvs).then(function () {
                                return newResults;
                            });
                        }
                        foreach(supportedInternal, function (field) {
                            supportedKeywords.add(field.key);
                        });
                        return extend(self, {
                            supportedKeywords: supportedKeywords.asReadOnly(),
                            keywords: keywords,
                            limit: ConstProperty(null),
                            moreResultsAvailable: ConstProperty(false),
                            getMore: EnabledCommand(async(getMore)),
                            results: results.asReadOnly()
                        });
                    }
                    return ConversationSearchQuery;
                })();
                Internal.ConversationSearchQuery = ConversationSearchQuery;
            })(Internal = Model_11.Internal || (Model_11.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_12) {
            var Internal;
            (function (Internal) {
                'use strict';
                var assert = Web.Utils.assert;
                var Command = Web.Utils.Command;
                var BoolProperty = Web.Utils.BoolProperty;
                var extend = Web.Utils.extend;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var isObject = Web.Utils.isObject;
                var isPromise = Web.Utils.isPromise;
                var foreach = Web.Utils.foreach;
                var Property = Web.Utils.Property;
                var NumProperty = Web.Utils.NumProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var ComputedProperty = Web.Utils.ComputedProperty;
                var Collection = Web.Utils.Collection;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var EDoesNotExist = Web.Utils.EDoesNotExist;
                var ENotSupported = Web.Utils.ENotSupported;
                var Task = Web.Utils.Task;
                var debug = Web.Utils.debug;
                var filter = Web.Utils.filter;
                var Model = Web.Utils.Model;
                /**
                 * A group that holds a collection of contacts and nested groups.
                 *
                 * An instance of Group represents a group of contacts, which
                 * can come from one of many sources:
                 *
                 *      -   the contact list that includes all contacts
                 *      -   a distribution group
                 *      -   a relationship group like Colleagues, Workgroup, Blocked
                 *      -   a user-created or a server-created group of contacts
                 *
                 * These sources are similar in a sense that they encapsulate a contact list,
                 * but the access path to that list may differ:
                 *
                 *     -    myContacts / contact[i]
                 *     -    myPrivacyRelationship / contact[i]
                 *     -    distributionGroup / contact[i]
                 *     -    pinnedGroup / groupContacts / contact[i]
                 *     -    defaultGroup / groupContacts / contact[i]
                 *     -    group / groupContacts / contact[i]
                 *
                 * For instance to get the list of rel=contact resources for a rel=group,
                 * the model at first gets rel=group, then it finds rel=groupContacts link
                 * in it, sends a GET to that link and finds rel=contact links in the response.
                 * To get the list of contacts for rel=myContacts and rel=myPrivacyRelationship
                 * it's enough to send a GET to these resources; in case of rel=distributionGroup
                 * the model sends a GET to distributionGroup/expandDistributionGroup.
                 *
                 * @created Aug 2013
                 * @blame antonkh
                 * @blame yodu
                 */
                var Group = (function () {
                    //#endregion
                    function Group(options) {
                        var ucwa = options.ucwa;
                        var source = options.source;
                        var contactmgr = options.contactmgr;
                        var subscribe = options.subscribe;
                        var unsubscribe = options.unsubscribe;
                        // source can be the href string or Promise<String>
                        var rGroup = source && !isPromise(source) && ucwa.get(source);
                        var self = Model();
                        var properties = {};
                        var rGroupMemberships = options.groupMemberships;
                        var tm = options.tm;
                        var mgmtRevision = NumProperty();
                        var isMgmtRevisionKnown = BoolProperty(false);
                        var isSignedIn = BoolProperty(false);
                        // enable person management APIs properly if the resource
                        // revision is already loaded; otherwise enable the APIs
                        // so that they can be called, at which point the resource
                        // revision will be loaded and the APIs will be enabled
                        // or disabled properly
                        var personMgmtEnabled = ComputedProperty([mgmtRevision, isMgmtRevisionKnown, isSignedIn], function (r) { return r >= 2 || !r && !isMgmtRevisionKnown() && isSignedIn(); });
                        var persons = Collection({
                            get: loadContactsAndNestedGroups,
                            subscribed: subscribeContactsAndGroups,
                            unsubscribed: unsubscribeContactsAndGroups
                        });
                        var groups = Collection({
                            get: loadContactsAndNestedGroups,
                            subscribed: subscribeContactsAndGroups,
                            unsubscribed: unsubscribeContactsAndGroups
                        });
                        var types = {
                            group: 'Custom',
                            defaultGroup: 'Others',
                            pinnedGroup: 'Favorites',
                            distributionGroup: 'Distribution',
                            myPrivacyRelationship: 'PrivacyRelationship'
                        };
                        var dfdInfo; // tracks the progress of `loadInfo`
                        var dfdContacts; // tracks the progress of `loadContactsAndNestedGroups`
                        function subscribeContactsAndGroups() {
                            if (subscribe)
                                subscribe();
                            loadContactsAndNestedGroups();
                        }
                        function unsubscribeContactsAndGroups() {
                            if (unsubscribe)
                                unsubscribe();
                        }
                        function importContacts(resource) {
                            // TODO: the list of contacts on the server may be a subset
                            // of the list of contacts known to the client; in this case
                            // some contacts must be deleted from the list
                            foreach(resource.related.contact || [], function (link) {
                                if (!persons(link.href))
                                    persons.add(contactmgr.get(link.href), link.href);
                            });
                        }
                        function importGroups(r) {
                            foreach(r.links('distributionGroup'), function (link) {
                                if (!groups(link.href)) {
                                    var nestedGroup = new Group({
                                        source: link.href,
                                        ucwa: ucwa,
                                        contactmgr: contactmgr,
                                        subscribe: subscribe,
                                        unsubscribe: unsubscribe,
                                        tm: tm
                                    });
                                    groups.add(nestedGroup, link.href);
                                }
                            });
                        }
                        function getContactUri(contact) {
                            if (!contact || !(isObject(contact) || isNotEmptyString(contact)))
                                throw EInvalidArgument('contact', 'the given value is not a Person model or valid URI');
                            return Task.wait(null).then(function () {
                                return contact.id ? contact.id.get() : contact;
                            });
                        }
                        /*
                         * Add a contact to this Group.
                         *
                         * add operation is a POST request of the form:
                         * "POST /groupMemberships?groudId=...&contactUri=..."
                         * where the href is obtained via the 'myGroupMemberships' link, and
                         * the 'groupId=<gid>' query part can be omitted for the default group.
                         *
                         * Note: UCWA allows contact to be added to certain (but not all)
                         * groups. We will let UCWA respond to operations that are not allowed.
                         *
                         * @param {String|Person} contact - a contact URI or Person object
                         * @returns {Promise}
                         * @created yodu, May 2014
                         */
                        function addContact(contact) {
                            var dfdAdd = getContactUri(contact).then(function (uri) {
                                return Task.wait(null).then(function () {
                                    return self.id.get();
                                }).then(function () {
                                    return rGroup.get('id');
                                }).then(function (gid) {
                                    return initPersonMgmtAPI().then(function () {
                                        return ucwa.send('POST', { rel: 'myGroupMemberships' }, {
                                            headers: { 'X-MS-RequiresMinResourceVersion': 2 /* AddPerson */ },
                                            // no need to pass the gid if this is the default group
                                            query: rGroup.rel == 'defaultGroup' ?
                                                { contactUri: uri } :
                                                { groupId: gid, contactUri: uri }
                                        });
                                    });
                                }, function (error) {
                                    // the group does not have an id
                                    // wrap the ucwa error inside an ENotSupported error
                                    throw ENotSupported(error);
                                });
                            });
                            tm && tm.monitor(dfdAdd, 'contact_add');
                            return dfdAdd;
                        }
                        /*
                         * Filter the myGroupMembership resources that match the current group
                         * and the contact href passed in.
                         *
                         * @param {String} contactHref - the contact href
                         * @returns {Array<Resource>} - an array of matched resources
                         * @created yodu, June 2014
                         */
                        function filterMembershipLinks(contactHref) {
                            return filter(rGroupMemberships.links('myGroupMembership'), function (link) {
                                var gm = ucwa.get(link.href);
                                return gm.hasLink(rGroup.rel) &&
                                    gm.link(rGroup.rel).href == rGroup.href &&
                                    gm.link('contact').href == contactHref;
                            });
                        }
                        /*
                         * Retrieve the link to remove a contact from this Group.
                         *
                         * @param {Person} contact - a Person object
                         * @returns {Promise<String>} - a promise containing the link href
                         * @created yodu, May 2014
                         */
                        function getMembershipLink(contact) {
                            if (!contact || !contact.id)
                                throw EInvalidArgument('contact', 'the given value is not a Person model');
                            // always load myGroupMemberships to prevent out of sync with UCWA
                            // TODO: batch process multiple remove requests in sequence
                            return ucwa.send('GET', rGroupMemberships.href).then(function () {
                                // exactly one link needs to be available
                                var membershipLinks = filterMembershipLinks(contact[Internal.sHref]);
                                if (membershipLinks.length != 1) {
                                    if (rGroup.rel == 'distributionGroup' ||
                                        rGroup.rel == 'myPrivacyRelationship') {
                                        // contact management is currently not supported for
                                        // DG and privacy relationship, so throw a more
                                        // meaningful error. Need to remove this special
                                        // handling once support becomes available
                                        throw ENotSupported(EDoesNotExist(contact));
                                    }
                                    else {
                                        throw EDoesNotExist(contact);
                                    }
                                }
                                return membershipLinks[0].href;
                            });
                        }
                        /*
                         * Remove a contact from this Group.
                         *
                         * remove operation is a DELETE request of the form:
                         * "DELETE /groupMemberships/...,..."
                         * where the href must be one of the 'myGroupMembership' links, and
                         * the comma separated parts are group ID and contact uri.
                         *
                         * Note: UCWA allows contact to be removed from certain (but not all)
                         * groups. We will let UCWA respond to operations that are not allowed.
                         *
                         * @param {Person} contact - a Person object
                         * @returns {Promise}
                         * @created yodu, May 2014
                         */
                        function removeContact(contact) {
                            var dfdRemove = getMembershipLink(contact).then(function (href) {
                                return initPersonMgmtAPI().then(function () {
                                    return ucwa.send('DELETE', href, {
                                        headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemovePerson */ }
                                    });
                                });
                            });
                            tm && tm.monitor(dfdRemove, 'contact_remove');
                            return dfdRemove;
                        }
                        //#region rename
                        /*
                         * Rename a group.
                         *
                         * renaming group is a PUT request of the form:
                         * "PUT /people/groups/<groupId>"
                         * where the data passed in the request contains the following properties:
                         * {
                         *      rel: 'group',
                         *      name: 'new group name',
                         *      id: '<group id>',
                         *      etag: '<some etag>',
                         *      <some-guid>: 'please pass this in a PUT request'
                         * }
                         * Except for the new name, all other properties should be directly
                         * associated with and obtained from the current group resource. The
                         * etag value will be inserted as the 'if-match' value in the header
                         * of the PUT request.
                         *
                         * Note: UCWA allows renaming for certain (but not all) groups. We will
                         * let UCWA respond to operations that are not allowed.
                         *
                         * @param {String} name - the new name specified
                         * @returns {Promise}
                         * @created yodu, August 2014
                         */
                        function rename(name) {
                            tm && tm.record('group_rename');
                            if (!isNotEmptyString(name))
                                throw EInvalidArgument('name', 'The new name must be a non empty string.');
                            return !rGroup ? name : loadInfo().then(function () {
                                return initPersonMgmtAPI();
                            }).then(function () {
                                return ucwa.send('PUT', rGroup.href, {
                                    headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RenameGroup */ },
                                    data: extend(rGroup.getSnapshot(), { name: name })
                                }).then(function () {
                                    // currently this PUT request results in a new group
                                    // created with the new name and the old group deleted.
                                    // The on success promise of this request will be used to
                                    // update the name of the old group, so we need to return
                                    // the name of the old group to make that update correct.
                                    return rGroup.get('name');
                                });
                            });
                        }
                        //#endregion
                        /*
                         * Enable person and group management APIs if supported.
                         */
                        function initPersonMgmtAPI() {
                            return ucwa.getRevisionOf(rGroupMemberships).then(function () {
                                isMgmtRevisionKnown(true);
                                if (!personMgmtEnabled())
                                    throw ENotSupported();
                            });
                        }
                        /**
                         * Expands the group by sending a GET request to the server
                         * and returns a promise that tracks the progress of that request.
                         * Note, that big distribution groups cannot be expanded, as
                         * the server returns a HTTP 403 with a "too many contacts" message
                         * in the response body.
                         *
                         * @returns {Promise}
                         */
                        function expand() {
                            // for regular groups
                            if (rGroup.hasLink('groupContacts'))
                                return ucwa.send('GET', rGroup.link('groupContacts').href);
                            // for distribution groups
                            if (rGroup.hasLink('expandDistributionGroup'))
                                return ucwa.send('GET', rGroup.link('expandDistributionGroup').href);
                            return new Task().reject(new Error('Missing the group expansion link.')).promise;
                        }
                        /**
                         * Adds a new observable property to the instance of Group.
                         * The given setter defines how to update the property.
                         */
                        function define(name, set) {
                            assert(!self[name]);
                            var p = Property({
                                subscribed: loadInfo,
                                get: function () {
                                    return loadInfo().then(function () {
                                        // a handler for the rGroup:updated event
                                        // has already updated this property
                                        return p();
                                    });
                                },
                                set: set
                            });
                            properties[name] = p;
                            self[name] = set ? p : p.asReadOnly();
                        }
                        function loadInfo() {
                            return Task.wait(source).then(function (href) {
                                dfdInfo = dfdInfo || ucwa.send('GET', href);
                                return dfdInfo;
                            });
                        }
                        function loadContactsAndNestedGroups() {
                            dfdContacts = dfdContacts || loadInfo().then(function () {
                                importContacts(rGroup);
                                importGroups(rGroup);
                                // these two group types do not need to be expanded
                                // since they do not have expansion links
                                if (rGroup.rel != 'myPrivacyRelationship' && rGroup.rel != 'myContacts') {
                                    return expand().then(function (r) {
                                        importContacts(r);
                                        importGroups(r);
                                    });
                                }
                            });
                            return dfdContacts;
                        }
                        function handleUcwaEvent(event) {
                            var scope = event['in'] || {};
                            var link = event.target || {};
                            if (scope.href == rGroup.href) {
                                if (event.type == 'deleted') {
                                    // if the contact does not exist in the collection,
                                    // nothing will happen
                                    persons.remove(link.href);
                                }
                                if (event.type == 'added') {
                                    if (!persons(link.href))
                                        persons.add(contactmgr.get(link.href), link.href);
                                }
                            }
                        }
                        define('name', rename);
                        define('uri');
                        define('relationshipLevel');
                        define('id');
                        Task.wait(source, 'sync').then(function (href) {
                            isSignedIn(true);
                            rGroup = rGroup || ucwa.get(href);
                            if (rGroup.rel != 'myPrivacyRelationship')
                                properties.relationshipLevel('None');
                            rGroup.updated(function () {
                                foreach(properties, function (p, name) {
                                    if (name in rGroup.properties)
                                        p(rGroup.properties[name], Property.sUpdated);
                                });
                            });
                            rGroupMemberships = rGroupMemberships || ucwa.get({ rel: 'myGroupMemberships' });
                            rGroupMemberships.updated(function () {
                                var rev = rGroupMemberships.link('self').revision;
                                mgmtRevision(+rev);
                            });
                            // the server tells over the event channel when a contact gets
                            // added to the group or removed from it
                            ucwa.event(handleUcwaEvent);
                            rGroup.deleted(function () {
                                ucwa.event.off(handleUcwaEvent);
                            });
                            try {
                                // import immediate contacts from rel=this/rel=contact[i]
                                importContacts(rGroup);
                            }
                            catch (err) {
                                debug.log('Failed to import persons for ' + rGroup.href + ': ' + err);
                            }
                            try {
                                // import immediate groups from rel=this/rel=distributionGroup[i]
                                importGroups(rGroup);
                            }
                            catch (err) {
                                debug.log('Failed to import groups for ' + rGroup.href + ': ' + err);
                            }
                            try {
                                // import indirect persons from rel=this/rel=groupContacts/rel=contact[i]
                                importContacts(ucwa.get(rGroup.link('groupContacts').href));
                            }
                            catch (_) {
                            }
                            // sHref will be a hidden symbol for Group objects
                            setHiddenProperty(self, Internal.sHref, rGroup.href);
                        });
                        // The add/remove methods of a Group object need to be overridden
                        // to do different things:
                        // 1) For a regular Group, add/remove are used to add/remove a
                        //    contact to/from the group.
                        // 2) For the root group that represents the "contact list", i.e.,
                        //    client.personsAndGroupsManager.all.persons, the add method is
                        //    not supported, and the remove method is used to remove a contact
                        //    from all groups.
                        return extend(self, {
                            avatarUrl: ConstProperty(null),
                            type: ConstProperty(types[rGroup && rGroup.rel || 'group']),
                            groups: groups.asReadOnly(),
                            persons: persons.asWritable({
                                add: Command(addContact, personMgmtEnabled),
                                remove: Command(removeContact, personMgmtEnabled)
                            })
                        });
                    }
                    return Group;
                })();
                Internal.Group = Group;
            })(Internal = Model_12.Internal || (Model_12.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_13) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Command = Web.Utils.Command;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var DisabledCommand = Web.Utils.DisabledCommand;
                var BoolProperty = Web.Utils.BoolProperty;
                var indexOf = Web.Utils.indexOf;
                var foreach = Web.Utils.foreach;
                var NumProperty = Web.Utils.NumProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var ComputedProperty = Web.Utils.ComputedProperty;
                var Collection = Web.Utils.Collection;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var ENotSupported = Web.Utils.ENotSupported;
                var Exception = Web.Utils.Exception;
                var Task = Web.Utils.Task;
                var findIndex = Web.Utils.findIndex;
                var Model = Web.Utils.Model;
                /**
                 * The root group holds the list of all contacts and all groups known to the client.
                 * Those groups include the user-created,  server-created and relationship groups.
                 *
                 * @created Aug 2013
                 * @blame antonkh
                 * @blame yodu
                 */
                var RootGroup = (function () {
                    //#endregion
                    function RootGroup(_a) {
                        var ucwa = _a.ucwa, contactmgr = _a.contactmgr, tm = _a.tm;
                        var groupRels = ['group', 'pinnedGroup', 'distributionGroup', 'defaultGroup'];
                        var persons = Collection({
                            get: loadContacts,
                            subscribed: function () { return handleSubscribe(loadContacts); },
                            unsubscribed: unsubscribe
                        });
                        var groups = Collection({
                            get: loadGroups,
                            subscribed: function () { return handleSubscribe(loadGroups); },
                            unsubscribed: unsubscribe
                        });
                        var mgmtRevision = NumProperty();
                        var isMgmtRevisionKnown = BoolProperty(false);
                        var isSignedIn = BoolProperty(false);
                        // enable group management APIs properly if the resource
                        // revision is already loaded; otherwise enable the APIs
                        // so that they can be called, at which point the resource
                        // revision will be loaded and the APIs will be enabled
                        // or disabled properly
                        var groupMgmtEnabled = ComputedProperty([mgmtRevision, isMgmtRevisionKnown, isSignedIn], function (r) { return r >= 2 || !r && !isMgmtRevisionKnown() && isSignedIn(); });
                        // these 2 arrays are used to manage delayed loading of locally
                        // created (pending) groups. A pending group is a Group object
                        // created by the 'PersonsAndGroupsManager.createGroup' method
                        // (which delegates to the 'createLocalGroup' method). A pending group
                        // is not assigned an href until the user requests to add it to ucwa
                        // successfully, and receives the 'group added' event from ucwa.
                        // See the 'createLocalGroup' method for detailed explanations.
                        var pendingHrefs = [];
                        var pendingGroups = [];
                        var rSubscriptions; // rel=myContactsAndGroupsSubscription
                        var rGroupMemberships; // rel=myGroupMemberships
                        var rContacts; // rel=myContacts
                        var rGroups; // rel=myGroups
                        var rPrivacyRelationships; // rel=myPrivacyRelationships
                        var hTimer; // renews subscription
                        var dtSubscription = 30; // minutes
                        var nSubscriptions = 0; // avoid duplicate (un)subscriptions
                        function createGroup(source) {
                            return new Internal.Group({
                                source: source,
                                ucwa: ucwa,
                                contactmgr: contactmgr,
                                subscribe: subscribe,
                                unsubscribe: unsubscribe,
                                groupMemberships: rGroupMemberships,
                                tm: tm
                            });
                        }
                        /**
                         * first subscription when myContactsAndGroupsSubscription
                         * is not 'Connected' ('Disconnected' or 'Connecting') shall
                         * make its state from 'Disconnected' to 'Connecting' and
                         * finally to 'Connected'. This process shall trigger
                         * 'contact added' and 'group added' events from UCWA to
                         * populate contact list.
                         *
                         * first subscription when myContactsAndGroupsSubscription
                         * is already 'Connected' will not trigger 'contact added'
                         * and 'group added' events from UCWA; so need to GET
                         * contacts/groups in order to populate contact list.
                         *
                         * subsequent subscription shall be a noop (indicated by
                         * subscribe throwing an exception, which is ignored).
                         */
                        function handleSubscribe(load) {
                            subscribe().then(function () {
                                if (rSubscriptions.get('state') == 'Connected')
                                    load();
                            });
                        }
                        function loadContacts() {
                            return ucwa.init().then(function () {
                                return ucwa.send('GET', { rel: 'myContacts' }).then(importContacts);
                            }).then(function () {
                                tm && tm.record('contacts_load', { nContacts: persons.size() });
                            });
                        }
                        function loadGroups() {
                            return ucwa.init().then(function () {
                                return Task.waitAll([
                                    ucwa.send('GET', { rel: 'myGroups' }).then(importGroups),
                                    ucwa.send('GET', { rel: 'myPrivacyRelationships' }).then(importRelationships)
                                ]).then(function () {
                                    tm && tm.record('groups_load', { nGroups: groups.size() });
                                    return;
                                });
                            });
                        }
                        function importContacts(r) {
                            foreach(r.related.contact || [], function (link) {
                                if (!persons(link.href))
                                    persons.add(contactmgr.get(link.href), link.href);
                            });
                        }
                        function importGroups(r) {
                            foreach(groupRels, function (rel) {
                                foreach(r.links(rel), function (link) {
                                    if (!groups(link.href))
                                        groups.add(createGroup(link.href), link.href);
                                });
                            });
                        }
                        function importRelationships(r) {
                            foreach(r.links('myPrivacyRelationship'), function (link) {
                                if (!groups(link.href))
                                    groups.add(createGroup(link.href), link.href);
                            });
                        }
                        /*
                        * Add method is currently not supported for the contact list.
                        *
                        * This method is not supported because contact list is the sum of all
                        * other groups therefore adding a contact to it is ambiguous - it is
                        * not clear which group the contact should be added to.
                        */
                        function addContactToContactList() {
                            throw ENotSupported();
                        }
                        //#region removeContactFromAllGroups
                        /*
                         * Remove a contact from all groups.
                         *
                         * removeContactFromAllGroups is a POST request of the form:
                         * "POST /groupMemberships/removeContactFromAllGroups?contactUri=..."
                         * where the href is obtained via the 'removeContactFromAllGroups' link.
                         *
                         * Note: the contact may not have been deleted when this request returns.
                         * It is actually removed from the group after UCWA sends the "contact deleted"
                         * event.
                         *
                         * Note: UCWA allows contact to be removed from certain (but not all)
                         * groups. We will let UCWA respond to operations that are not allowed.
                         *
                         * @param {Contact} contact - a Person object
                         * @returns {Promise}
                         * @created yodu, May 2014
                         */
                        function removeContactFromAllGroups(contact) {
                            tm && tm.record('contact_remove');
                            if (!contact || !contact.id)
                                throw EInvalidArgument('contact', 'the given value is not a Person model');
                            return contact.id.get().then(function (uri) {
                                // always load myGroupMemberships to prevent out of sync with UCWA
                                // TODO: batch process multiple remove requests in sequence
                                return ucwa.send('GET', rGroupMemberships.href).then(function () {
                                    return initGroupMgmtAPI();
                                }).then(function () {
                                    return ucwa.send('POST', rGroupMemberships.link('removeContactFromAllGroups').href, {
                                        query: { contactUri: uri },
                                        headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemovePersonFromAllGroups */ }
                                    });
                                });
                            });
                        }
                        //#endregion
                        function fetchLink(rel) {
                            return ucwa.exists({ rel: rel }) ?
                                Task.wait({ href: ucwa.get({ rel: rel }).href }) :
                                ucwa.send('GET', rSubscriptions.href).then(function (r) {
                                    return r.link(rel);
                                });
                        }
                        function subscribe() {
                            nSubscriptions++;
                            return ucwa.init().then(function () {
                                // exception is used for caller to skip loadContacts/loadGroups
                                if (nSubscriptions > 1)
                                    throw Exception('AlreadySubscribed');
                                return fetchLink('startOrRefreshSubscriptionToContactsAndGroups');
                            }).then(function (link) {
                                function renew() {
                                    return ucwa.send('POST', link.href, {
                                        query: { duration: dtSubscription }
                                    });
                                }
                                renew(); // subscribe once
                                hTimer = Web.setInterval(function () {
                                    renew().then(null, unsubscribe); // and cancel subscription if something went wrong
                                }, dtSubscription * 60 * 1000);
                            });
                        }
                        function unsubscribe() {
                            nSubscriptions--;
                            if (nSubscriptions > 0)
                                return;
                            ucwa.init().then(function () {
                                Web.clearInterval(hTimer);
                                fetchLink('stopSubscriptionToContactsAndGroups').then(function (link) {
                                    return ucwa.send('POST', link.href);
                                });
                            });
                        }
                        /* A typical scenario to create a group and add it to the server
                         * consists of 4 steps: (pgm = client.personsAndGroupsManager)
                         *  1) Create a local group: g = pgm.createGroup()
                         *  2) Set the name of group: g.name("G1")
                         *  3) Request to add on server: pgm.all.groups.add(g)
                         *  4) Handling "group added" event: g is finally added
                         *
                         * These problems need to be solved to implement this scenario:
                         *  - both step 3 and step 4 are async
                         *  - the group is not added until after step 4
                         *  - the event in step 4 does not contain the group object in the
                         *    previous 3 steps
                         *  - the group object g is created in step 1 but loaded in step 4
                         *
                         * So the main issue is to correlate group g with the "group added"
                         * event, and load group resource when the right event is received.
                         *
                         * To solve the problem, we use a pattern used in the Conversation
                         * and Participant models (for adding a Participant object to the
                         * Conversation and load it later). The basic idea is as follows:
                         *
                         *  in step 1): create promise p to pass to Group constructor,
                         *      which will attach any resource-dependent operations with the
                         *      then clause of the promise. In addition, add p to an array
                         *      pendingHrefs and g to another array pendingGroups
                         *  in step 4): retrieve groupName from event; iterate pendingGroups
                         *      to locate g by name; add g to the groups collection; resolve
                         *      corresponding promise p in pendingHrefs (which will load the
                         *      group resource for g); deleting g from pendingGroups and p
                         *      from pendingHrefs
                         */
                        function createLocalGroup() {
                            tm && tm.record('group_create');
                            var dfd = new Task(), group = createGroup(dfd.promise);
                            pendingHrefs.push(dfd);
                            pendingGroups.push(group);
                            return group;
                        }
                        /*
                         * Add a user defined group to the contact list.
                         *
                         * The group specified is either a locally created group object
                         * or a group object obtained from search. This operation is to
                         * request UCWA to add the group to the contact list.
                         *
                         * It is a POST request of the form:
                         * "POST /people/groups"
                         * where the body of the request shall contain an object:
                         * { 'displayName': 'group name' }.
                         *
                         * @param {Group} group - the Group object to be created on UCWA
                         * @returns {Promise}
                         * @created yodu, August 2014
                         */
                        function addNewGroup(group) {
                            var name = group.name();
                            if (!isNotEmptyString(name))
                                throw EInvalidArgument('name', 'The group name must be a non empty string.');
                            return initGroupMgmtAPI().then(function () {
                                var dfdAdd = ucwa.send('POST', { rel: 'myGroups' }, {
                                    data: { displayName: name },
                                    headers: { 'X-MS-RequiresMinResourceVersion': 2 /* AddGroup */ }
                                });
                                tm && tm.monitor(dfdAdd, 'group_add', { type: group.type() });
                                return dfdAdd;
                            });
                        }
                        /*
                         * Add an existing distribution group to the contact list.
                         *
                         * add operation is a POST request of the form:
                         * "POST /people/groups/addToContactList?displayName=<dlname>&smtpAddress=<group@sample.com>"
                         * where the actual link used in this operation must exist on this group resource.
                         *
                         * @param {Group} group - the Group object to be added
                         * @returns {Promise}
                         * @created yodu, August 2014
                         */
                        function addDG(group) {
                            var link = ucwa.get(group[Internal.sHref]).link('addToContactList');
                            var dfdAdd = ucwa.send('POST', link.href);
                            tm && tm.monitor(dfdAdd, 'group_add', { type: group.type() });
                            return dfdAdd;
                        }
                        /*
                         * Depending on the argument specified, either create a new user defined
                         * group in the contact list, or add an existing distribution group to
                         * the contact list.
                         *
                         * @param {Group} group - the Group object to be added
                         * @returns {Promise}
                         * @created yodu, August 2014
                         */
                        function addGroup(group) {
                            return group.type() == 'Distribution' ? addDG(group) : addNewGroup(group);
                        }
                        /*
                         * Delete a user defined group from the contact list.
                         *
                         * delete operation is a DELETE request of the form:
                         * "DELETE /people/groups/<groupId>"
                         * where the actual link used in this operation is the href of this group resource.
                         *
                         * @param {Group} group - the Group object to be deleted
                         * @returns {Promise}
                         * @created yodu, August 2014
                         */
                        function deleteGroup(group) {
                            return initGroupMgmtAPI().then(function () {
                                var dfdRemove = ucwa.send('DELETE', group[Internal.sHref], {
                                    headers: { 'X-MS-RequiresMinResourceVersion': 2 /* RemoveGroup */ }
                                });
                                tm && tm.monitor(dfdRemove, 'group_remove', { type: group.type() });
                                return dfdRemove;
                            });
                        }
                        /*
                         * Remove a distribution group from the contact list.
                         *
                         * add operation is a POST request of the form:
                         * "POST /people/groups/removeFromContactList?<groupId=mygid>"
                         * where the actual link used in this operation must exist on this group resource.
                         *
                         * @param {Group} group - the Group object to be added
                         * @returns {Promise}
                         * @created yodu, August 2014
                         */
                        function removeDG(group) {
                            var link = ucwa.get(group[Internal.sHref]).link('removeFromContactList');
                            var dfdRemove = ucwa.send('POST', link.href);
                            tm && tm.monitor(dfdRemove, 'group_remove', { type: group.type() });
                            return dfdRemove;
                        }
                        /*
                         * Depending on the argument specified, either delete a user defined
                         * group from the contact list, or remove a distribution group from
                         * the contact list.
                         *
                         * @param {Group} group - a Group object to be removed
                         * @returns {Promise}
                         * @created yodu, August 2014
                         */
                        function removeGroup(group) {
                            var rel = ucwa.get(group[Internal.sHref]).rel;
                            if (rel == 'group')
                                return deleteGroup(group); // delete a user defined group
                            else if (rel == 'distributionGroup')
                                return removeDG(group); // remove a distribution group
                            else
                                throw ENotSupported({ groupType: rel });
                        }
                        /*
                         * Enable person and group management APIs if supported.
                         */
                        function initGroupMgmtAPI() {
                            return ucwa.getRevisionOf(rGroupMemberships).then(function () {
                                isMgmtRevisionKnown(true);
                                rGroupMemberships.set('qqq', true);
                                if (!groupMgmtEnabled())
                                    throw ENotSupported();
                            });
                        }
                        ucwa.init().then(function () {
                            isSignedIn(true);
                            // all these resources are missing in the anonymous mode
                            rGroupMemberships = ucwa.get({ rel: 'myGroupMemberships' }, null);
                            rSubscriptions = ucwa.get({ rel: 'myContactsAndGroupsSubscription' }, null);
                            rContacts = ucwa.get({ rel: 'myContacts' }, null);
                            rGroups = ucwa.get({ rel: 'myGroups' }, null);
                            rPrivacyRelationships = ucwa.get({ rel: 'myPrivacyRelationships' }, null);
                            if (rContacts)
                                importContacts(rContacts);
                            if (rGroups)
                                importGroups(rGroups);
                            if (rPrivacyRelationships)
                                importRelationships(rPrivacyRelationships);
                            if (rGroupMemberships) {
                                rGroupMemberships.updated(function () {
                                    var rev = rGroupMemberships.link('self').revision;
                                    mgmtRevision(+rev);
                                });
                            }
                        });
                        // the server tells over the event channel when a group gets added or removed;
                        // these events are not available for the relationship groups
                        ucwa.event(function (event) {
                            var scope = event['in'] || {}, link = event.target, href = link.href;
                            // these events are not available for the relationship groups
                            if (indexOf(groupRels, link.rel) >= 0) {
                                if (scope.rel == 'myGroups') {
                                    if (event.type == 'deleted') {
                                        // nothing will happen if the href is not in the collection
                                        groups.remove(href);
                                    }
                                    else if (event.type == 'added' && !groups(href)) {
                                        if (pendingGroups.length > 0) {
                                            Task.wait(null).then(function () {
                                                if (!ucwa.get(href).has('name'))
                                                    return ucwa.send('GET', href);
                                            }).then(function () {
                                                var i = findIndex(pendingGroups, function (g) {
                                                    return g.name() == ucwa.get(href).get('name');
                                                });
                                                if (i >= 0) {
                                                    pendingHrefs[i].resolve(href);
                                                    groups.add(pendingGroups[i], href);
                                                    pendingGroups.splice(i, 1);
                                                    pendingHrefs.splice(i, 1);
                                                }
                                                else {
                                                    groups.add(createGroup(href), href);
                                                }
                                            });
                                        }
                                        else {
                                            groups.add(createGroup(href), href);
                                        }
                                    }
                                }
                                else if (link.rel == 'group' && event.type == 'updated' && groups(href)) {
                                    // group updated, get its latest values, the group model will
                                    // be updated automatically once the resource arrives
                                    ucwa.send('GET', href);
                                }
                            }
                            if (scope.rel == 'myContacts') {
                                if (event.type == 'added' && !persons(href)) {
                                    persons.add(contactmgr.get(href), href);
                                }
                                else if (event.type == 'deleted') {
                                    persons.remove(href);
                                }
                            }
                        });
                        return Model({
                            id: ConstProperty(null),
                            name: ConstProperty(null),
                            uri: ConstProperty(null),
                            avatarUrl: ConstProperty(null),
                            type: ConstProperty('Root'),
                            relationshipLevel: ConstProperty('None'),
                            createGroup: EnabledCommand(createLocalGroup),
                            // these commands are disabled when not signed in to
                            // simplify their implementation
                            persons: persons.asWritable({
                                // disable add method: currently not supported
                                add: DisabledCommand(addContactToContactList),
                                remove: Command(removeContactFromAllGroups, groupMgmtEnabled)
                            }),
                            groups: groups.asWritable({
                                add: Command(addGroup, groupMgmtEnabled),
                                remove: Command(removeGroup, groupMgmtEnabled)
                            })
                        });
                    }
                    return RootGroup;
                })();
                Internal.RootGroup = RootGroup;
                var RootGroup;
                (function (RootGroup) {
                    ;
                })(RootGroup = Internal.RootGroup || (Internal.RootGroup = {}));
            })(Internal = Model_13.Internal || (Model_13.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_14) {
            var Internal;
            (function (Internal) {
                'use strict';
                var Model = Web.Utils.Model;
                var EnabledCommand = Web.Utils.EnabledCommand;
                /**
                 * It holds a root group, which contains the list of all clients and groups known to the client.
                 *
                 * @created Oct 2014
                 * @blame chfang
                 */
                var PersonsAndGroupsManager = (function () {
                    //#endregion
                    function PersonsAndGroupsManager(_a) {
                        var ucwa = _a.ucwa, psm = _a.psm, cm = _a.contactmgr, me = _a.me, tm = _a.tm;
                        var root = new Internal.RootGroup({
                            ucwa: ucwa,
                            contactmgr: cm,
                            tm: tm
                        });
                        return Model({
                            mePerson: me,
                            all: root,
                            // These two commands are enabled only when signed in.
                            // This simplifies implementation of the search query models.
                            createPersonSearchQuery: EnabledCommand(function () {
                                return new Internal.PersonSearchQuery({
                                    ucwa: ucwa,
                                    psm: psm,
                                    contactmgr: cm,
                                    me: me,
                                    tm: tm
                                });
                            }),
                            createGroupSearchQuery: EnabledCommand(function () {
                                return new Internal.GroupSearchQuery({
                                    ucwa: ucwa,
                                    psm: psm,
                                    contactmgr: cm,
                                    tm: tm
                                });
                            }),
                            createGroup: root.createGroup
                        });
                    }
                    return PersonsAndGroupsManager;
                })();
                Internal.PersonsAndGroupsManager = PersonsAndGroupsManager;
            })(Internal = Model_14.Internal || (Model_14.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                /** It's simply a cache of all created person models. */
                var ContactManager = (function () {
                    function ContactManager(ucwa, psm) {
                        this.ucwa = ucwa;
                        this.psm = psm;
                        this.contacts = {}; // contacts[href] = Person(...)
                    }
                    /** Finds or creates a Person model by its rel=contact href. */
                    ContactManager.prototype.get = function (href) {
                        var _this = this;
                        var createPerson = function () { return new Internal.Person({
                            href: href,
                            ucwa: _this.ucwa,
                            psm: _this.psm
                        }); };
                        if (typeof href === 'string') {
                            if (!this.contacts[href])
                                this.contacts[href] = createPerson();
                            return this.contacts[href];
                        }
                        else {
                            return createPerson();
                        }
                    };
                    return ContactManager;
                })();
                Internal.ContactManager = ContactManager;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var sleep = Web.Utils.sleep;
                var repeat = Web.Utils.repeat;
                var Http = Web.Utils.Http;
                var Task = Web.Utils.Task;
                var NumProperty = Web.Utils.NumProperty;
                /**
                 * Creates and keeps a presence subscription to one or multiple SIP URIs.
                 *
                 * @created Oct 2014
                 * @blame antonkh
                 */
                var PresenceSubscription = (function () {
                    /**
                     * @param duration - Duration in minutes.
                     *
                     *  We found that values higher than 11 minutes get rejected by the server.
                     */
                    function PresenceSubscription(ucwa, uris, duration, tm) {
                        if (duration === void 0) { duration = 11; }
                        this.ucwa = ucwa;
                        this.uris = uris;
                        this.duration = duration;
                        this.tm = tm;
                        this._size = NumProperty();
                        this.active = {};
                        /** The number of SIP URIs in this subscription. */
                        this.size = this._size.asReadOnly();
                        this._size(uris.length);
                        for (var _i = 0; _i < uris.length; _i++) {
                            var uri = uris[_i];
                            this.active[uri] = true;
                        }
                        this.init();
                    }
                    PresenceSubscription.prototype.init = function () {
                        var _this = this;
                        this.dfd = Task.wait(null, 'sync').then(function () {
                            // in the anonymous mode rel=presenceSubscriptions does not exist
                            return _this.ucwa.send('POST', { rel: 'presenceSubscriptions' }, {
                                data: {
                                    duration: _this.duration,
                                    uris: _this.uris
                                }
                            });
                        }).then(function (r) {
                            _this.rSubscription = r;
                            // this logic should handle a more aggressive approach to extending existing
                            // presence subscription and should make it less likely that an 'updated'
                            // event will appear for this subscription
                            _this.rep = repeat(function () {
                                return sleep((_this.duration - 1) * 60).then(function () { return _this.extendDuration(); });
                            }).catch(function (err) {
                                // by this moment the stack layer should've deleted the subscription
                                // resource and fired the deleted event from it; after that the model
                                // needs to create a new subscription to the uris and continue as usual
                                if (err && err.code == 'RequestFailed' && err.rsp.status == 404 /* NotFound */)
                                    _this.init();
                                throw err;
                            });
                            // UCWA sends an empty "updated" event to warn that the subscription is about to expire
                            _this.rSubscription.dirty.when(true, function () { return _this.extendDuration(); });
                            // if UCWA deletes the subscription, the client should stop trying to extend it
                            _this.rSubscription.deleted(function () {
                                // TODO: however, if the subscription has been deleted
                                // due to a network loss, the model should rather restore
                                // the subscription and continue as though nothing has happened
                                _this.stop();
                                _this._size(0);
                                _this.active = {};
                            });
                        }).finally(function () {
                            _this.dfd = null;
                        });
                        this.tm && this.tm.monitor(this.dfd, 'presence_subscribe', { nUris: this._size });
                    };
                    PresenceSubscription.prototype.extendDuration = function () {
                        return this.ucwa.send('POST', this.rSubscription.href, {
                            query: { duration: this.duration }
                        });
                    };
                    PresenceSubscription.prototype.stop = function () {
                        if (this.rep) {
                            this.rep.cancel();
                            this.rep = null;
                        }
                    };
                    PresenceSubscription.prototype.add = function (uri) {
                        if (this.active[uri]) {
                        }
                        else {
                            this.active[uri] = true;
                            this._size.inc();
                        }
                    };
                    /**
                     * UCWA offers API to add one or multiple SIP URIs to an existing presence
                     * subscription, but doesn't offer an efficient way to remove a SIP URI.
                     * Thus this implementation doesn't offer a way to unsubscribe from a SIP URI
                     * without deleting the entire presence subscription. The remove method
                     * doesn't unsubscribe the given URI. Instead, it decrements an internal
                     * counter and when it reaches zero, it deletes the entire presence
                     * subscription.
                     */
                    PresenceSubscription.prototype.remove = function (uri) {
                        if (this.active[uri]) {
                            this.active[uri] = false;
                            this._size.dec();
                            if (this._size() == 0) {
                                if (this.rSubscription) {
                                    this.stop();
                                    this.ucwa.send('DELETE', this.rSubscription.href);
                                }
                                else if (this.dfd) {
                                    this.dfd.cancel();
                                }
                            }
                        }
                    };
                    return PresenceSubscription;
                })();
                Internal.PresenceSubscription = PresenceSubscription;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var debug = Web.Utils.debug;
                var batched = Web.Utils.batched;
                var Subscription = Web.Utils.Subscription;
                /**
                 * Creates, updates and deletes contact presence subscriptions.
                 *
                 * It's mainly responsible for merging several subscriptions into one
                 * which is supposed to reduce the pressure on the server.
                 *
                 * This is the outline of relationships between all involved resources:
                 *
                 *      /presenceSubscriptions
                 *          /presenceSubscription[i]
                 *              /addToPresenceSubscription
                 *              /memberships
                 *                  /presenceSubscriptionMembership[i]
                 *                      /presenceSubscription (link to parent)
                 *                      /contact
                 *      /subscribedContacts (a read-only view)
                 *          /contact[i]
                 *
                 * @created Oct 2014
                 * @blame antonkh
                 */
                var PresenceSubscriptionManager = (function () {
                    function PresenceSubscriptionManager(ucwa, maxBatchSize, duration, tm) {
                        var _this = this;
                        this.subs = {};
                        this.refs = {};
                        this.dfds = {};
                        // one presence subscription cannot contain more than 75 URIs
                        this._subscribe = batched(function (uris) {
                            var psub = new Internal.PresenceSubscription(ucwa, uris, duration, tm);
                            psub.size.when(0, function () {
                                for (var _i = 0; _i < uris.length; _i++) {
                                    var uri = uris[_i];
                                    _this.remove(uri);
                                }
                            });
                            return psub;
                        }, maxBatchSize || 75);
                    }
                    PresenceSubscriptionManager.prototype.unsubscribe = function (uri) {
                        var refs = this.refs;
                        var subs = this.subs;
                        var dfds = this.dfds;
                        refs[uri]--;
                        if (refs[uri] == 0) {
                            if (subs[uri]) {
                                subs[uri].remove(uri);
                            }
                            else {
                                try {
                                    dfds[uri].cancel();
                                }
                                catch (err) {
                                    // TODO: it's not clear what's causing this bug; suppressing it for now to not break the UI
                                    debug.log('unsubscribe(' + uri + ') failed', err && err.stack || err);
                                }
                                this.remove(uri);
                            }
                        }
                    };
                    PresenceSubscriptionManager.prototype.remove = function (uri) {
                        delete this.dfds[uri];
                        delete this.refs[uri];
                        delete this.subs[uri];
                    };
                    /**
                     * Creates a presence subscription for the given SIP URI.
                     * The subscription manager may either create a standalone
                     * subscription or merge it with others to reduce pressure
                     * on the server.
                     *
                     *     var sub = psm.subscribe("sip:user123@contoso.com");
                     *     setTimeout(sub.dispose, 10000); // unsubscribe after 10 seconds
                     *
                     * This method may be invoked multiple times on the same SIP URI:
                     * the subscriptions manager will handle this correctly.
                     */
                    PresenceSubscriptionManager.prototype.subscribe = function (uri) {
                        var _this = this;
                        var refs = this.refs;
                        var subs = this.subs;
                        var dfds = this.dfds;
                        var isDisposed = false;
                        if (dfds[uri]) {
                            refs[uri]++;
                        }
                        else if (subs[uri]) {
                            refs[uri]++;
                            subs[uri].add(uri);
                        }
                        else {
                            refs[uri] = 1;
                            dfds[uri] = this._subscribe(uri).then(function (sub) {
                                subs[uri] = sub;
                                dfds[uri] = null;
                            });
                        }
                        return new Subscription(function () {
                            if (!isDisposed) {
                                isDisposed = true;
                                _this.unsubscribe(uri);
                            }
                        });
                    };
                    return PresenceSubscriptionManager;
                })();
                Internal.PresenceSubscriptionManager = PresenceSubscriptionManager;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_15) {
            var Internal;
            (function (Internal) {
                'use strict';
                var guid = Web.Utils.guid;
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var assert = Web.Utils.assert;
                var indexOf = Web.Utils.indexOf;
                var Task = Web.Utils.Task;
                var Event = Web.Utils.Event;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var StringEnum = Web.Utils.StringEnum;
                var BoolProperty = Web.Utils.BoolProperty;
                /**
                 * The OnlineMeeting model encapsulates rel=onlineMeeting and rel=onlineMeetingInvitation
                 * resource objects and belongs to a Conversation model. When the endpoint receives
                 * an "onlineMeetingInvitation started" event, the OnlineMeeting model acts as the invitation
                 * and provides "accept" and "decline" methods. After the online meeting invitation is accepted,
                 * the model represents the rel=onlineMeeting resource object.
                 *
                 * Note, that UCWA has separate resource objects for scheduled online meetings:
                 * rel=myOnlineMeeting and rel=myLargeOnlineMeeting.
                 *
                 * @created Jan 2014
                 * @blame antonkh
                 */
                var OnlineMeeting = (function () {
                    function OnlineMeeting(_a) {
                        //#region Locals
                        var ucwa = _a.ucwa, rInvitation = _a.rInvitation, rMeeting = _a.rMeeting, from = _a.from, threadId = _a.threadId, subject = _a.subject, priority = _a.priority, conversation = _a.conversation, contactManager = _a.contactManager;
                        var pState = Property();
                        var pSubject = Property();
                        var pUri = Property();
                        var pJoinUrl = Property();
                        var pPriority = Property();
                        var changed = new Event;
                        var tCreatorHref = new Task();
                        var pCreatorHref = Property({
                            get: function () { return tCreatorHref.promise; }
                        });
                        pCreatorHref.changed(function (href) { return tCreatorHref.resolve(href); });
                        var methods = {
                            start: async(start),
                            accept: async(accept),
                            decline: async(decline)
                        };
                        var self = Model({
                            from: from,
                            changed: changed.observer,
                            state: pState.asReadOnly(),
                            subject: pSubject.asReadOnly(),
                            uri: pUri.asReadOnly(),
                            priority: pPriority.asReadOnly(),
                            joinUrl: pJoinUrl.asReadOnly(),
                            availableModalities: Model({
                                messaging: createAvailabilityProperty('Messaging'),
                                audio: createAvailabilityProperty('Audio'),
                                video: createAvailabilityProperty('Video'),
                                appSharing: createAvailabilityProperty('ApplicationSharing')
                            })
                        });
                        //#endregion
                        //#region Initialization
                        if (rInvitation) {
                            // the meeting model is created to represent
                            // an incoming invitation to a meeting
                            assert(from);
                            pState(OnlineMeeting.State.Notified);
                            self.accept = methods.accept;
                            self.decline = methods.decline;
                            rInvitation.updated(update);
                        }
                        else if (rMeeting) {
                            // the meeting model is created based on
                            // existing rel=onlineMeeting resource
                            pState(OnlineMeeting.State.Connected);
                            rMeeting.updated(update);
                        }
                        else {
                            // the meeting model is built from scratch
                            // to create a new online meeting
                            assert(threadId);
                            pState(OnlineMeeting.State.Created);
                            pSubject(subject);
                            pPriority(priority);
                            self.start = methods.start;
                        }
                        self.creator = contactManager.get(pCreatorHref);
                        //#endregion
                        ucwa.event(function (event) {
                            var target = event.target;
                            var resource = event.resource;
                            var context = event['in'];
                            if (event.type == 'added' && target.rel == 'onlineMeeting' && context && conversation[Internal.sHref] == context.href && !rMeeting) {
                                rMeeting = resource;
                                rMeeting.updated(update);
                            }
                        });
                        ucwa.event(function (event) {
                            var target = event.target;
                            var resource = event.resource;
                            if (event.type == 'completed' && target.rel == 'onlineMeetingInvitation' &&
                                resource.link('conversation').href == conversation[Internal.sHref] && resource.get('state') == 'Connected') {
                                pState(OnlineMeeting.State.Connected);
                            }
                        });
                        //#region Private Methods
                        function createAvailabilityProperty(modality) {
                            // it's possible to return a const false property
                            // in some cases, but this optimization will give
                            // nothing, while require more complicated code
                            var property = BoolProperty(false);
                            if (rInvitation) {
                                rInvitation.updated(function () {
                                    var modalities = rInvitation.get('availableModalities', []);
                                    var value = indexOf(modalities, modality) >= 0;
                                    property(value);
                                });
                            }
                            return property.asReadOnly();
                        }
                        /**
                         * At first it listens to rel=onlineMeetingInvitation and once it completes,
                         * it starts listening to rel=onlineMeeting.
                         */
                        function update() {
                            var r = rMeeting || rInvitation;
                            // note, that r can be either rel=onlineMeetingInvitation or rel=onlineMeeting
                            // and their property sets are similar but not identical
                            pSubject(r.get('subject', ''));
                            pUri(r.get('onlineMeetingUri', ''));
                            pJoinUrl(r.get('joinUrl', ''));
                            pPriority(r.get('importance', ''));
                            if (r.hasLink('organizer'))
                                pCreatorHref(r.link('organizer').href);
                            var state = r.has('state') && r.get('state');
                            if (state == 'Connected')
                                pState(OnlineMeeting.State.Connected);
                            else if (state == 'Failed')
                                pState(OnlineMeeting.State.Disconnected);
                        }
                        function sendMeetingJoinFailureCER(conferenceUri, event) {
                            if (!event)
                                return;
                            var appResource = ucwa.exists({ rel: 'application' }) && ucwa.get({ rel: 'application' });
                            if (appResource && appResource.hasLink('sendClientErrorReport')) {
                                return ucwa.send('POST', { rel: 'sendClientErrorReport' }, {
                                    data: {
                                        description: event.reason ? event.reason.message : 'Failed to join conference',
                                        conferenceUri: conferenceUri,
                                        clientErrorCode: event.reason ? event.reason.code : 'FAILURE',
                                        rel: event.target.rel
                                    },
                                    nobatch: true
                                });
                            }
                        }
                        //#endregion
                        //#region Public Methods
                        //#region start
                        /**
                         * Creates a new persistent online meeting or joins an existing one using its
                         * known URI. In addition to rel=onlineMeeting, UCWA creates a rel=conversation
                         * resource object. The sequence of requests and events is following:
                         *
                         *      - POST rel=startOnlineMeeting
                         *      - onlineMeetingInvitation started
                         *      - conversation added
                         *      - onlineMeeting added in conversation
                         *      - onlineMeetingInvitation completed
                         *
                         * After the meeting is created, the web app is supposed to add modalities.
                         *
                         * Note, that when joining an online meeting anonymously, the "onlineMeetingInvitation completed"
                         * event does not arrive until the owner of the meeting admits the anonymous
                         * guest, so before that moment OnlineMeeting::state is "Connecting" and the
                         * promise returned by OnlineMeeting::start is pending.
                         *
                         * @param {String} [uri] - The URI of an existing meeting to join.
                         * @param {String} [name] - The guest name when joining an online meeting anonymously.
                         *
                         * @returns {Promise}
                         */
                        function start(options) {
                            var uri = options && options.uri;
                            var name = options && options.name;
                            return Task.run(function () {
                                var operationId = guid(), dfdRequest, dfdStarted, dfdCompleted, dfdAdded;
                                pState(OnlineMeeting.State.Connecting);
                                // prevent calling start twice
                                delete self.start;
                                changed.fire();
                                // Send a POST to rel=startOnlineMeeting.
                                // The response to this request usually comes
                                // before any events, but this is not guaranteed.
                                if (uri) {
                                    dfdRequest = ucwa.send('POST', { rel: 'joinOnlineMeeting' }, {
                                        data: {
                                            operationId: operationId,
                                            threadId: threadId,
                                            anonymousDisplayName: name,
                                            onlineMeetingUri: uri
                                        }
                                    });
                                }
                                else {
                                    dfdRequest = ucwa.send('POST', { rel: 'startOnlineMeeting' }, {
                                        data: {
                                            operationId: operationId,
                                            threadId: threadId,
                                            subject: subject || '',
                                            importance: priority || 'Normal'
                                        }
                                    });
                                }
                                // Wait for "onlineMeetingInvitation started" event.
                                // The only reason to wait for this event is to get the rel=conversation link
                                // and then use that link to find the corresponding "onlineMeeting added" event.
                                // Note, that this event may not arrive at all, if UCWA rejected the attempt
                                // to create an online meeting.
                                dfdStarted = ucwa.wait({
                                    type: 'started',
                                    target: { rel: 'onlineMeetingInvitation' },
                                    resource: { operationId: operationId }
                                }).then(function (event) {
                                    assert(!rInvitation);
                                    rInvitation = event.resource;
                                    rInvitation.updated(update);
                                });
                                // Wait for "onlineMeetingInvitation completed" event.
                                // This event indicates the successful completion of
                                // the operation and this event usually arrives last.
                                // When joining anonymously an online meeting, this event
                                // arrives after the owner of the meeting admits the guest.
                                dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'onlineMeetingInvitation' },
                                    resource: { operationId: operationId }
                                }).then(function (event) {
                                    if (event.status != 'Success') {
                                        sendMeetingJoinFailureCER(uri, event);
                                        throw Internal.EInvitationFailed(event.reason);
                                    }
                                });
                                // Wait for "onlineMeeting added in conversation" event.
                                // After the invitation succeeds, UCWA sends a rel=onlineMeeting resource
                                // with the persistent join URL and other information about the meeting,
                                // so the ONlineMeeting model must start using this resource as the source
                                // of data.
                                dfdAdded = ucwa.wait({
                                    type: 'added',
                                    target: { rel: 'onlineMeeting' },
                                    resource: function (r) {
                                        return rInvitation && r.link('conversation').href == rInvitation.link('conversation').href;
                                    }
                                }).then(function (event) {
                                    // TODO: refactor this event handler with the other one.
                                    rInvitation.updated.off(update);
                                    if (!rMeeting) {
                                        rMeeting = event.resource;
                                        rMeeting.updated(update);
                                    }
                                });
                                return Task.waitAll([
                                    dfdRequest,
                                    dfdStarted,
                                    dfdCompleted,
                                    dfdAdded]);
                            }).then(function () {
                                pState(OnlineMeeting.State.Connected);
                            }).catch(function (error) {
                                // if something went wrong, restore the original state
                                self.start = methods.start;
                                pState(OnlineMeeting.State.Created, error);
                                changed.fire();
                                throw error;
                            });
                        }
                        //#endregion
                        //#region accept
                        /**
                         * Accepts the invitation to the online meeting. To do that this method:
                         *
                         *      - Sends a POST to rel=onlineMeetingInvitation/rel=accept.
                         *      - Waits for "onlineMeeting added" event to get the rel=onlineMeeting resource.
                         *      - Waits for "onlineMeetingInvitation completed" event.
                         *
                         * If the operation succeeds, the final state is:
                         *
                         *      - pState is "Connected"
                         *      - rMeeting is the rel=onlineMeeting resource
                         *
                         * If the operation fails, the final state is:
                         *
                         *      - pState is "Disconnected"
                         *
                         * The operation completes after receiving the "onlineMeetingInvitation completed" event.
                         * After the meeting is accepted, the corresponding conversation adds the messaging
                         * modality.
                         *
                         * @returns {Promise}
                         */
                        function accept() {
                            check.state(pState(), OnlineMeeting.State.Notified);
                            pState(OnlineMeeting.State.Connecting);
                            return Task.run(function () {
                                var dfdMeetingAdded; // "onlineMeeting added" event
                                var dfdInvitationCompleted; // "onlineMeetingInvitation completed" event
                                var dfdInvitationRequest; // POST rel=onlineMeetingInvitation/rel=accept
                                dfdInvitationRequest = ucwa.send('POST', rInvitation.link('accept').href);
                                dfdMeetingAdded = ucwa.wait({
                                    type: 'added',
                                    target: { rel: 'onlineMeeting' },
                                    resource: function (r) {
                                        return r.link('conversation').href == rInvitation.link('conversation').href;
                                    }
                                }).then(function (event) {
                                    // TODO: refactor this event handler with other one
                                    rInvitation.updated.off(update);
                                    if (!rMeeting) {
                                        rMeeting = event.resource;
                                        rMeeting.updated(update);
                                    }
                                });
                                dfdInvitationCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'onlineMeetingInvitation', href: rInvitation.href }
                                }).then(function (event) {
                                    if (event.status != 'Success') {
                                        var onlineMeetingUri = event.resource.has('onlineMeetingUri') &&
                                            event.resource.get('onlineMeetingUri');
                                        sendMeetingJoinFailureCER(onlineMeetingUri, event);
                                        throw Internal.EInvitationFailed(event.reason);
                                    }
                                });
                                return Task.waitAll([
                                    dfdInvitationRequest,
                                    dfdMeetingAdded,
                                    dfdInvitationCompleted
                                ]);
                            }).then(function () {
                                delete self.accept;
                                delete self.decline;
                                pState(OnlineMeeting.State.Connected);
                                changed.fire();
                            }).catch(function (error) {
                                pState(OnlineMeeting.State.Disconnected, error);
                                throw error;
                            });
                        }
                        //#endregion
                        //#region decline
                        function decline(reason) {
                            if (reason === void 0) { reason = 'Global'; }
                            check.state(pState(), OnlineMeeting.State.Notified);
                            return ucwa.send('POST', rInvitation.link('decline').href, {
                                data: { reason: reason }
                            }).then(function () { return pState(OnlineMeeting.State.Disconnected); });
                        }
                        //#endregion
                        //#endregion
                        return self;
                    }
                    return OnlineMeeting;
                })();
                Internal.OnlineMeeting = OnlineMeeting;
                var OnlineMeeting;
                (function (OnlineMeeting) {
                    OnlineMeeting.State = StringEnum('Created', 'Notified', 'Connecting', 'Connected', 'Disconnected');
                    OnlineMeeting.AccessLevel = StringEnum('Everyone', 'Invited', 'Locked', 'SameEnterprise');
                    OnlineMeeting.AutomaticLeaderAssignment = StringEnum('Disabled', 'Everyone', 'SameEnterprise');
                    OnlineMeeting.EntryExitAnnouncement = StringEnum('Disabled', 'Enabled');
                    OnlineMeeting.LobbyBypassForPhoneUsers = StringEnum('Disabled', 'Enabled');
                    OnlineMeeting.PhoneUserAdmission = StringEnum('Disabled', 'Enabled');
                })(OnlineMeeting = Internal.OnlineMeeting || (Internal.OnlineMeeting = {}));
            })(Internal = Model_15.Internal || (Model_15.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var dateToTimeStamp = Web.Utils.dateToTimeStamp;
                var timeStampToDate = Web.Utils.timeStampToDate;
                /**
                 * The MyOnlineMeeting model encapsulates rel=myOnlineMeeting resource object and is the result of
                 * scheduling a meeting. It basically takes the resource object and exposing properties as either
                 * settable or read-only using an ObservableResource. The settable properties can trigger an
                 * aggregated update of the underlying resource object if the new values differ. The onlineMeetingUri
                 * property can be used to start/join the meeting.
                 *
                 * @param {UCWA} ucwa
                 * @param source - The rel=myOnlineMeeting resource selector.
                 *
                 * @property {String} accessLevel - Controls who is let into the meeting.
                 *
                 *  - Everyone
                 *  - Invited - Only users in the attendees/leaders, all others are put in the lobby.
                 *  - Locked - All users except the organizer are put into the lobby.
                 *  - SameEnterprise - Only users from the same enterprise, all others are put in the lobby.
                 *
                 * @property {Array<String>} attendees - SIP URIs of users to include as attendees.
                 * @property {String} automaticLeaderAssignment - Which participants are automatically promoted to leaders.
                 *
                 *  An online meeting organizer can schedule a meeting so that users are automatically promoted
                 *  to the leader role when they join the meeting. For example, if the meeting is scheduled with
                 *  automatic promotion policy set to "SameEnterprise", then any participants
                 *  from the organizer's company are automatically promoted to leaders when they join the meeting.
                 *  Conference leaders can still promote specific users to the leader role, including anonymous users.
                 *
                 * @property {String} description - Purpose of the meeting
                 * @property {String} entryExitAnnouncement - The attendance announcements status for the online meeting.
                 *
                 *  When attendance announcements are enabled, the online meeting will announce the names
                 *  of the participants who join the meeting through audio.
                 *
                 * @property {Date} expirationTime - The UTC date and time after which the online meeting can be deleted.
                 *
                 *  The day and time must be between one year before, and ten years after,
                 *  the current date and time on the server.
                 *
                 * @property {Array<String>} leaders - Array of SIP URIs of users to include as leaders.
                 *
                 *  The organizer will automatically be added to the leaders list.
                 *
                 * @property {String} lobbyBypassForPhoneUsers - When enabled phone users will skip the meeting lobby.
                 * @property {String} phoneUserAdmission - Whether participants can join the online meeting over the phone.
                 *
                 *  Setting this property to true means that online meeting participants can join the meeting
                 *  over the phone through the Conferencing Auto Attendant (CAA) service.
                 *
                 * @property {String} subject - The subject of the online meeting.
                 * @property {String} joinUrl - The URL that is used when the online meeting is joined from the web.
                 * @property {String} onlineMeetingId - Identifies this meeting among the other online meetings that are scheduled by the organizer.
                 *
                 *  The online meeting ID is unique within the organizer's list of scheduled online meetings.
                 *
                 * @property {String} onlineMeetingUri - The online meeting URI.
                 *
                 *  The online meeting URI is used by participants to join this online meeting.
                 *  It can be used to join the meeting:
                 *
                 *      client.startMeeting({
                 *          uri: scheduledMeeting.onlineMeetingUri()
                 *      });
                 *
                 * @property {String} organizerUri - he URI of the online meeting organizer: the person who scheduled the meeting.
                 *
                 *  Organizers can enumerate or change only the conferences that they organize.
                 *
                 * @created v-shagma, Jul 2014
                 */
                function MyOnlineMeeting(ucwa, options) {
                    return Internal.ObservableResource(ucwa, options.source, function ($) {
                        $.property('accessLevel');
                        $.property('attendees');
                        $.property('automaticLeaderAssignment');
                        $.property('description');
                        $.property('entryExitAnnouncement');
                        $.property('expirationTime', {
                            parse: timeStampToDate,
                            convert: dateToTimeStamp,
                            prepare: function (val) { return val && val.toJSON(); }
                        });
                        $.property('joinUrl', { readOnly: true });
                        $.property('leaders');
                        $.property('lobbyBypassForPhoneUsers');
                        $.property('onlineMeetingId', { readOnly: true });
                        $.property('onlineMeetingUri', { readOnly: true });
                        $.property('organizerUri', { readOnly: true });
                        $.property('phoneUserAdmission');
                        $.property('subject');
                    });
                }
                Internal.MyOnlineMeeting = MyOnlineMeeting;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var isString = Web.Utils.isString;
                var sanitizeHtml = Web.Utils.sanitizeHtml;
                var convertHtmlToText = Web.Utils.convertHtmlToText;
                var convertTextToHtml = Web.Utils.convertTextToHtml;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var Property = Web.Utils.Property;
                var BaseModel = Web.Utils.BaseModel;
                var ConstProperty = Web.Utils.ConstProperty;
                /*
                 * Remove leading and trailing white spaces as well as empty <div>
                 * tags from the input html string.
                 *
                 * @created Jul 2015
                 * @blame yodu
                 */
                function trimHtml(html) {
                    var re = /^\s*<div>([\s\S]*)<\/div>\s*$/i;
                    return re.test(html) ?
                        trimHtml(html.replace(re, '$1')) :
                        html.trim();
                }
                /**
                 * This is an incoming or an outgoing instant message in a conversation.
                 *
                 * @created Aug 2013
                 * @blame antonkh
                 */
                var Message = (function (_super) {
                    __extends(Message, _super);
                    function Message(_a) {
                        var _this = this;
                        var ucwa = _a.ucwa, _b = _a.href, href = _b === void 0 ? '' : _b, sender = _a.sender, _c = _a.status, status = _c === void 0 ? Message.Status.Succeeded : _c, _d = _a.time, time = _d === void 0 ? new Web.Date : _d, text = _a.text, html = _a.html, direction = _a.direction;
                        _super.call(this);
                        this.isEdited = ConstProperty(false);
                        this.isDeleted = ConstProperty(false);
                        text = (text || '').trim();
                        html = (html || '').trim();
                        // infer text from html
                        if (html && !text) {
                            try {
                                text = convertHtmlToText(html);
                            }
                            catch (err) {
                                text = '';
                            }
                        }
                        // infer html from text
                        if (text && !html) {
                            try {
                                html = convertTextToHtml(text);
                            }
                            catch (err) {
                                html = '';
                            }
                        }
                        var _href = isString(href) ?
                            ConstProperty(href) :
                            href;
                        var _status = isString(status) ?
                            Property({ value: status }) :
                            status;
                        _href.changed(function (s) { return _this[Internal.sHref] = s; });
                        if (_status() != Message.Status.Succeeded) {
                            ucwa.wait({
                                type: 'completed',
                                target: { rel: 'message' },
                                resource: function (r) {
                                    // _href() is not available immediately
                                    return r.href == _href();
                                }
                            }).then(function (event) {
                                _status(event.status == 'Success' ?
                                    Message.Status.Succeeded :
                                    Message.Status.Failed, event.reason);
                            });
                        }
                        this.sender = sender.person; // this implies that all messages have a valid sender object
                        this.text = ConstProperty(text && disableHtmlInText(text).trim()); // html is disabled to prevent xss
                        this.html = ConstProperty(html && trimHtml(sanitizeHtml(html))); // sanitize html to prevent xss                
                        this.timestamp = ConstProperty(time);
                        this.direction = ConstProperty(direction || (_href() || _href() == '' ? Message.Direction.Incoming : Message.Direction.Outgoing));
                        this.status = _status.asReadOnly();
                    }
                    return Message;
                })(BaseModel);
                Internal.Message = Message;
                var Message;
                (function (Message) {
                    var Status;
                    (function (Status) {
                        Status.Pending = 'Pending';
                        Status.Succeeded = 'Succeeded';
                        Status.Failed = 'Failed';
                    })(Status = Message.Status || (Message.Status = {}));
                    var Direction;
                    (function (Direction) {
                        Direction.Incoming = 'Incoming';
                        Direction.Outgoing = 'Outgoing';
                    })(Direction = Message.Direction || (Message.Direction = {}));
                })(Message = Internal.Message || (Internal.Message = {}));
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_16) {
            var Internal;
            (function (Internal) {
                'use strict';
                var inherit = Web.Utils.inherit;
                var Property = Web.Utils.Property;
                var BoolProperty = Web.Utils.BoolProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var Model = Web.Utils.Model;
                /**
                 * A general purpose activity item like a text message, a video call, etc.
                 *
                 * It takes an existing model as a prototype, creates a derived activity item
                 * object and augments it with missing properties.
                 *
                 * @blame antonkh
                 */
                var ActivityItem = (function () {
                    function ActivityItem(type, key, prototype) {
                        var reason = Property();
                        if (prototype.status)
                            prototype.status.changed(function (newValue, newReason) { return reason(newReason); });
                        // create an object inherited from the prototype and add
                        // missing properties to the create object
                        return inherit(Model(prototype), {
                            type: ConstProperty(type),
                            key: ConstProperty(key),
                            timestamp: ConstProperty(new Web.Date),
                            status: ConstProperty('Succeeded'),
                            reason: reason.asReadOnly(),
                            isRead: BoolProperty(false)
                        }, 'append');
                    }
                    return ActivityItem;
                })();
                Internal.ActivityItem = ActivityItem;
            })(Internal = Model_16.Internal || (Model_16.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_17) {
            var Internal;
            (function (Internal) {
                'use strict';
                var map = Web.Utils.map;
                var keys = Web.Utils.keys;
                var take = Web.Utils.take;
                var async = Web.Utils.async;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var foreach = Web.Utils.foreach;
                var inherit = Web.Utils.inherit;
                var indexOf = Web.Utils.indexOf;
                var isArray = Web.Utils.isArray;
                var isModel = Web.Utils.isModel;
                var isProperty = Web.Utils.isProperty;
                var isCollection = Web.Utils.isCollection;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var timeStampToDate = Web.Utils.timeStampToDate;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var URI = Web.Utils.URI;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var Subscription = Web.Utils.Subscription;
                var ConstProperty = Web.Utils.ConstProperty;
                var ENotSupported = Web.Utils.ENotSupported;
                /**
                 * A read-only representation of a Person in a contact list or in a search query.
                 *
                 * A Person model is created on top of a "contact" resource from UCWA.
                 * When created, it does not send any HTTP requests to get additional
                 * information about the Person, but waits for the view layer
                 * (or whoever created the Person model) to subscribe to one of the
                 * Person model properties. For example, when the caller starts
                 * listening to Person name changes
                 *
                 *      person1.displayName.changed(function (name) {
                 *          console.log("the contact's name is " + name);
                 *      });
                 *
                 * the Person model checks whether the property is already
                 * available and if so, the Person model does not fetches it
                 * again from the server, If the property value is not available,
                 * the Person model sends all HTTP server requests necessary to obtain
                 * that value. For example for the
                 * code snippet above where someone subscribes to the "displayName" property,
                 * the Person model sends up to one HTTP request to load the resource:
                 *
                 *      GET /contacts/126173
                 *
                 * For more complicated properties, like "status", it may be necessary
                 * to send extra HTTP requests to create a presence subscription. So when
                 * someone starts listening to the "status" property
                 *
                 *      sub = person1.status.subscribe();
                 *      person1.status.changed(onPresenceChanged);
                 *      function onPresenceChanged(presence) {
                 *          console.log("the contact is " + presence.availability);
                 *      }
                 *
                 * the Person model sends a POST request to create a presence subscription
                 * (in addition to all requests that are necessary to get the URL to which
                 * that POST request can be sent):
                 *
                 *      POST /contacts/126173/presencesubscriptions
                 *
                 *      {"Uris":["sip:johndoe@contoso.com"], "Duration":"11"}
                 *
                 * But after the view stops listening to the property
                 *
                 *      sub.dispose();
                 *
                 * the Person model sends a DELETE request to remove the presence subscription:
                 *
                 *      DELETE /contacts/126173/presencesubscriptions/2877816481
                 *
                 * This is why a well written web app should unsubscribe from Person models
                 * after it does not need them. The Person model cannot do this itself, because
                 * in JavaScript there is no concept of "finalizers" or "destructors" and so
                 * the Person model cannot know when it's no longer needed.
                 *
                 * @created Aug 2013
                 * @blame sosobov
                 * @blame antonkh
                 * @blame yodu
                 */
                var Person = (function () {
                    //#endregion
                    function Person(spec) {
                        var href = spec.href, ucwa = spec.ucwa, psm = spec.psm || new Internal.PresenceSubscriptionManager(ucwa), // defaults for unit tests
                        dfdGet, // tracks the progress of GET rel=contact
                        dfdGetLink = {}, // tracks the progress of GET rel=contactPresence for example
                        PropType = StringEnum('direct', 'linked', 'photo'), 
                        // presence subscription is needed when the Person wants to observe linked properties
                        // (status, activity, note, location, capabilities, relationship):
                        // - subscriptionRefCount tracks the number of observed linked properties and tells the
                        //   Person when to create or delete the subscription.
                        subscriptionRefCount = 0, subscription, properties = {}, 
                        // Property<Resource> which gets the possibly empty rel=contact on demand
                        prContact = (typeof href === 'string' ? ConstProperty(href) : href).map(function (href) { return ucwa.get(href); }), proto = Model(), self = inherit(proto);
                        spec = null; // no need to use `spec` beyond this point
                        initialize();
                        //#region methods
                        function getPropertyValue(name) {
                            var prop = properties[name];
                            return prContact.get().then(function (r) {
                                // the contact resource may contain an incomplete
                                // set of properties and links: UCWA reserves the right
                                // to return partial resources in certain cases (contact search)
                                var isValueAvailable = prop.type == PropType.direct ?
                                    r.has(prop.internalName) :
                                    r.hasLink(prop.internalName);
                                if (!isValueAvailable)
                                    return fetchContactResource();
                            }).then(function () {
                                switch (prop.type) {
                                    case PropType.linked:
                                        return fetchLinkedProperty(prop.link).then(function (result) {
                                            updatePropertyFromResource(prop, result);
                                        });
                                    case PropType.photo:
                                        return getPhoto();
                                }
                            }).then(function () {
                                // at this moment the updated value
                                // is in the cache of the property
                                return prop.property();
                            });
                        }
                        /**
                         * Defines a property of this Person.
                         *
                         * @param {string} name - public property name
                         * @param {object} def - an object with the following properties:
                         *
                         *      internal     - a name of this property in the UCWA contact resource.
                         *                     this can be an array of names if several UCWA properies
                         *                     are combined into one collection.
                         *      type         - property type (can be direct, linked or photo).
                         *      field        - the sub-property of the internal UCWA contact resource.
                         *      element      - the element name in the internal UCWA contact resource
                         *                     if the resource is an array.
                         *      isCollection - whether this property is a Collection or not.
                         *      transform    - a function used to transform the UCWA resource value
                         *                     into a form specifically needed by the property.
                         *
                         * @remark:
                         *
                         *  Fills out the internal properties of a Person model with the UCWA resources' definitions.
                         *
                         *  A value of the direct property can be found in the UCWA contact resource;
                         *  a linked property is accessible only via a link in the UCWA contact resource;
                         *  photo is also a linked property, but we make it a separate type because it
                         *  is retrieved from the server not like other linked properties.
                         *
                         *  Each property also has a "link" field; for linked properties it is the property
                         *  link in the UCWA contact resource; it is null for properties whose values are
                         *  immediately available in the contact resource.
                         *
                         * @returns {Property|Collection}
                         *
                         */
                        function defineProperty(name, def) {
                            assert(isNotEmptyString(name));
                            assert(!def || PropType[def.type]);
                            var property = (def && def.isCollection ? Collection : Property)({
                                get: function () {
                                    return getPropertyValue(name);
                                },
                                subscribed: function () {
                                    // fetch some properties from the server only when some other object is binding
                                    // to those properties for the first time
                                    onPropertySubscribed(properties[name]);
                                },
                                unsubscribed: function () {
                                    onPropertyUnsubscribed(properties[name]);
                                }
                            });
                            properties[name] = {
                                internalName: def && def.internal || name,
                                type: def && def.type || PropType.direct,
                                field: def && def.field,
                                element: def && def.element,
                                observed: false,
                                dirty: false,
                                link: null,
                                transform: def && def.transform,
                                property: property
                            };
                            return properties[name].property.asReadOnly();
                        }
                        /**
                         * Transform status values from UCWA to values known to jCafe.
                         * @param {string} s - status value from UCWA
                         */
                        function fixStatus(s) {
                            return Person.Status[s] || {
                                IdleBusy: Person.Status.Idle,
                                IdleOnline: Person.Status.Idle
                            }[s] || Person.Status.Unknown;
                        }
                        /**
                         * Initializes this Person from the contact resource
                         */
                        function initialize() {
                            // define properties
                            self.id = defineProperty('id', { internal: 'uri', type: PropType.direct });
                            self.sourceNetwork = defineProperty('sourceNetwork');
                            self.company = defineProperty('company');
                            self.department = defineProperty('department');
                            self.office = defineProperty('office');
                            self.title = defineProperty('title');
                            self.emails = defineProperty('emails', {
                                internal: 'emailAddresses',
                                type: PropType.direct,
                                isCollection: true,
                                transform: function (arr) {
                                    return map(arr || [], function (email) {
                                        return Model({
                                            type: ConstProperty(null),
                                            emailAddress: ConstProperty(email)
                                        });
                                    });
                                }
                            });
                            self.phoneNumbers = defineProperty('phoneNumbers', {
                                // phoneNumbers is an aggregate of 4 UCWA direct resources
                                internal: ['workPhoneNumber', 'homePhoneNumber', 'mobilePhoneNumber', 'otherPhoneNumber'],
                                type: PropType.direct,
                                isCollection: true,
                                transform: function (phones) {
                                    // keys are UCWA resource names, values are jCafe phone types
                                    var phoneTypes = {
                                        workPhoneNumber: 'Work',
                                        homePhoneNumber: 'Home',
                                        mobilePhoneNumber: 'Mobile',
                                        otherPhoneNumber: 'Other'
                                    };
                                    /* phones is an array of objects:
                                     * [ {'workPhoneNumber':'xxx-xxx-xxxx'},
                                     *   {'homePhoneNumber':'xxx-xxx-xxxx'},
                                     *   {'mobilePhoneNumber':'xxx-xxx-xxxx'},
                                     *   {'otherPhoneNumber':'xxx-xxx-xxxx'} ]
                                     */
                                    return (phones || []).filter(function (phone) {
                                        var type = null, value = null, k = keys(phone);
                                        if (k.length == 1) {
                                            if (k[0] in phoneTypes) {
                                                type = phoneTypes[k[0]];
                                                value = phone[k[0]];
                                            }
                                        }
                                        return type && value;
                                    }).map(function (phone) {
                                        var k = keys(phone)[0];
                                        return Model({
                                            type: ConstProperty(phoneTypes[k]),
                                            telUri: ConstProperty(phone[k]),
                                            displayString: ConstProperty(null)
                                        });
                                    });
                                }
                            }).sort(function (p1, p2) { return p1.type() < p2.type(); });
                            self.workPhone = defineProperty('workPhone', { internal: 'workPhoneNumber', type: PropType.direct });
                            self.homePhone = defineProperty('homePhone', { internal: 'homePhoneNumber', type: PropType.direct });
                            self.mobilePhone = defineProperty('mobilePhone', { internal: 'mobilePhoneNumber', type: PropType.direct });
                            self.otherPhone = defineProperty('otherPhone', { internal: 'otherPhoneNumber', type: PropType.direct });
                            self.type = defineProperty('type');
                            self.displayName = defineProperty('displayName', { internal: 'name', type: PropType.direct });
                            self.avatarUrl = defineProperty('avatarUrl', { internal: 'contactPhoto', type: PropType.photo });
                            self.status = defineProperty('status', { internal: 'contactPresence', type: PropType.linked, field: 'availability', transform: fixStatus });
                            self.endpointType = defineProperty('endpointType', { internal: 'contactPresence', type: PropType.linked, field: 'deviceType', transform: Person.fixDeviceType });
                            self.lastSeenAt = defineProperty('lastSeenAt', { internal: 'contactPresence', type: PropType.linked, field: 'lastActive', transform: timeStampToDate });
                            self.activity = defineProperty('activity', { internal: 'contactPresence', type: PropType.linked, field: 'activity' });
                            self.relationship = defineProperty('relationship', { internal: 'contactPrivacyRelationship', type: PropType.linked, field: 'relationshipLevel' });
                            self.location = defineProperty('location', { internal: 'contactLocation', type: PropType.linked, field: 'location', transform: disableHtmlInText });
                            // the location property contains a few sub-properties
                            // they are not defined by UCWA but needed in jCafe
                            extend(self.location, {
                                type: ConstProperty(null),
                                street: ConstProperty(null),
                                city: ConstProperty(null),
                                state: ConstProperty(null),
                                country: ConstProperty(null),
                                postalCode: ConstProperty(null)
                            });
                            // the Person#note object contains 2 sub-properties
                            // These properties need to be managed under the properties array
                            // to facilitate property subscription/unsubscription, and they
                            // should NOT be be added as direct properties of the Person model.
                            self.note = Model({
                                type: defineProperty('note.type', { internal: 'contactNote', type: PropType.linked, field: 'type' }),
                                text: defineProperty('note.text', { internal: 'contactNote', type: PropType.linked, field: 'message', transform: disableHtmlInText })
                            });
                            // the Person.capabilities object contains 5 sub-properties
                            // These properties need to be managed under the properties array
                            // to facilitate property subscription/unsubscription, and they
                            // should NOT be be added as direct properties of the Person model.
                            self.capabilities = Model({
                                chat: defineProperty('capabilities.chat', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'Messaging'
                                }),
                                audio: defineProperty('capabilities.audio', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'Audio'
                                }),
                                video: defineProperty('capabilities.video', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'Video'
                                }),
                                screenSharing: defineProperty('capabilities.screenSharing', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'ApplicationSharing'
                                }),
                                dataCollaboration: defineProperty('capabilities.dataCollaboration', {
                                    internal: 'contactSupportedModalities',
                                    type: PropType.linked,
                                    field: 'modalities',
                                    element: 'DataCollaboration'
                                })
                            });
                            // TODO: the setter of this property should move the contact to the Blocked group
                            self.isBlocked = ConstProperty(false, ENotSupported());
                            // once the rel=contact resource becomes available...
                            prContact.once(function (r) { return !!r; }, function () {
                                var r = prContact();
                                // sHref will be a hidden symbol for Contact objects
                                setHiddenProperty(proto, Internal.sHref, r.href);
                                // listen to contact resource update events;
                                // this will also populate direct properties if we have a non-empty
                                // contact resource in the repository
                                r.updated(function () {
                                    foreach(properties, function (p) {
                                        if (p.type != PropType.direct) {
                                            p.link = r.relatedHref(p.internalName);
                                        }
                                        else {
                                            var v = !isArray(p.internalName) ?
                                                r.properties[p.internalName] :
                                                p.internalName.filter(function (i) { return r.properties[i]; }).map(function (i) { return take(r.properties, i); });
                                            p.property(p.transform ? p.transform(v) : v);
                                        }
                                    });
                                });
                            });
                            ucwa.event(onSubscriptionEvent);
                            // some linked properties may be available in the resource cache
                            updateLinkedPropsOrGetMissingProperties();
                            // the photo URL may be already available in the resource cache
                            getPhoto();
                        }
                        /**
                         * An internal event handler invoked only when some other object
                         * is binding to a Person property for the first time.
                         */
                        function onPropertySubscribed(p) {
                            p.observed = true;
                            switch (p.type) {
                                case PropType.direct:
                                    prContact.get().then(function (r) {
                                        if (!r.has(p.internalName))
                                            fetchContactResource();
                                    });
                                    break;
                                case PropType.linked:
                                    // the link href of the property isn't needed: the subscription
                                    // and the consequent updates can be handled without this link
                                    createSubscription(p);
                                    break;
                                case PropType.photo:
                                    // as of Oct 2014 UCWA doesn't have an API to create a subscription
                                    // to a contact's photo; if later it gets one, this is the right place
                                    // to invoke it; for now creating a subscription to a contact's photo
                                    // is no different from fetching it once
                                    p.property.get();
                                    break;
                            }
                        }
                        function onPropertyUnsubscribed(p) {
                            p.observed = false;
                            if (p.type == PropType.linked)
                                deleteSubscription();
                        }
                        /**
                         * Fetches the rel=contact resource once.
                         * Subsequent calls to this function return
                         * an already resolved promise.
                         */
                        function fetchContactResource() {
                            if (!dfdGet) {
                                dfdGet = prContact.get().then(function (r) {
                                    return ucwa.send('GET', r.href);
                                });
                                // if the server returned the rel=contact resource,
                                // don't fetch it again as it's unlikely it will change;
                                // but if the server failed to return the resource,
                                // allow further attempts to fetch it again
                                dfdGet.then(null, function () {
                                    dfdGet = null;
                                });
                            }
                            return dfdGet;
                        }
                        /**
                         * Sends only one GET to a linked resource even if invoked multiple times.
                         */
                        function fetchLinkedProperty(link) {
                            // TODO: This is a pretty common pattern which is known as debouncing.
                            if (!dfdGetLink[link]) {
                                dfdGetLink[link] = ucwa.send('GET', link).finally(function () {
                                    dfdGetLink[link] = null;
                                });
                            }
                            return dfdGetLink[link];
                        }
                        /**
                         * Fetches Person photo from the server
                         */
                        function getPhoto() {
                            if (properties.avatarUrl.link) {
                                return Person.getPhotoUrl({
                                    ucwa: ucwa,
                                    path: properties.avatarUrl.link
                                }).then(function (url) {
                                    properties.avatarUrl.property(url);
                                });
                            }
                        }
                        function createSubscription(prop) {
                            subscriptionRefCount++;
                            if (subscriptionRefCount == 1) {
                                // fetch the SIP URI if it's not available
                                properties.id.property.get().then(function (uri) {
                                    subscription = psm.subscribe(uri);
                                });
                            }
                            else if (prop.dirty) {
                                // subscription already exists but we ignored this property updates so far because
                                // there were no observers of this particular property - so we may not see another
                                // property update event and we need to fetch the property value explicitly.
                                //
                                // the check for subscription is needed to prevent GETs for props subscribed
                                // immediately after the first subscription in the same event cycle:
                                //
                                //    contact.status.changed(...) -> POST subscription
                                //    contact.note.text.changed(...) -> no GET here - we'll get the value from the 'note updated' event.
                                prop.property.get();
                            }
                        }
                        function deleteSubscription() {
                            subscriptionRefCount--;
                            if (subscriptionRefCount == 0 && subscription) {
                                subscription.dispose();
                                subscription = null;
                            }
                        }
                        /**
                         * presence subscription event handler
                         */
                        function onSubscriptionEvent(event) {
                            // prContact can be empty if this rel=contact is supposed to be inside a rel=participant
                            // which doesn't have the /contact link at the moment. However it wouldn't be correct to
                            // require the /contact link here as this event cannot be related to this contact. This
                            // follows from a simple observation: an event like "presence updated in contact" can arrive
                            // only if the model has created a presence subscription and the model creates a presence
                            // subscription only after it gets the /contact.uri value. You might have noticed that the ctor
                            // of the person model can theoretically take the .uri value from the parent rel=participant
                            // resource and create a presence subscription without fetching the rel=contact resource,
                            // but then prContact won't be empty. This event can be relevant while prContact is empty only
                            // if the following conditions are met:
                            //
                            //  1. This rel=contact is supposed to be a link in a rel=participant.
                            //  2. The rel=participant doesn't have the /contact link.
                            //  3. The rel=participant has the .uri value.
                            //  4. The implementation of the person model can take the .uri from the parent participant model.
                            //  5. The implementation of the person model can create a presence subscription without fetching rel=contact.
                            //
                            // This is theoretically possible and might be a good optimization in the future.
                            var r = prContact();
                            var target = event.target;
                            var scope = event['in'];
                            if (target && event.type == 'updated' && scope && r && scope.href == r.href) {
                                // status, activity, note, location, capabilities, relationship changes
                                foreach(properties, function (p) {
                                    if (p.type == PropType.linked && target.rel == p.internalName) {
                                        if (p.observed) {
                                            p.property.get();
                                            p.dirty = false;
                                        }
                                        else {
                                            p.dirty = true;
                                        }
                                    }
                                });
                            }
                        }
                        /**
                         * Sets linked properties with the values found in the repository.
                         * Those that lack data in the repository are returned by this function as an array.
                         *
                         * @returns An array of linked properties that need to be fetched from the server.
                         */
                        function updateLinkedPropsOrGetMissingProperties() {
                            var missing = [];
                            // check repository first, we may already have linked resources
                            foreach(properties, function (p) {
                                var r;
                                // when joining an online meeting anonymously, UCWA gives a limited
                                // subset of links that are given in the normal mode; e.g. rel=contactPresence
                                // is not available in the anonymous mode
                                if (p.type == PropType.linked && p.link) {
                                    r = ucwa.get(p.link);
                                    if (!isEmptyObject(r.properties))
                                        updatePropertyFromResource(p, r);
                                    else
                                        missing.push(p);
                                }
                            });
                            return missing;
                        }
                        /**
                         * Sets the property with the value from a resource property
                         *
                         * @param {object} p - element of the internal properties collection
                         * @param {Resource} r - resource containing that property data
                         */
                        function updatePropertyFromResource(p, r) {
                            // the following logic specially handles the internal
                            // properties of Person.capabilities
                            var value = !p.field ? r.get() :
                                p.element ? indexOf(r.get(p.field), p.element) >= 0 :
                                    r.properties[p.field];
                            p.property(p.transform ? p.transform(value) : value);
                        }
                        //#endregion
                        // return the read-only copy of Person properties
                        return extend(self, Person.prototype, {
                            // properties not defined by UCWA yet
                            firstName: ConstProperty(null),
                            lastName: ConstProperty(null)
                        });
                    }
                    /**
                     * Subscribes to every observed property and collection.
                     * This method is common for MePerson and Person and is
                     * used only by LWX and SWX. It's not meant to be used by
                     * other apps.
                     */
                    Person.prototype.subscribe = function () {
                        var subs = [], self = this;
                        foreach(self, function visit(member) {
                            if (isProperty(member) || isCollection(member)) {
                                if (member.observed())
                                    subs.push(member.subscribe());
                            }
                            if (isModel(member))
                                foreach(member, visit);
                        });
                        return new Subscription(function () {
                            for (var _i = 0; _i < subs.length; _i++) {
                                var s = subs[_i];
                                s.dispose();
                            }
                            subs = [];
                        });
                    };
                    return Person;
                })();
                Internal.Person = Person;
                var Person;
                (function (Person) {
                    var Status;
                    (function (Status) {
                        Status.Away = 'Away';
                        Status.BeRightBack = 'BeRightBack';
                        Status.Busy = 'Busy';
                        Status.DoNotDisturb = 'DoNotDisturb';
                        Status.Offline = 'Offline';
                        Status.Online = 'Online';
                        Status.Idle = 'Idle';
                        Status.Unknown = 'Unknown';
                    })(Status = Person.Status || (Person.Status = {}));
                    function fixDeviceType(t) {
                        return { PC: 'Desktop', Mobile: 'Mobile', Web: 'Web' }[t] || 'Unknown';
                    }
                    Person.fixDeviceType = fixDeviceType;
                    /**
                     * Takes a path to a Person's photo and returns the photo's URL
                     * that can be used by the <img> element.
                     *
                     * This function completes or fails synchronously in all production
                     * topologies.
                     *
                     * @param {UCWA} ucwa
                     * @param {String} path - href of the "contactPhoto" resource
                     *
                     * @returns {Promise<String>} URL usable by <img> elements.
                     */
                    Person.getPhotoUrl = async(function (_a) {
                        var ucwa = _a.ucwa, path = _a.path;
                        // Use the URI class to extract the domain name from
                        // the rel=applications href and combine it with the photo's path.
                        // After auto-discovery and authentication steps are passed, SkypeWeb
                        // sends a POST to rel=applications to create a rel=application
                        // resource; in a reply to that POST the server sends a cookie
                        // called cwt_ucwa which is associated with the .../photos path and
                        // thus is used by the browser to download contact photos.
                        // It's important to keep in mind that rel=applications and rel=user
                        // may belong to different pools and a web ticket issued by one pool
                        // may not work in another pool.
                        //
                        // TODO: Use URL or rel=xframe. Both rel=applications and rel=xframe
                        // contain the valid host name in their URLs, so no need to demand
                        // that a web app store rel=applications in a snapshot. Note, that
                        // in some topologies the client is redirected between pools and xframes
                        // during auto discovery and sign in, so the repository may contain
                        // multiple rel=xframe resources.
                        var app = ucwa.get({ rel: 'applications' });
                        var url = new URI(app.href).path(path).query('');
                        return url + '';
                    });
                })(Person = Internal.Person || (Internal.Person = {}));
            })(Internal = Model_17.Internal || (Model_17.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_18) {
            var Internal;
            (function (Internal) {
                'use strict';
                var map = Web.Utils.map;
                var clone = Web.Utils.clone;
                var debug = Web.Utils.debug;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var batched = Web.Utils.batched;
                var foreach = Web.Utils.foreach;
                var inherit = Web.Utils.inherit;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var timeStampToDate = Web.Utils.timeStampToDate;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Enum = Web.Utils.Enum;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var ConstProperty = Web.Utils.ConstProperty;
                var SequentialStateMachine = Web.Utils.SequentialStateMachine;
                /**
                 * Represents the currently signed-in user and is built on top of the "me" resource.
                 *
                 * @created Sep 2013
                 * @blame sosobov
                 * @blame antonkh
                 * @blame yodu
                 */
                var MePerson = (function () {
                    //#endregion
                    function MePerson(ucwa, options) {
                        var supportsText = Property.bool(false);
                        var supportsHtml = Property.bool(false);
                        var supportsMessaging = supportsText.or(supportsHtml);
                        var supportsAudio = Property.bool(false);
                        var supportsVideo = Property.bool(false);
                        var supportsSharing = Property.bool(false);
                        var supportsConferencing = options && options.supportsConferencing || ConstProperty(false);
                        var guestName = options && options.guestName;
                        var canChangeCapabilities = Property.bool(true);
                        var eReconnecting = Exception('Reconnecting');
                        var dfdGet; // it's tracking the GET rel=me requests
                        var State = Enum('Unavailable', 'Available');
                        var sm = SequentialStateMachine(State.Unavailable);
                        var requests = {}; // requests.note = a GET for /me/note
                        var properties = {};
                        var proto = Model();
                        var self = inherit(proto);
                        var tm = options && options.tm;
                        options = null; // reduce the scope of "options" to the initialization part
                        var dfdrMe = ucwa.init().then(function () {
                            var r = ucwa.get({ rel: 'me' });
                            return isEmptyObject(r.properties) ?
                                ucwa.send('GET', { rel: 'me' }).then(function () { return r; }) :
                                r;
                        });
                        sm.defineState(State.Available, function () {
                            return makeMeAvailable().then(function () {
                                startReportingActivity();
                                // every time ucwa fails and then gets restored,
                                // most of the state, including the availability,
                                // disappears and needs to be recreated
                                ucwa.restored(function () {
                                    available(false, eReconnecting);
                                    makeMeAvailable().then(function () {
                                        available(true);
                                    });
                                });
                                ucwa.connected.when(false, function () {
                                    available(false);
                                });
                            });
                        });
                        //#region properties
                        defineProperty('id', {
                            source: 'uri'
                        });
                        defineProperty('displayName', {
                            source: 'name'
                        });
                        defineProperty('title', {
                            source: 'title'
                        });
                        defineProperty('department', {
                            source: 'department'
                        });
                        defineProperty('emails', {
                            source: 'emailAddresses',
                            isCollection: true,
                            parse: function (value) {
                                return map(value || [], function (email) {
                                    return Model({
                                        type: ConstProperty(null),
                                        emailAddress: ConstProperty(email)
                                    });
                                });
                            }
                        });
                        defineProperty('email', {
                            source: 'emailAddresses',
                            parse: function (value) {
                                return value && value[0] || '';
                            }
                        });
                        self.phoneNumbers = defineLinkedProperty('phoneNumbers', {
                            source: 'phones',
                            isCollection: true,
                            parse: function (phones) {
                                return map(phones || [], function (phone) {
                                    var p = phone.properties, type = p && p.type && p.type.charAt(0).toUpperCase() + p.type.slice(1);
                                    return {
                                        type: ConstProperty(type),
                                        telUri: ConstProperty(p.number),
                                        displayString: ConstProperty(null)
                                    };
                                });
                            },
                            fetchAll: function (r) {
                                return Task.waitAll(map(r.links('phone'), function (link) {
                                    return ucwa.send('GET', link.href);
                                }));
                            }
                        });
                        self.note = Model({
                            text: defineLinkedProperty('note.text', {
                                source: 'note',
                                fetchOnce: true,
                                parse: function (data) {
                                    return data && data.message;
                                },
                                compose: function (message) {
                                    return message && message.message ? clone(message) :
                                        { message: message, type: self.note.type() || 'Personal' };
                                }
                            }),
                            type: defineLinkedProperty('note.type', {
                                source: 'note',
                                parse: function (data) {
                                    return data && data.type;
                                }
                            }).asReadOnly()
                        });
                        self.location = defineLinkedProperty('location', {
                            source: 'location',
                            fetchOnce: true,
                            parse: function (data) {
                                return data && data.location;
                            },
                            compose: function (location) {
                                return { location: location };
                            }
                        });
                        // the location property contains a few sub-properties
                        // (they are not defined by UCWA but needed in jCafe)
                        extend(self.location, {
                            type: ConstProperty('Unknown'),
                            street: ConstProperty(null),
                            city: ConstProperty(null),
                            state: ConstProperty(null),
                            country: ConstProperty(null),
                            postalCode: ConstProperty(null)
                        });
                        self.status = defineLinkedProperty('status', {
                            source: 'presence',
                            value: 'Offline',
                            fetchOnce: true,
                            parse: function (object) {
                                return object ? object.availability : 'Offline';
                            },
                            compose: function (value) {
                                var object = {};
                                object.availability = value;
                                return object;
                            }
                        });
                        self.activity = defineLinkedProperty('activity', {
                            source: 'presence',
                            parse: function (object) {
                                return object && object.activity;
                            }
                        }).asReadOnly();
                        self.endpointType = defineLinkedProperty('endpointType', {
                            source: 'presence',
                            parse: function (object) {
                                return Internal.Person.fixDeviceType(object && object.deviceType);
                            }
                        }).asReadOnly();
                        self.isBlocked = ConstProperty(false);
                        self.lastSeenAt = defineLinkedProperty('lastSeenAt', {
                            source: 'presence',
                            parse: function (object) {
                                return object && timeStampToDate(object.lastActive);
                            }
                        }).asReadOnly();
                        self.note.reset = function () { return sm.advanceTo(State.Available)
                            .then(function () { return ucwa.send('POST', { rel: 'note' }, { data: {} }); })
                            .then(function (r) { return null; }); };
                        self.status.reset = function () { return sm.advanceTo(State.Available)
                            .then(function () { return ucwa.send('POST', { rel: 'presence' }, { data: {} }); })
                            .then(function (r) { return null; }); };
                        self.location.reset = function () { return sm.advanceTo(State.Available)
                            .then(function () { return ucwa.send('POST', { rel: 'location' }, { data: {} }); })
                            .then(function (r) { return null; }); };
                        var photo = defineProperty('avatarUrl', {
                            source: 'photo'
                        });
                        var available = Property.bool(false);
                        // whenever me.available.set(true) is invoked
                        // send a POST request to rel=makeMeAvailable and
                        // only then change the value of me.available
                        self.available = available.fork(function (newValue) {
                            // if this throws, the cached value won't be changed
                            if (available() && !newValue)
                                throw new Error('cannot downgrade the availability by calling me.available(false)');
                            if (!available() && newValue) {
                                return sm.advanceTo(State.Available).then(function () {
                                    available(newValue);
                                    return newValue;
                                });
                            }
                            // this value will be set to MePerson::available
                            return newValue;
                        });
                        self.active = Property.bool(true);
                        self.account = ConstProperty(null);
                        self.capabilities = Model({
                            chat: extend(supportsMessaging, {
                                text: supportsText.fork(canChangeCapabilities),
                                html: supportsHtml.fork(canChangeCapabilities)
                            }),
                            audio: supportsAudio.fork(canChangeCapabilities),
                            video: supportsVideo.fork(canChangeCapabilities),
                            screenSharing: supportsSharing.fork(canChangeCapabilities),
                            dataCollaboration: ConstProperty(false),
                            conferencing: supportsConferencing
                        });
                        //#endregion
                        //#region Internal Methods
                        //#region defineProperty
                        /**
                         * @param name - The desired name of the property in the MePerson model.
                         * @param options - An object with the following parameters:
                         * - source - The name of the property in the rel=me resource.
                         * - isCollection - A flag to indicate whether this is a Collection or Property.
                         * - parse
                         *
                         *      Takes the value from the resource and converts it to
                         *      a value that will be published in the model's properties.
                         *
                         * @returns {Property|Collection}
                         */
                        function defineProperty(name, options) {
                            assert(!self[name]);
                            var source = options && options.source;
                            var parse = options && options.parse || (function (x) { return x; });
                            var property = (options && options.isCollection ? Collection : Property)({
                                get: function () {
                                    // a user can legitimately write something like:
                                    //
                                    //      me.title.get().then(...);
                                    //      me.name.get().then(...);
                                    //      me.uri.get().then(...);
                                    //      ...
                                    //
                                    // and will reasonably expect to see only one GET request
                                    // to grab all these properties; dfdGet solves this case
                                    if (!dfdGet) {
                                        dfdGet = dfdrMe.then(function () {
                                            return ucwa.send('GET', { rel: 'me' });
                                        }).finally(function () {
                                            dfdGet = null;
                                        });
                                    }
                                    return dfdGet.then(function () {
                                        return property();
                                    });
                                }
                            });
                            properties[name] = property;
                            self[name] = property.asReadOnly();
                            dfdrMe.then(function (rMe) {
                                rMe.updated(function () {
                                    if (rMe.has(source))
                                        property(parse(rMe.get(source)));
                                });
                                rMe.deleted(function () {
                                    // reset properties when resource is deleted
                                    property(parse(void 0));
                                });
                            });
                            return property;
                        }
                        //#endregion
                        //#region defineLinkedProperty
                        /**
                         * @param name - The desired name of the property in the MePerson model.
                         * @param type - The type name.
                         * @param source - The rel of the link in the rel=me resource.
                         *
                         * @param parse
                         *
                         *      Takes the value from the resource and converts it to
                         *      a value that will be published in the model's properties.
                         *
                         * @param compose
                         *
                         *      Takes the value from the model's property, when the view specifies the new value,
                         *      and converts it to a format that is acceptable by UCWA.
                         *
                         * @returns {Property}
                         */
                        function defineLinkedProperty(name, options) {
                            assert(!self[name]);
                            var rel = options.source;
                            var source = { rel: rel };
                            var parse = options.parse;
                            var compose = options.compose;
                            var fetchAll = options.fetchAll;
                            var fetchOnce = options.fetchOnce;
                            var expected = {};
                            var property = (options && options.isCollection ? Collection : Property)({
                                subscribed: subscribe,
                                value: options.value,
                                get: function () {
                                    // The link appears only after the client sends a POST
                                    // to rel=makeMeAvailable. However if the link is already
                                    // available, don't send extra requests.
                                    return dfdrMe.then(function () {
                                        return ucwa.exists(source) ?
                                            fetch() :
                                            subscribe();
                                    });
                                },
                                set: function (value) {
                                    if (value === expected) {
                                        expected = {};
                                        return value;
                                    }
                                    tm && tm.record('me_set', { rel: rel });
                                    return sm.advanceTo(State.Available).then(function () {
                                        return post(rel, compose(value));
                                    }).then(function () {
                                        // Leave the old value in the property.
                                        // It will be updated after the corresponding
                                        // "updated" event from the server.
                                        return property();
                                    });
                                }
                            });
                            function set(value) {
                                expected = value;
                                property(value);
                                return value;
                            }
                            function fetch() {
                                // send the GET only once, even if it has been requested many times
                                requests[rel] = requests[rel] || ucwa.send('GET', source).finally(function () {
                                    requests[rel] = null;
                                });
                                return requests[rel].then(function (r) {
                                    return Task.wait(fetchAll ? fetchAll(r) : r.properties).then(parse).then(set);
                                });
                            }
                            function subscribe() {
                                return sm.advanceTo(State.Available).then(fetch);
                            }
                            ucwa.event(function (event) {
                                if (event.type in { updated: 1, added: 1 } && event.target && event.target.rel == source.rel)
                                    fetch();
                                else if (event.type == 'deleted' && event.target && event.target.rel == source.rel) {
                                    // reset properties when resource is deleted
                                    set(parse(void 0));
                                }
                            });
                            dfdrMe.then(function () {
                                // The linked resource is there in two cases:
                                // 1. The app is being restored from a snapshot.
                                // 2. The app is connecting to an existing endpoint.
                                if (ucwa.exists(source)) {
                                    if (!isEmptyObject(ucwa.get(source).properties)) {
                                        // If the linked resource contains some data, the app is being restored
                                        // from a snapshot and the value of the property can be taken from there.
                                        set(parse(ucwa.get(source).properties));
                                    }
                                    else if (fetchOnce) {
                                        // If the link is there, but the corresponding resource has no data,
                                        // then the app must be connecting to an existing endpoint. If this was
                                        // a regular sign in, the init sequence would be as following:
                                        //
                                        //      POST /applications
                                        //      POST /me/makeMeAvailable
                                        //      GET /me
                                        //
                                        //      me updated
                                        //      note added
                                        //      presence added
                                        //      location added
                                        //
                                        //      GET /me/note
                                        //      GET /me/presence
                                        //      GET /me/location
                                        //
                                        // When the app is forking an endpoint, UCWA gives an already initialized
                                        // endpoint and the sequence changes to:
                                        //
                                        //      POST /applications
                                        //
                                        // Because the returned /me already has /reportMyActivity, the app
                                        // doesn't need to POST /me/makeMeAvailable and UCWA wouldn't send
                                        // these "updated" and "added" events anyway. Instead, it gives an
                                        // already intialized /me resource with all the links: /note, /presence,
                                        // /location, /phones and so on. Since in the regular sign in the
                                        // data from these links are always fetched and since the point of SDK
                                        // is to hide differences between the two types of sign ins, it's reasonable
                                        // to fetch data from these links if the app is forking an endpoint.
                                        fetch();
                                    }
                                }
                            });
                            properties[name] = property;
                            return property;
                        }
                        //#endregion
                        //#region post
                        /**
                         * Sends a POST to the given rel.
                         *
                         * The actual POST request at the next event loop to handle the case
                         * when the same or related properties are set multiple times. If this
                         * happens, conflicting requests are merged at the next event loop and
                         * only one POST request is sent.
                         *
                         * @param {String} rel
                         * @param {Object} data
                         *
                         * @returns {Promise}
                         */
                        function post(rel, data) {
                            var resource = ucwa.get({ rel: rel });
                            post[rel] = post[rel] || batched(function (values) {
                                var merged = clone(resource.properties);
                                foreach(values, function (v) {
                                    extend(merged, v);
                                });
                                return ucwa.send('POST', { rel: rel }, {
                                    data: merged,
                                    nobatch: true
                                });
                            }, Infinity);
                            return post[rel](data, 0);
                        }
                        //#endregion
                        //#region makeMeAvailable
                        /**
                         * This lets other users see the presence of this user and
                         * also tells the server to send presence, location and note updates.
                         */
                        function makeMeAvailable() {
                            var isReconnecting = available.reason === eReconnecting;
                            var formats = [];
                            var modalities = [];
                            if (supportsText())
                                formats.push('Plain');
                            if (supportsHtml())
                                formats.push('Html');
                            if (supportsMessaging())
                                modalities.push('Messaging');
                            if (supportsAudio())
                                modalities.push('Audio');
                            if (supportsVideo())
                                modalities.push('Video');
                            if (supportsSharing())
                                modalities.push('ApplicationSharing');
                            return dfdrMe.then(function () {
                                // if the client is restoring its state from a snapshot,
                                // it must take into account that previously another client
                                // may have sent a POST to rel=makeMeAvailable and UCWA
                                // does not allow to send this request twice; so the intent here
                                // is to check whether that POST request was sent and if it was,
                                // don't send it again
                                if (isReconnecting || !ucwa.exists({ rel: 'reportMyActivity' })) {
                                    tm && tm.record('me_make_available');
                                    // TODO: changing capabilities after POST rel=makeMeAvailable can be done with PUT rel=communication
                                    canChangeCapabilities(false);
                                    // in the anonymous mode there is no rel=makeMeAvailable link
                                    return ucwa.send('POST', { rel: 'makeMeAvailable' }, {
                                        data: { SupportedModalities: modalities, SupportedMessageFormats: formats },
                                        nobatch: true
                                    }).then(function () {
                                        if (!isReconnecting)
                                            return ucwa.send('GET', { rel: 'me' }, { nobatch: true });
                                    });
                                }
                            });
                        }
                        //#endregion
                        //#region startReportingActivity
                        /**
                         * To let the server know that the web client is active a POST
                         * request to the "reportMyActivity" resource must be sent every
                         * 3 minutes. Otherwise the user's availability will be changed
                         * to a less available status.
                         */
                        function startReportingActivity() {
                            var id = Web.setInterval(function () {
                                if (self.active()) {
                                    ucwa.send('POST', { rel: 'reportMyActivity' }, {
                                        nobatch: true
                                    }).catch(function (err) {
                                        // After a long period of inactivity, the connection with UCWA is usually lost.
                                        // While the connection is being restored, MePerson resends POST /makeMeAvailable.
                                        // However this periodic timer doesn't know about that logic and keeps sending
                                        // POST /reportMyActivity as usual. If the timer happens to wake up before the
                                        // /makeMeAvailable is completed, UCWA will reject this /reportMyActivity with a
                                        // 409.MakeMeAvailableRequired error.
                                        if (err && err.code == 'RequestFailed' && err.rsp.status == 409)
                                            return;
                                        debug.log('%c reportMyActivity stopped', 'color:red;font-weight:bold', err);
                                        Web.clearInterval(id);
                                        self.active(false, err);
                                    });
                                }
                            }, 3 * 60 * 1000);
                        }
                        //#endregion
                        //#endregion Internal Methods
                        //#region initialization
                        if (guestName)
                            guestName.changed(properties.displayName);
                        dfdrMe.then(function (rMe) {
                            setHiddenProperty(proto, Internal.sHref, rMe.href);
                            // the rel=me/photo link may appear after the ctor of MePerson was invoked:
                            // to handle this case MePerson needs to subscribe to rel=me and fetch the photo
                            // when the rel=me/photo link becomes available
                            rMe.updated(function fn() {
                                if (rMe.hasLink('photo') && !photo()) {
                                    // no more events needed from rel=me
                                    rMe.updated.off(fn);
                                    // try to get the actual photo URL and if it's not possible,
                                    // use the original href as the URL
                                    Internal.Person.getPhotoUrl({
                                        ucwa: ucwa,
                                        path: rMe.link('photo').href
                                    }).catch(function () {
                                        return rMe.link('photo').href;
                                    }).then(function (url) {
                                        photo(url);
                                    });
                                }
                            });
                        });
                        // TODO: Bind these properties to .supportedModalities and .supportedMessageFormats
                        // of rel=communication. For now the values are read from the snapshot once before
                        // signing in. Note, that the binding shouldn't change the initial values set from
                        // outside (by UI for example) before signing in.
                        try {
                            var rc = ucwa.get({ rel: 'communication' });
                            var sm_1 = rc.get('supportedModalities', []);
                            var sf = rc.get('supportedMessageFormats', []);
                            if (sf.indexOf('Plain') >= 0)
                                supportsText(true);
                            if (sf.indexOf('Html') >= 0)
                                supportsHtml(true);
                            if (sm_1.indexOf('Audio') >= 0)
                                supportsAudio(true);
                            if (sm_1.indexOf('Video') >= 0)
                                supportsVideo(true);
                            if (sm_1.indexOf('ApplicationSharing') >= 0)
                                supportsSharing(true);
                        }
                        catch (_) {
                        }
                        //#endregion
                        return extend(self, Internal.Person.prototype, {
                            // properties not defined by UCWA yet
                            firstName: ConstProperty(null),
                            lastName: ConstProperty(null),
                            office: ConstProperty(null),
                            company: ConstProperty(null)
                        });
                    }
                    return MePerson;
                })();
                Internal.MePerson = MePerson;
            })(Internal = Model_18.Internal || (Model_18.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_19) {
            var Internal;
            (function (Internal) {
                'use strict';
                var map = Web.Utils.map;
                var find = Web.Utils.find;
                var guid = Web.Utils.guid;
                var async = Web.Utils.async;
                var check = Web.Utils.check;
                var debug = Web.Utils.debug;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var indexOf = Web.Utils.indexOf;
                var isArray = Web.Utils.isArray;
                var isString = Web.Utils.isString;
                var contains = Web.Utils.contains;
                var isDictionary = Web.Utils.isDictionary;
                var timeStampToDate = Web.Utils.timeStampToDate;
                var convertHtmlToText = Web.Utils.convertHtmlToText;
                var convertTextToHtml = Web.Utils.convertTextToHtml;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var SipUri = Web.Utils.SipUri;
                var Symbol = Web.Utils.Symbol;
                var Command = Web.Utils.Command;
                var DataUri = Web.Utils.DataUri;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var StringEnum = Web.Utils.StringEnum;
                var ConstProperty = Web.Utils.ConstProperty;
                var EAlreadyExists = Web.Utils.EAlreadyExists;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                // Modality.State.... stuff is too long: to avoid splitting one line into
                // had to make these shorter aliases; also good for minifying
                var cCreated = Internal.Modality.State.Created;
                var cNotified = Internal.Modality.State.Notified;
                var cConnected = Internal.Modality.State.Connected;
                var cConnecting = Internal.Modality.State.Connecting;
                var cDisconnected = Internal.Modality.State.Disconnected;
                var sStatus = Symbol('status'); // status property of a queued message
                var sStartingMessaging = Symbol('starting'); // serves as state.reason when state=Connecting    
                function makeMultipartRequest(request, context, revision, boundary) {
                    var contentId = '367A2DAE00F7417FB5CEFE6364C97D31';
                    var strRequest = JSON.stringify(extend({}, request, { customContent: 'CID:' + contentId }));
                    var strContext = JSON.stringify(context);
                    var payload = [
                        '--' + boundary,
                        'Content-Type: application/vnd.microsoft.com.ucwa+json',
                        'Content-Length: ' + strRequest.length,
                        '',
                        strRequest,
                        '--' + boundary,
                        'Content-Type: text/json',
                        'Content-Id: ' + contentId,
                        // this specified field allows the multipart content always processed to
                        // the endpoint, which may not regiser 'text/json' as its supported format.
                        'Content-Disposition: render; handling=optional',
                        '',
                        strContext,
                        '--' + boundary + '--',
                        ''
                    ].join('\r\n');
                    return {
                        headers: {
                            'Content-Type': 'multipart/related;boundary=' + boundary + ';type="application/vnd.microsoft.com.ucwa+json"',
                            'Content-Length': payload.length,
                            'X-MS-RequiresMinResourceVersion': revision
                        },
                        data: payload
                    };
                }
                /**
                 * The ChatService model is one of conversation modalities, which establishes
                 * the channel for participants to send instant messages.
                 *
                 * @created Aug 2013
                 * @blame antonkh
                 */
                var ChatService = (function () {
                    //#endregion
                    function ChatService(_a) {
                        var ucwa = _a.ucwa, conversation = _a.conversation, rInvitation = _a.rInvitation, guestName = _a.guestName, tm = _a.tm;
                        //#region locals
                        var participants = conversation.participants;
                        var localParticipant = conversation.selfParticipant;
                        var subject = conversation.topic;
                        var priority = conversation.priority;
                        var threadId = conversation.threadId;
                        var messages = Collection();
                        /** Indexed by participant hrefs since this collection
                            is emptied after the conversation ends. */
                        var typingParticipants = Collection();
                        var rMessaging; // rel=messaging
                        var state = Property();
                        var nMessageEvents = 0; // the number of received "message completed" events
                        var dfdStart; // promise returned by ChatService::start
                        var dfdAccept; // promise returned by ChatService::accept            
                        var lastMessage; // last message received
                        var invitationMessage; // last invitation message
                        var negotiatedFormats = Collection({
                            get: function () {
                                var formats = rMessaging.get('negotiatedMessageFormats');
                                var dict = map(formats, function (fmt) { return fmt == 'Plain' ? 'Text' : fmt; });
                                return StringEnum.apply(null, dict);
                            }
                        });
                        var self = Model({
                            state: state.asReadOnly(),
                            messages: messages.asReadOnly(),
                            isAlerting: ConstProperty(true),
                            alertFilters: Collection.empty,
                            supportedMessageFormats: negotiatedFormats.asReadOnly(),
                            typingParticipants: typingParticipants.asReadOnly()
                        });
                        //#endregion
                        //#region internals
                        function getParticipant(href) {
                            return find(conversation.participants(), function (p) { return p[Internal.sHref] == href; });
                        }
                        function getMessageData(rMessage, rel) {
                            // "data:text/plain;charset=utf-8,how+are+you%3F" => "how are you?"
                            return DataUri(rMessage.relatedHref(rel) || 'data:,').data || '';
                        }
                        function isMessageFormatNegotiated(format) {
                            try {
                                return indexOf(rMessaging.get('negotiatedMessageFormats'), format) >= 0;
                            }
                            catch (err) {
                                // either rel=messaging is absent or it's missing the list of formats
                                return false;
                            }
                        }
                        //#region chooseMessageFormat
                        /**
                         * The point of this function is to chose one data format to
                         * send to the server based on a set of formats given to SkypeWeb
                         * and a set of formats accepted by the remote participant.
                         *
                         * It's unlikely that the SDK and UCWA will ever support RTF or
                         * other text formats that will be exotic to web clients, so this function
                         * can assume that only two formats exist: text/plain and text/html.
                         *
                         * This function must take into consideration remote clients
                         * that cannot read html (OWA for example).
                         */
                        function chooseMessageFormat(message) {
                            // if this is the very first message in a conversation
                            // that is being started, there will be no rel=messaging
                            // resource and the list of negotiated formats will be empty
                            if ('html' in message)
                                return isMessageFormatNegotiated('Html') || !rMessaging ?
                                    { type: 'text/html', data: message.html + '' } :
                                    { type: 'text/plain', data: convertHtmlToText(message.html + '') };
                            if ('text' in message)
                                return isMessageFormatNegotiated('Plain') || !isMessageFormatNegotiated('Html') ?
                                    { type: 'text/plain', data: message.text + '' } :
                                    { type: 'text/html', data: convertTextToHtml(message.text + '') };
                            throw EInvalidArgument('message', 'must contain either `text` or `html` format');
                        }
                        //#endregion
                        //#region addIncomingMessage
                        /**
                         * Reads a resource representing an incoming message
                         * and adds a corresponding message model to the collection.
                         */
                        function addIncomingMessage(resource) {
                            var phref = resource.link('participant').href;
                            var sender = getParticipant(phref);
                            if (!sender)
                                throw Error('There is no participant with href=' + phref);
                            var message = new Internal.Message({
                                href: resource.href,
                                sender: sender,
                                text: getMessageData(resource, 'plainMessage'),
                                html: getMessageData(resource, 'htmlMessage'),
                                time: new Web.Date,
                                direction: Internal.Message.Direction.Incoming,
                                ucwa: ucwa
                            });
                            // don't add the invitation message twice to the collection
                            if (!isInvitationMessage(message))
                                messages.add(message);
                            lastMessage = message;
                        }
                        //#endregion
                        function isInvitationMessage(message) {
                            return invitationMessage && invitationMessage === lastMessage &&
                                lastMessage.direction() == message.direction();
                        }
                        function processFirstMessageInInvitation() {
                            var dmsg = DataUri(rInvitation.relatedHref('message') || 'data:,');
                            var text = dmsg.mime == 'text/plain' ? dmsg.data : '';
                            var html = dmsg.mime == 'text/html' ? dmsg.data : '';
                            // inviter is placed in the participants collection when the conversation is
                            // created from the invitation.
                            var sender = isIncoming() ? participants(0) : localParticipant;
                            var message = new Internal.Message({
                                sender: sender,
                                text: text,
                                html: html,
                                direction: Internal.Message.Direction.Incoming,
                                ucwa: ucwa
                            });
                            // sometimes the invitation doesn't contain a message
                            if (text || html) {
                                lastMessage = invitationMessage = message;
                                messages.add(message);
                            }
                            // TODO: the .toast member is deprecated and will be removed
                            self.toast = Model({
                                sender: sender,
                                text: message.text,
                                html: message.html,
                                priority: ConstProperty(rInvitation.get('importance', void 0)),
                                subject: ConstProperty(disableHtmlInText(rInvitation.get('subject', void 0)))
                            });
                        }
                        function addOutgoingMessage(options) {
                            var message = new Internal.Message({
                                href: options.href,
                                sender: localParticipant,
                                text: options.text,
                                html: options.html,
                                status: options.status,
                                time: options.timestamp,
                                direction: Internal.Message.Direction.Outgoing,
                                ucwa: ucwa
                            });
                            // for outgoing messages the caller may specify the id
                            messages.add(message, options.id || guid());
                            return message;
                        }
                        // message completed, direction=Incoming/Outgoing
                        ucwa.observe('message completed', function (event) {
                            var r = event.resource;
                            if (rMessaging && r.link('messaging').href == rMessaging.href) {
                                if (r.get('direction') == 'Incoming') {
                                    nMessageEvents++;
                                    addIncomingMessage(r);
                                }
                                else {
                                    var message = find(messages(), function (m) { return m[Internal.sHref] == r.href; });
                                    // receiving an outgoing "message completed" event for a message
                                    // that isn't in the collection means that the message was sent
                                    // by another tab.
                                    if (!message) {
                                        addOutgoingMessage({
                                            href: r.href,
                                            text: getMessageData(r, 'plainMessage'),
                                            html: getMessageData(r, 'htmlMessage'),
                                            status: event.status == 'Success' ? Internal.Message.Status.Succeeded : Internal.Message.Status.Failed,
                                            timestamp: timeStampToDate(r.get('timeStamp', null))
                                        });
                                    }
                                }
                            }
                        });
                        function observeMessagingState() {
                            assert(rMessaging, 'rel=messaging must be known before starting observing its state');
                            rMessaging.updated(function () {
                                var newState = rMessaging.get('state', '');
                                if (newState == 'Disconnected')
                                    state(Internal.Modality.State.Disconnected);
                                else if (newState == 'Connected')
                                    state(Internal.Modality.State.Connected);
                                // this triggers the custom getter that pulls the formats
                                // from the resource and updates the collection
                                negotiatedFormats.get();
                            });
                        }
                        function getConversationResource() {
                            // sHref is an internal id available in this file
                            var href = conversation[Internal.sHref];
                            return href ? ucwa.get(href) : null;
                        }
                        function isConferencing() {
                            var rc = getConversationResource();
                            return rc && rc.get('state', '') == 'Conferenced';
                        }
                        function isMessagingActive() {
                            var rc = getConversationResource();
                            var href = rc && rc.hasLink('messaging') && rc.link('messaging').href;
                            var rm = href && ucwa.exists(href) && ucwa.get(href);
                            return rm && rm.get('state', null) == 'Connected';
                        }
                        function isIncomingMeetingRequest() {
                            return conversation.meeting &&
                                conversation.meeting.state() == 'Notified' &&
                                conversation.meeting.availableModalities.messaging();
                        }
                        function isIncoming() {
                            return rInvitation ? rInvitation.get('direction') == 'Incoming' : false;
                        }
                        // participant added/deleted in typingParticipants
                        ucwa.event(function (event) {
                            var target = event.target;
                            var context = event['in'] || {};
                            // if the event includes the 'in' property, it indicates it is for
                            // a typingParticipant's 'added' or 'deleted' events, other than for a participant's events.
                            if (rMessaging && rMessaging.hasLink('typingParticipants') && context.href == rMessaging.link('typingParticipants').href) {
                                if (event.type == 'deleted') {
                                    typingParticipants.remove(target.href);
                                }
                                else if (event.type == 'added') {
                                    var typingParticipant = getParticipant(target.href);
                                    if (typingParticipant && !typingParticipants(target.href))
                                        typingParticipants.add(typingParticipant, target.href);
                                }
                            }
                        });
                        // messagingInvitation started
                        ucwa.event(function (event) {
                            var resource = event.resource;
                            var target = event.target;
                            // messaging can be added to an existing 1:1 conversation by the remote participant
                            // messagingInvitation can also be outgoing in the multi-tab scenario
                            if (event.type == 'started' && target.rel == 'messagingInvitation' &&
                                resource.link('conversation').href == conversation[Internal.sHref]) {
                                rInvitation = resource;
                                processInvitation();
                            }
                        });
                        function setResource(r) {
                            rMessaging = r;
                            rMessaging.deleted(function () { return rMessaging = null; });
                        }
                        function setResourceAndObserveState(href) {
                            setResource(ucwa.get(href));
                            observeMessagingState();
                        }
                        function conversationUpdated() {
                            var rc = getConversationResource();
                            if (!rMessaging && rc.hasLink('messaging')) {
                                setResourceAndObserveState(rc.link('messaging').href);
                                rc.updated.off(conversationUpdated);
                            }
                        }
                        function defineAsyncCommand(name, states, method) {
                            var enabled = Property();
                            self[name] = Command(async(method), enabled);
                            state.changed(function (value) {
                                var isEnabled = contains(states, function (s) {
                                    return isArray(s) ?
                                        value == s[0] && state.reason === s[1] :
                                        value == s;
                                });
                                enabled(isEnabled);
                            });
                        }
                        //#endregion
                        //#region start
                        /**
                         * Sends the messaging invitation to participants.
                         * Under the hood it does the following to start messaging:
                         *
                         *      - Sends a POST to rel=startMessaging or rel=conversation/messaging/addMessaging.
                         *      - Waits for "messagingInvitation completed" event.
                         *      - Starts receiving "message completed" events.
                         *
                         * @param {String} to - SIP URI of whom to send the invitation to.
                         * @param {String} [name] - Display name for anonymously joined meetings.
                         * @param {String|Object} [message] - The first message in the conversation.
                         *
                         *  The message can contain the desired id of the first message:
                         *  see comments for the `send` method.
                         *
                         *  To start the conversation with the first plain text message use:
                         *
                         *      im.start('This is a plain text message');
                         *      im.start({ text : 'This is a plain text message' });
                         *
                         *  To start the conversation with the first html message use:
                         *
                         *      im.start({ html : '<b>This is a html message</b>' });
                         *
                         *  Note, that if the first message contains only the html format
                         *  and it's invalid, the .start method will return a rejected promise.
                         *
                         * @param [context] - An arbitrary object that can be serialized.
                         *
                         *  If set, the POST request to UCWA will be sent in a special multipart
                         *  format with all the regular invitation parameters plus this context.
                         *  The context is supposed to describe the invitation, so that the remote
                         *  participant may know why the request is sent.
                         *
                         * @returns {Promise<Message>}
                         */
                        defineAsyncCommand('start', [cCreated, [cConnecting, sStartingMessaging], cDisconnected], function (options) {
                            options = options || {};
                            var message = options.message;
                            var name = options.name || guestName && guestName();
                            var to = options.to;
                            var context = options.context;
                            var timestamp = options.timestamp;
                            var boundary = options.boundary; // can be given by unit tests
                            var operationId = options.operationId || guid(); // can be given by unit tests
                            var sessionContext = options.sessionContext || guid(); // can be given by unit tests
                            options = null;
                            if (to && !SipUri.test(to))
                                throw Error('.to must be a valid SIP URI');
                            if (message && !isString(message) && !isDictionary(message))
                                throw Error('.message must be a string or a { text: "...", html: "..." } object');
                            var firstMessage; // firstMessage === await im.start(...)
                            var status; // status of firstMessage
                            var isMeeting = conversation.isGroupConversation();
                            if (isString(message))
                                message = { text: message };
                            // in p2p mode take URI of the remote participant
                            if (!isMeeting) {
                                if (!to)
                                    to = participants(0).uri();
                                else
                                    check(participants.size() == 0, 'ambiguous remote party in 1:1 call');
                                check(to, 'the remote participant URI is not specified');
                            }
                            state(Internal.Modality.State.Connecting);
                            dfdStart = Task.run(function () {
                                if (conversation.meeting) {
                                    if (conversation.meeting.state() == Internal.OnlineMeeting.State.Created) {
                                        return conversation.meeting.start({
                                            name: name,
                                            uri: conversation.uri()
                                        });
                                    }
                                }
                                else if (isMeeting) {
                                    return conversation.addMeeting().start({
                                        // Needed for joining meetings anonymously.
                                        name: name,
                                        // If it's null, a new meeting will be created.
                                        // If it's not null, we wil join that meeting.
                                        uri: conversation.uri()
                                    });
                                }
                            }).then(function () {
                                var rc = getConversationResource();
                                // if there is no existing rel=conversation resource yet,
                                // send the messaging invitation to the global rel=startMessaging link;
                                // otherwise add the messaging modality to an existing conversation by
                                // sending the invitation to rel=conversation/messaging/addMessaging link.
                                if (!rc)
                                    return ucwa.get({ rel: 'communication' }).link('startMessaging');
                                var rm = ucwa.get(rc.link('messaging').href);
                                // if /messaging/addMessaging is available, no need to send the GET
                                return rm.hasLink('addMessaging') ?
                                    rm.link('addMessaging') :
                                    ucwa.send('GET', rm.href).then(function (r) { return r.link('addMessaging'); });
                            }).then(function (startMessagingLink) {
                                // the next step is to send a POST request to initiate a messaging invitation
                                // and to await the "messagingInvitation started" event that corresponds to
                                // the initiated invitation
                                var parameters = {
                                    operationId: operationId,
                                    threadId: threadId()
                                };
                                // parameters specific to 1:1 conversations
                                if (!isConferencing()) {
                                    extend(parameters, {
                                        to: to,
                                        // in 1:N conversations these parameters are set
                                        // on the conversation as a whole, not on the modality
                                        importance: priority() || 'Normal',
                                        subject: subject() || '',
                                        sessionContext: sessionContext
                                    });
                                }
                                // check whether the user specified the first message in
                                // the conversation: this message should be embedded into
                                // the messaging invitation
                                if (message) {
                                    var content = chooseMessageFormat(message);
                                    parameters.message = 'data:' + content.type + ',' + DataUri.encodeData(content.data);
                                    status = Property();
                                    status(Internal.Message.Status.Pending);
                                    var href = Property();
                                    // If the invitation has a message embedded, there will be the following
                                    // sequence of events from UCWA:
                                    //
                                    //      messagingInvitation started
                                    //      conversation added
                                    //      message started
                                    //      messagingInvitation completed
                                    //      message completed
                                    //
                                    // The `message completed` event must match a message in the collection of messages,
                                    // as otherwise that message will be considered to have been sent from another tab.
                                    ucwa.wait({
                                        type: 'started',
                                        target: { rel: 'message' },
                                        sender: function (link) { return rInvitation && rInvitation.link('conversation').href == link.href; }
                                    }).then(function (event) {
                                        href(event.target.href);
                                    });
                                    // add the first message in the conversation to the chat history
                                    firstMessage = addOutgoingMessage({
                                        id: message.id,
                                        href: href.asReadOnly(),
                                        text: message.text,
                                        html: message.html,
                                        timestamp: timestamp,
                                        status: status
                                    });
                                }
                                var request = context && startMessagingLink.revision >= 2 ?
                                    makeMultipartRequest(parameters, context, 2, boundary || random()) :
                                    { data: parameters };
                                // UCWA rejects attempts to send the POST request inside a batch request
                                request.nobatch = true;
                                var dfdPost = ucwa.send('POST', startMessagingLink.href, request);
                                // Wait for the "messagingInvitation started" event to get the invitation resource for the cancellation purpose
                                // even before the 'messagingInvitation completed' arrives
                                var dfdStarted = ucwa.wait({
                                    type: 'started',
                                    target: { rel: 'messagingInvitation' },
                                    resource: function (r) { return r.get('operationId', '') == operationId || r.get('threadId', '') == threadId(); }
                                }).then(function (event) {
                                    rInvitation = event.resource;
                                });
                                // wait for the "messagingInvitation completed" event that corresponds to the given conversation
                                var dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'messagingInvitation' },
                                    resource: function (r) { return r.get('operationId', '') == operationId || r.get('threadId', '') == threadId(); }
                                }).then(function (event) {
                                    if (event.status == 'Failure')
                                        throw Internal.EInvitationFailed(event.reason);
                                    rInvitation = event.resource;
                                    setResource(ucwa.get(rInvitation.link('messaging').href));
                                    // if the messaging is started in a conference, UCWA sends
                                    // the rel=messagingInvitation/rel=acceptedByParticipant resource
                                    // that does not contain the "name" property and contains invalid "uri"
                                    // (it points to the URI of the online meeting instead of the participant);
                                    // however UCWA returns the correct values if it's asked for them
                                    // explicitly - via a GET request to the rel=participant
                                    if (isConferencing() && rInvitation.hasLink('acceptedByParticipant'))
                                        ucwa.send('GET', rInvitation.link('acceptedByParticipant').href);
                                });
                                // The intent here is to:
                                //
                                //      1. Send a POST to rel=startMessaging.
                                //      2. Wait for the "messagingInvitation completed" event.
                                //      3. If the event arrives, cancel the POST and proceed.
                                //      4. If the event has not arrived, but the POST failed, stop waiting for the event and fail.
                                //      5. If the POST succeeds, continue waiting for the event.
                                //
                                // Note, that the event may arrive before a response from the POST.
                                // The Task.waitAll below lets achieve 1, 2, 4, 5 but not 3. However, #3
                                // (cancelling the POST if the event arrives first) will not make
                                // any difference, as almost always POST completes before the event arrives.
                                // The problem is what if the POST completes, but the event never arrives:
                                // the task will stuck in this state indefinitely.
                                return Task.waitAll([dfdPost, dfdStarted, dfdCompleted]);
                            }).then(function () {
                                if (status)
                                    status(Internal.Message.Status.Succeeded);
                                observeMessagingState();
                                // add participants to a meeting created by this start().
                                if (isConferencing())
                                    conversation[Internal.sInternal].inviteParticipants();
                                // UCWA has accepted the request to start messaging,
                                // so now it's time to wrap everything up: set the
                                // final state and so on.
                                state(Internal.Modality.State.Connected);
                                return firstMessage;
                            }).catch(function (error) {
                                // if something went wrong, set the final state and quit
                                state(Internal.Modality.State.Disconnected, error);
                                if (status)
                                    status(Internal.Message.Status.Failed, error);
                                if (rInvitation && rInvitation.hasLink('cancel'))
                                    ucwa.send('POST', rInvitation.link('cancel').href);
                                // rethrow the error, so that it may be processed by the caller
                                throw error;
                            }).finally(function () {
                                dfdStart = null;
                            });
                            // Name should be undefined except in the case of an anonymously signed in user
                            tm && tm.monitor(dfdStart, 'chat_start', { isGroupChat: isMeeting, isAnonJoin: !!name });
                            return dfdStart;
                        });
                        //#endregion
                        //#region sendMessage
                        /**
                         * Sends a message to all the participants the conversation.
                         *
                         * @param message - The content of the message to send.
                         *
                         *      If the this parameter is a plain string, SkypeWeb
                         *      assumes that it is in the text/plain format.
                         *      If this parameter has the form of { html : "..." }
                         *      then the message is sent as text/html.
                         *
                         *          im.sendMessage("This is a plain text message");
                         *          im.sendMessage({ text : "This is a plain text message." });
                         *          im.sendMessage({ html : "This text is <span style="color:blue">blue</span>." });
                         *
                         *      If several message formats are specified, only one of them
                         *      will be chosen. Note, that if the given html representation
                         *      of the message appears invalid, the .send method returns
                         *      a rejected promise.
                         *
                         * @param [format="text"] - Either "text" or "html".
                         *
                         *      The are two ways to specify the format of the message:
                         *
                         *          im.sendMessage("abc", "html");
                         *          im.sendMessage({ html: "abc" });
                         *
                         * @param {String} [.text] - The text/plain format of the message.
                         * @param {String} [.html] - The text/html format of the message.
                         * @param {String} [.id] - The unique id of the message.
                         *
                         *      This id will be used as the key to the `messages` collection
                         *      and thus can be used to associated the message object in the
                         *      `messages` collection with the message sent via the `send` method:
                         *
                         *          var id = Math.random();
                         *          var promise = im.sendMessage({ text: "Hi", id: id }); // it's pending
                         *          var msg = im.messages(id); // this is the pending message
                         *          assert.equal(msg.status(), "Processing");
                         *
                         *      If the given `id` conflicts with an existing message id,
                         *      no message will be sent to the server or added to the collection
                         *      and the returned promise will be rejected.
                         *
                         * @returns {Promise<Message>}
                         *
                         *      As usual, this method returns a promise that resolves
                         *      after the operation succeeds or gets rejected after
                         *      the operation fails. To track the progress of the
                         *      operation one can use the following code snippet:
                         *
                         *          im.sendMessage(message).then(
                         *              function (msg) { alert("The message has been sent.") },
                         *              function (err) { alert("The message could not be sent.") });
                         *
                         *      The returned promise has the "status" observable
                         *      property that can be used to monitor the progress:
                         *
                         *          im.sendMessage(message).status.changed(function (status) {
                         *              console.log("im.send: " + status);
                         *          });
                         *
                         *      It is noteworthy that the message gets added to the `messages`
                         *      collection immediately after the call to `send` and the status of the
                         *      added message is "Pending". Then the server sends an event
                         *      that changes the status to "Succeeded".
                         */
                        defineAsyncCommand('sendMessage', [cCreated, cNotified, cConnecting, cConnected, cDisconnected], function (message, format) {
                            if (isString(message)) {
                                message = format && format.toLowerCase() == 'html' ?
                                    { html: message } :
                                    { text: message };
                            }
                            // the status should be a property here, since it is to be updated
                            // when processing events from the server
                            var status = message[sStatus] || Property({ value: 'Pending' });
                            var href = message[Internal.sHref] || Property();
                            var id = message.id || guid();
                            // sendMessage can be used to start or accept conversation
                            if (state() != cConnected) {
                                return Task.run(function () {
                                    if (!(dfdStart || dfdAccept || state() == cNotified))
                                        return self.start({ message: message });
                                    if (messages(id))
                                        throw EAlreadyExists('message.id = ' + id);
                                    addOutgoingMessage({
                                        id: id,
                                        href: href,
                                        text: message.text,
                                        html: message.html,
                                        status: status
                                    });
                                    return (dfdStart || dfdAccept || self.accept()).then(function () {
                                        return self.sendMessage(extend(message, (_a = {
                                                id: id
                                            },
                                            _a[Internal.sHref] = href,
                                            _a[sStatus] = status,
                                            _a
                                        )));
                                        var _a;
                                    }).catch(function (err) {
                                        status(Internal.Message.Status.Failed, err);
                                        throw err;
                                    });
                                });
                            }
                            if (messages(id) && !message[Internal.sHref])
                                throw EAlreadyExists('message.id = ' + id);
                            var content = chooseMessageFormat(message);
                            // The message model should be created and added to the "messages"
                            // collection right away, but at this moment UCWA has neither replied
                            // to the POST request to rel=sendMessage, nor has it sent the
                            // "message completed" event. To handle this difficulty, the message
                            // model is given two properties with no value: the "href" and the
                            // "status" properties. The message model takes them and waits until
                            // the "href" property changes its value: this value is set after
                            // the modality receives a HTTP 201 reply to the POST request - the HTTP 201
                            // contains the Location header with the href of the rel=message resource.
                            var msgobj = messages(id) || addOutgoingMessage({
                                id: id,
                                href: href,
                                text: message.text,
                                html: message.html,
                                status: status
                            });
                            var dfd = ucwa.send('POST', rMessaging.link('sendMessage').href, {
                                headers: { 'Content-Type': content.type },
                                data: content.data,
                                nobatch: true // UCWA fails with HTTP 500 if an IM is sent inside a batch request
                            });
                            dfd.then(function (rMessage) {
                                // the message model could not receive "message completed" event
                                // and update its status, because it did not know the href of the
                                // message resource; now the href becomes known (it arrives inside
                                // the Location header)
                                href(rMessage.href);
                            }).catch(function (err) {
                                status(Internal.Message.Status.Failed, err);
                            });
                            tm && tm.monitor(dfd, 'chat_send_message', { isGroupChat: conversation.isGroupConversation() });
                            return dfd.then(function () { return msgobj; });
                        });
                        //#endregion
                        //#region stop
                        /**
                         * Terminates the ongoing messaging session.
                         */
                        defineAsyncCommand('stop', [Internal.Modality.State.Connected, Internal.Modality.State.Connecting], function () {
                            if (dfdStart) {
                                dfdStart.cancel();
                                return;
                            }
                            state(Internal.Modality.State.Disconnecting);
                            var dfdStop = ucwa.send('POST', rMessaging.link('stopMessaging').href).then(function () {
                                state(Internal.Modality.State.Disconnected);
                            }).catch(function (error) {
                                // restore the original state
                                state(Internal.Modality.State.Connected);
                                throw error;
                            });
                            tm && tm.monitor(dfdStop, 'chat_stop', { isGroupChat: conversation.isGroupConversation() });
                            return dfdStop;
                        });
                        //#endregion
                        //#region reject
                        /**
                         * Rejects the incoming messaging invitation.
                         * reason: 'Local' - reject just on this endpoint, 'Global' (default) - reject on all.
                         */
                        defineAsyncCommand('reject', [Internal.Modality.State.Notified], function (reason) {
                            if (reason === void 0) { reason = 'Global'; }
                            state(Internal.Modality.State.Disconnecting);
                            var dfdReject = Task.wait().then(function () {
                                // in UCWA an incoming meeting request tells which modalities
                                // are available in the meeting; if Messaging is available, then
                                // the chat's reject command can decline the meeting request
                                return isIncomingMeetingRequest() ?
                                    conversation.meeting.decline(reason) :
                                    ucwa.send('POST', rInvitation.link('decline').href, {
                                        data: { reason: reason }
                                    });
                            }).then(function () {
                                state(Internal.Modality.State.Disconnected);
                            }).catch(function (error) {
                                // restore the original state
                                state(Internal.Modality.State.Notified);
                                throw error;
                            });
                            tm && tm.monitor(dfdReject, 'chat_reject', { isGroupChat: conversation.isGroupConversation() });
                            return dfdReject;
                        });
                        //#endregion
                        //#region accept
                        /**
                         * To accept the messaging invitation, it does the following:
                         *
                         *      - Sends a POST request to rel=messagingInvitation.
                         *      - Waits for "messagingInvitation completed" event.
                         */
                        defineAsyncCommand('accept', [Internal.Modality.State.Notified], function (args) {
                            state(Internal.Modality.State.Connecting);
                            // in UCWA an incoming meeting request tells which modalities
                            // are available in the meeting; to accept a modality the app
                            // needs to accept the meeting request first and then send to UCWA
                            // a request to start the modality
                            dfdAccept = Task.wait(null).then(function () {
                                if (isIncomingMeetingRequest()) {
                                    return conversation.meeting.accept().then(function () {
                                        // enable the .start command
                                        state(Internal.Modality.State.Connecting, sStartingMessaging);
                                        // args.operationId is set by unit tests
                                        return self.start(args);
                                    });
                                }
                                // send a POST request to rel=messagingInvitation/accept
                                var dfdPost = ucwa.send('POST', rInvitation.link('accept').href);
                                // await "messagingInvitation completed" event
                                var dfdCompleted = ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'messagingInvitation', href: rInvitation.href }
                                }).then(function () {
                                    setResource(ucwa.get(rInvitation.link('messaging').href));
                                });
                                return Task.waitAll([dfdPost, dfdCompleted]).then(function () {
                                    observeMessagingState();
                                    // now the invitation is considered to be successfully accepted,
                                    // so set the final state, make available certain methods and so on
                                    state(Internal.Modality.State.Connected);
                                });
                            }).catch(function (error) {
                                // if something went wrong, set the final state and quit
                                state(Internal.Modality.State.Disconnected, error);
                                // rethrow the error, so that it may be catched by the caller
                                throw error;
                            }).finally(function () {
                                dfdAccept = null;
                            });
                            tm && tm.monitor(dfdAccept, 'chat_accept', { isGroupChat: conversation.isGroupConversation() });
                            return dfdAccept;
                        });
                        //#endregion
                        //#region sendIsTyping
                        /**
                         * To set IsTyping for the function is used to broadcast the user's typing status.
                         * When the function is called, the setIsTyping resource will start a short timer on
                         * the server during which the user will show up in the typingParticipants (UCWA)
                         * for this conversation (UCWA). If the  function is not called again within that time,
                         * the user will be removed from typingParticipants.
                         */
                        defineAsyncCommand('sendIsTyping', [Internal.Modality.State.Connected], function () {
                            return ucwa.send('POST', rMessaging.link('setIsTyping').href, {
                                nobatch: true
                            });
                        });
                        //#endregion
                        //#region processInvitation
                        /**
                         * Handles an incoming 1:1 messaging invitation:
                         * reads the embedded message and adds it to the
                         * collection, enables the accept/reject commands
                         * and so on. This method can be invoked multiple
                         * times in the conversation merging scenario.
                         */
                        function processInvitation() {
                            // if another tab starts a conversation, all other tabs get the
                            // outgoing invitation event (with no message link); and they
                            // do not need to process the toast message
                            if (isIncoming()) {
                                processFirstMessageInInvitation();
                                state(cNotified);
                            }
                            else {
                                // if the outgoing invitation contains a message, there will be
                                // "message completed" event shortly after this invitation event:
                                // to recognize that message, the rel=messaging needs to be known
                                if (rInvitation.hasLink('messaging'))
                                    setResource(ucwa.get(rInvitation.link('messaging').href));
                                state(cConnecting);
                            }
                            // the invitation can be cancelled by the remote party
                            // and this must be somehow reflected in the modality
                            ucwa.wait({
                                type: 'completed',
                                status: 'Failure',
                                target: { rel: 'messagingInvitation', href: rInvitation.href }
                            }).then(function (event) {
                                invitationMessage = null;
                                state(Internal.Modality.State.Disconnected, event.reason);
                            });
                            // the invitation can be accepted by the server without the client's consent
                            ucwa.wait({
                                type: 'completed',
                                status: 'Success',
                                target: { rel: 'messagingInvitation', href: rInvitation.href }
                            }).then(function (event) {
                                // if the state is still Notified and the invitation is incoming,
                                // then the "completed" event is sent because another endpoint has
                                // accepted the request as the accept() method would've changed
                                // the state to Connecting; if the invitation is outgoing because
                                // it was started on another tab, this tab must also recognize the
                                // completion of the invitation and move to the Connected state
                                if (state() == cNotified || state() == cConnecting && !isIncoming()) {
                                    setResourceAndObserveState(rInvitation.link('messaging').href);
                                    state(Internal.Modality.State.Connected, event.reason);
                                }
                            }).catch(function (error) {
                                state(Internal.Modality.State.Disconnected, error);
                            });
                        }
                        //#endregion
                        //#region processIncomingMeetingRequest
                        function processIncomingMeetingRequest() {
                            // this also enables .accept and .reject commands
                            state(Internal.Modality.State.Notified);
                            // set resource once meeting is connected and messaging
                            // becomes available, necessary for establishing IM upon
                            // UCWA auto accept
                            conversation.meeting.state.when(Internal.OnlineMeeting.State.Connected, function () {
                                var rc = getConversationResource();
                                if (!rMessaging && !dfdStart && !dfdAccept) {
                                    if (rc.hasLink('messaging'))
                                        setResourceAndObserveState(rc.link('messaging').href);
                                    else
                                        rc.updated(conversationUpdated);
                                }
                            });
                            // An incoming meeting invitation may fail before we accepted it or while 
                            // we ignored it because the invitation may be accepted on another endpoint 
                            // or UCWA auto-accept may not be enabled. 
                            conversation.meeting.state.when(Internal.OnlineMeeting.State.Disconnected, function () { return state(Internal.Modality.State.Disconnected); });
                        }
                        //#endregion
                        //#region init
                        if (isMessagingActive()) {
                            // TODO: restore the messaging history (as of Mar 2014, UCWA doesn't support this)
                            state(Internal.Modality.State.Connected);
                            setResourceAndObserveState(getConversationResource().link('messaging').href);
                        }
                        else if (rInvitation) {
                            processInvitation();
                        }
                        else if (!isIncomingMeetingRequest()) {
                            state(Internal.Modality.State.Created);
                        }
                        // in unit tests a conversation mock may not have .changed event
                        if (conversation.changed) {
                            // the same conversation can be used to handle multiple
                            // chat sessions; in this case the .changed event may be
                            // fired multiple times and each time the chat service
                            // must be able to accept the invitation.
                            //
                            // in fact this event is fired only when a meeting is either
                            // added to or removed from a conversation.
                            conversation.changed(function () {
                                if (isIncomingMeetingRequest())
                                    processIncomingMeetingRequest();
                            });
                        }
                        debug.watch('ChatService::state', state);
                        //#endregion
                        return self;
                    }
                    return ChatService;
                })();
                Internal.ChatService = ChatService;
            })(Internal = Model_19.Internal || (Model_19.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_20) {
            var Internal;
            (function (Internal) {
                'use strict';
                var bind = Web.Utils.bind;
                var debug = Web.Utils.debug;
                var assert = Web.Utils.assert;
                var foreach = Web.Utils.foreach;
                var inherit = Web.Utils.inherit;
                var isString = Web.Utils.isString;
                var isEmptyObject = Web.Utils.isEmptyObject;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Enum = Web.Utils.Enum;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var BoolProperty = Web.Utils.BoolProperty;
                var ConstProperty = Web.Utils.ConstProperty;
                var EDoesNotExist = Web.Utils.EDoesNotExist;
                var SequentialStateMachine = Web.Utils.SequentialStateMachine;
                /**
                 * A participant represents a contact in a conversation.
                 *
                 * In large online meetings there may be hundreds of participants, so to
                 * reduce the network traffic the server sends as little information as
                 * possible. UI needs to choose a small subset of participants that are
                 * currently being displayed to the user and subscribe to only these
                 * participant models:
                 *
                 *      visibleParticipants.forEach(function (participantView) {
                 *          var participant = participantView.getModel();
                 *
                 *          // now subscribe to the participant
                 *          bindProperty(participant.admit.enabled, buttonAdmit);
                 *          bindProperty(participant.reject.enabled, buttonReject);
                 *      });
                 *
                 * A subscription to a participant model tells that model to keep itself
                 * up to date by sending extra requests to the server. Too many such
                 * subscriptions may add too much network traffic.
                 *
                 * @created Sep 2013
                 * @blame antonkh
                 * @blame sosobov
                 */
                var Participant = (function () {
                    //#endregion
                    function Participant(options) {
                        var contactManager = options.contactManager;
                        var ucwa = options.ucwa;
                        var href = isString(options.href) ? ConstProperty(options.href) : options.href;
                        var title = options.name;
                        var sipuri = options.uri;
                        var isLocal = ConstProperty(!!options.isLocal);
                        var convState = options.convState || ConstProperty(null);
                        var rParticipant = href() && ucwa.get(href());
                        var State = Enum('PureHref', 'Fetched');
                        var sm = SequentialStateMachine(State.PureHref);
                        var isTyping = Property({ value: false });
                        var messagingState = Property({ value: 'Disconnected' });
                        var state = Property({ value: 'Disconnected' });
                        // should be undefined initially to avoid "changed" notification right away
                        var isJoined = BoolProperty();
                        var properties = {};
                        var methods = {};
                        var nRefs = 0; // the number of subscriptions to this model
                        var audioState = Property({ value: 'Disconnected' }), audioMuted = Property({ value: false }), audioOnHold = Property({ value: false }), isSpeaking = Property({ value: false });
                        var videoState = Property({ value: 'Disconnected' }), vsEmpty = new Internal.MediaStream, videoChannels = Collection(), videoChannel;
                        // these ids are needed for video subsciption in a conference
                        var audioSourceId = Property({ value: -1 }), videoSourceId = Property({ value: -1 }), isInMediaRoster = {};
                        var pContactHref = Property({
                            value: getContactHrefOr(void 0),
                            get: function () {
                                return pContactHref() || getAndFetchParticipantResource().then(function () {
                                    // a handler for the rel=participant:updated event
                                    // has already updated this model property, so its new value is cached
                                    return pContactHref();
                                });
                            }
                        });
                        // There are three ways to get the person model:
                        //
                        //  1. Take it from the ctor args if this is an "outgoing" participant.
                        //  2. Wrap existing /participant/contact link.
                        //  3. Create it without the link and fetch the link later.
                        //
                        // The call to inherit is important: it creates a fork of the original
                        // person object and thus perfectly reflects the state of that object
                        // and even changes if the original object changes, but allows to modify
                        // the forked object without modifying the original person object.
                        var person = inherit(options.person || contactManager.get(pContactHref() || pContactHref));
                        var proto = Model();
                        var self = inherit(proto, {
                            state: state.asReadOnly(),
                            person: person,
                            screenSharing: Model({
                                state: ConstProperty('Disconnected'),
                                isControlling: ConstProperty(false),
                                stream: Model({
                                    state: ConstProperty('Stopped'),
                                    width: ConstProperty(0),
                                    height: ConstProperty(0),
                                    source: Model({
                                        sink: Model({
                                            container: ConstProperty(null)
                                        })
                                    })
                                })
                            }),
                            chat: Model({
                                isTyping: isTyping.asReadOnly(),
                                state: messagingState.asReadOnly()
                            }),
                            audio: Model({
                                state: audioState.asReadOnly(),
                                isMuted: audioMuted.asReadOnly(),
                                isOnHold: audioOnHold.asReadOnly(),
                                isSpeaking: isSpeaking.asReadOnly()
                            }),
                            video: Model({
                                state: videoState.asReadOnly(),
                                channels: videoChannels
                            }),
                            isJoined: isJoined.asReadOnly()
                        });
                        options = null;
                        videoChannel = new Internal.VideoChannel({
                            name: isLocal() ? 'Self Channel' : 'Render Channel'
                        });
                        videoChannel.stream.setSource(vsEmpty);
                        videoChannels.add(videoChannel);
                        //#region properties
                        defineProperty('displayName');
                        defineProperty('name');
                        defineProperty('role');
                        defineProperty('uri');
                        defineProperty('sourceNetwork');
                        defineProperty('workPhoneNumber');
                        defineProperty('otherPhoneNumber');
                        defineProperty('isAnonymous', 'anonymous');
                        defineProperty('organizer');
                        //#endregion
                        //#region methods
                        defineMethod('admit');
                        defineMethod('reject');
                        defineMethod('eject');
                        defineMethod('promote');
                        defineMethod('demote');
                        //#endregion
                        //#region internal methods
                        function getContactHrefOr(value) {
                            return rParticipant && rParticipant.hasLink('contact') && rParticipant.link('contact').href || value;
                        }
                        function getParticipantResource() {
                            return href.get().then(function () {
                                attach();
                                return rParticipant;
                            });
                        }
                        function attach() {
                            // It seems strange to check here for existence of the resource,
                            // but there is a special case when this is needed. An attempt to
                            // send a message to an offline contact results in a batch of events:
                            //
                            //      messagingInvitation completed, status=Failure
                            //      localParticipant added
                            //      localParticipant deleted
                            //
                            // The added event makes the conversation object resolve the href promise,
                            // which invokes its .then(...) listeners only after the entire batch of
                            // events is processed, but by that moment the href is no longer valid.
                            // Not checking the existence of the resource makes ucwa.get fail an assert(...)
                            // which is annoying during a debugging session, as this assertion doesn't
                            // indicate any real problem.
                            if (!ucwa.exists(href()))
                                throw EDoesNotExist(href());
                            // in case there are multiple href.get() calls at the same time, 
                            // once the first call compelete and have rParticipant available,
                            // the rest calls just need to return the resouce without adding 
                            // listeners again.
                            if (rParticipant)
                                return;
                            setHiddenProperty(proto, Internal.sHref, href());
                            rParticipant = ucwa.get(href());
                            rParticipant.updated(function () {
                                isJoined(true);
                                foreach(rParticipant.properties, function (value, name) {
                                    if (name in properties)
                                        properties[name](value);
                                });
                                foreach(methods, function (method, rel) {
                                    method.enabled(rParticipant.hasLink(rel));
                                });
                                pContactHref(getContactHrefOr(pContactHref()));
                                messagingState(rParticipant.hasLink('participantMessaging') ? 'Connected' : 'Disconnected');
                                // TODO: UCWA used to drop participant modality links from the participant resource event if they were
                                // present. This was fixed in UCWA (DEVEX-1999) on 12/12/14, but it takes such a long time to reach our
                                // test servers, so I rely on participantAudio/Video events for now.
                                // audioState(rParticipant.hasLink('participantAudio') ? 'Connected' : 'Disconnected');
                                // videoState(rParticipant.hasLink('participantVideo') ? 'Connected' : 'Disconnected');
                            });
                            rParticipant.deleted(function () {
                                state('Disconnected');
                                isJoined(false);
                                for (var name_6 in methods)
                                    methods[name_6].enabled(false);
                            });
                            rParticipant.memberships.changed(function () {
                                var typing = rParticipant.memberships.contains(function (m) { return m.rel == 'typingParticipants'; });
                                isTyping(typing);
                            });
                            // In online meetings the participant resources may get invalidated
                            // by empty "participant updated" events. The client may not unconditionally
                            // fetch the actual state of the participant resource after every such an
                            // updated event to avoid generating too much traffic. So whenever the
                            // participant resource gets invalidated, the model checks whether the view
                            // is observing this participant model and if it is, it sends a GET to the server.
                            rParticipant.dirty.changed(refreshIfNeeded);
                        }
                        function getAndFetchParticipantResource() {
                            return getParticipantResource().then(function () {
                                var p = sm.advanceTo(State.Fetched);
                                p.then(); // creates a dangling promise that prevents cancellation of sm
                                return p.then();
                            });
                        }
                        function defineProperty(name, attr) {
                            attr = attr || name;
                            var p = Property({
                                get: function () {
                                    return getAndFetchParticipantResource().then(function () {
                                        // a handler for the rel=participant:updated event
                                        // has already updated this model property, so its new value is cached
                                        return p();
                                    });
                                },
                                unsubscribed: decRef,
                                subscribed: function () {
                                    incRef();
                                    // if the property is in the resource already, do not
                                    // send any requests to the server to load this property
                                    getParticipantResource().then(function () {
                                        if (!rParticipant.has(attr))
                                            sm.advanceTo(State.Fetched);
                                    });
                                }
                            });
                            properties[attr] = p;
                            self[name] = p.asReadOnly();
                        }
                        function defineMethod(name) {
                            var enabled = Property({
                                unsubscribed: decRef,
                                subscribed: function () {
                                    incRef();
                                    getParticipantResource().then(function () {
                                        if (!rParticipant.hasLink(name))
                                            sm.advanceTo(State.Fetched);
                                    });
                                },
                                get: function () {
                                    return getParticipantResource().then(function () {
                                        return rParticipant.hasLink(name) || sm.advanceTo(State.Fetched).then(function () {
                                            // the handler of rParticipant.updated has already updated this property
                                            return enabled();
                                        });
                                    });
                                }
                            });
                            methods[name] = {
                                enabled: enabled
                            };
                            self[name] = Command(bind(post, name), enabled);
                        }
                        function refreshIfNeeded() {
                            if (rParticipant.dirty() && nRefs > 0)
                                ucwa.send('GET', rParticipant.href);
                        }
                        function post(rel) {
                            return ucwa.send('POST', rParticipant.link(rel).href);
                        }
                        function incRef() {
                            nRefs++;
                        }
                        function decRef() {
                            nRefs--;
                        }
                        //#region setMediaSourceId
                        // extract media source ids from "participantAudio/Video added/updated in
                        // participant/localParticipant" events
                        // for the local participant MSIs are extracted from the event resource,
                        // for the remote one msi is in event.target.title
                        function setMediaSourceId(event) {
                            var target = event.target, resource = event.resource, rel = target.rel, scope = event['in'], scopeRel = scope && scope.rel, type = event.type, modality, res, msiNone = -1, msi;
                            res = /^participant(Audio|Video)$/.exec(rel);
                            if (!res)
                                return;
                            modality = res[1]; // Audio or Video
                            if (type == 'added' || type == 'updated') {
                                res = /^(local)?participant$/i.exec(scopeRel);
                                if (!res)
                                    return;
                                self[Internal.sInternal].rAudio = resource;
                                msi = res[1] != 'local' ? +target.title :
                                    modality == 'Audio' ?
                                        +resource.get('audioSourceId', -1) :
                                        +resource.get('videoSourceId', -1);
                                if (isNaN(msi))
                                    msi = msiNone;
                                if (modality == 'Audio')
                                    audioSourceId(msi);
                                else
                                    videoSourceId(msi);
                            }
                            else if (type == 'deleted' && modality == 'Video') {
                                // we don't reset audio source id because we need to keep the
                                // pair of audio and video MSIs intact to remove this participant
                                // from the media manager roster. But we do this while processing
                                // 'participantVideo deleted' event, so we can reset both MSIs here.
                                audioSourceId(msiNone);
                                videoSourceId(msiNone);
                            }
                        }
                        //#endregion
                        //#endregion
                        //#region AV-related stuff
                        setHiddenProperty(proto, Internal.sInternal, {
                            state: state,
                            audioState: audioState,
                            videoState: videoState,
                            isSpeaking: isSpeaking,
                            audioSourceId: audioSourceId,
                            videoSourceId: videoSourceId,
                            isInMediaRoster: isInMediaRoster,
                            setMediaSourceId: setMediaSourceId,
                            isLocal: isLocal,
                            audioOnHold: audioOnHold,
                            audioMuted: audioMuted,
                            setVideoStarted: function (val) {
                                assert(videoChannel.isStarted);
                                videoChannel.isStarted._set(val);
                            },
                            setVideoStream: function (vs) {
                                var stream = videoChannel.stream, format = stream.source.sink.format(), container = stream.source.sink.container();
                                stream.setSource(vs || vsEmpty);
                                // retain the video format and container after setting a new video stream
                                stream.source.sink.format(format);
                                stream.source.sink.container(container);
                                debug.log('Participant::SetVideoStream  stream %c' + (vs && vs._id()) + ', ' + properties.displayName(), 'color:green;font-weight:bold');
                            }
                        });
                        audioSourceId.changed(function (newState, reason, oldState) {
                            debug.log('MSI Audio(' + properties.displayName() + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        videoSourceId.changed(function (newState, reason, oldState) {
                            debug.log('MSI Video(' + properties.displayName() + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        videoState.changed(function (newState, reason, oldState) {
                            debug.log('Participant VideoState (' + properties.displayName() + ')::state: %c' + oldState + ' -> ' + newState, 'color:green;font-weight:bold', 'Reason: ', reason);
                        });
                        //#endregion
                        // the participant's name can be embedded in the link: { href: "...", title: "..." }
                        if (title)
                            properties.name(title);
                        // the participant's uri can be known even before the href is known
                        // if the participant object is created for a known uri and then
                        // resolved once the href becomes available:
                        //
                        //      participants.add("sip:johndoe@contoso.com");
                        //
                        if (sipuri)
                            properties.uri(sipuri);
                        // participant.displayName <- person.displayName || participant.name || participant.uri
                        Property.observe([person.displayName || ConstProperty(null), properties.name, properties.uri], function (cn, pn, pu) { return properties.displayName(pn || cn || pu || ''); });
                        // participant.person.displayName = participant.displayName
                        person.displayName = properties.displayName.asReadOnly();
                        // participant.id <- person.id || participant.uri
                        Property.observe([person.id || ConstProperty(null), properties.uri], function (cu, pu) { return properties.uri(pu || cu); });
                        // participant.person.id = participant.uri
                        person.id = properties.uri.asReadOnly();
                        sm.defineState(State.Fetched, function () {
                            if (isEmptyObject(rParticipant.properties))
                                return ucwa.send('GET', rParticipant.href);
                        });
                        href.changed(function () {
                            rParticipant = null;
                            setHiddenProperty(proto, Internal.sHref, href());
                            sm.reset();
                            // if the href isn't available at the moment,
                            // pull it and then attach to the resource;
                            // otherwise attach to the resource immediately
                            // to let UI see the property values without
                            // a delay introduced by a .get() call
                            if (!href())
                                href.get().then(attach);
                            else
                                try {
                                    attach();
                                }
                                catch (err) {
                                }
                        });
                        Property.observe([messagingState, audioState, videoState, convState], function (ms, as, vs, cs) {
                            // videoState check is not needed since AV state is defined by audio
                            state(cs == 'InLobby' ? 'InLobby' :
                                ms == 'Connected' || as == 'Connected' ? 'Connected' :
                                    'Disconnected');
                        });
                        return self;
                    }
                    return Participant;
                })();
                Internal.Participant = Participant;
            })(Internal = Model_20.Internal || (Model_20.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var guid = Web.Utils.guid;
                var Radix = Web.Utils.Radix;
                var Base64 = Web.Utils.Base64;
                /** this is where FILETIME starts counting from */
                var dt1601 = new Web.Date('1601-01-01T00:00:00Z');
                /** FILETIME measures time in 100 ns units */
                var dt100ns = 0.0001;
                /** in the root thread's FILETIME the last 2 bytes are dropped,
                    hence it measures time in 100 ns * 2^16 = 6.5536 ms units  */
                var dt100ns16 = dt100ns * (1 << 16);
                /** in the continued threads last 18 bits are dropped from FILETIME,
                    hence they measure time in 100 ns * 2^18 = 26.2144 ms units */
                var dt100ns18 = dt100ns16 * (1 << 2);
                /** if the time measured in dt100b18 units doesn't fit in 31 bits, 5 more bits
                    are dropped and the time is measured in 100 ns * 2^23 = 838.8608 ms units */
                var dt100ns23 = dt100ns18 * (1 << 5);
                /** tells that the time diff is measured in dt100ns23 units
                    this flag maps to the 7-th bit because MSB is written first */
                var kLowRes = 0x80000000;
                var r256 = new Radix(0x100);
                /**
                 * A thread id is a base64-encoded sequence of 22+5*N bytes.
                 * When a conversation starts, it's described by a 22 byte id.
                 * Every time it's ended and continued, a 5 byte block is added.
                 * In the binary representation the most significant byte (MSB)
                 * is written first (known as network byte order):
                 *
                 *   +0x00: 1 byte
                 *
                 *      Always set to 0x01. This must be the version of the format.
                 *
                 *   +0x01: 5 bytes
                 *
                 *      The number of 6.5536 ms intervals between the moment when
                 *      the conversation started and Jan 1, 1601. The author of the
                 *      first implementation decided to use the 8-byte FILETIME type
                 *      which tells the number of 100 ns intervals from Jan 1, 1601.
                 *      The author was smart, so he realised that 8 bytes was too much
                 *      and the resolution is too fine, so he discarded the most significant
                 *      byte and two least significant bytes and essentially ended up with a
                 *      5 byte meta-FILETIME type which tells the number of 100 ns * 2^16
                 *      intervals since Jan 1, 1601. Note, that since the MSB byte was discarded,
                 *      its value is assumed to be 0x01.
                 *
                 *  +0x06: 16 bytes
                 *
                 *      The GUID of the first conversation. See RFC 4122.
                 *
                 *  +0x16+5*N: 4 bytes
                 *
                 *      The number of either 26.2144 ms or 838.8608 ms intervals
                 *      between when this thread started and when the previous thread
                 *      started. Apparently, the author of this format noticed that the
                 *      next thread is started shortly (considering the length of epochs
                 *      that his meta-FILETIME can measure) after the previous thread and
                 *      it's possible to save a few bits by storing only the diff between
                 *      the two threads. Unfortunately, this diff didn't fit in 4 bytes,
                 *      so his optimization was pointless. So he discarded two more bits
                 *      (hence the odd 26 ms = 100 ns * 2^16 * 4 interval) and was able fit
                 *      the diff if it was less than 2 years. This worked well until someone
                 *      decided to continue a conversation 2 years later: the diff didn't fit
                 *      into the 4 bytes. So the author invented a smart trick: he said, that
                 *      if the diff fits in 31 bits, it's stored in those 4 bytes; if it doesn't
                 *      fit in the 31 bits, then 5 more bits are discarded (hence the second
                 *      odd interval: 838 ms = 100 ns * 2^16 * 4 * 2^5) and the 31-st bit is set.
                 *      This was enough to store diffs up to 50 years with a little bit less
                 *      resolution.
                 *
                 *
                 *  +0x1a+5*N: 1 byte
                 *
                 *      Most significant 4 bits (4..7) contain a random number in 0..15 range,
                 *      while the least significant 4 bits (0..3) contain some "sequence number"
                 *      which is in the author's library set to 0.
                 *
                 * This format is already implemented in existing clients and has to be implemented
                 * exactly the same way here to enable interop with those clients.
                 *
                 * @created Aug 2015
                 * @blame antonkh
                 */
                var ThreadId = (function () {
                    function ThreadId(id, uuid) {
                        if (id === void 0 || id instanceof Web.Date) {
                            this.time = id || new Web.Date;
                            this.guid = uuid || guid();
                            this.next = [];
                        }
                        else if (typeof id === 'string') {
                            var bytes = Base64.decodeBytes(id);
                            if (bytes.length < 22 || (bytes.length - 22) % 5 != 0)
                                throw SyntaxError('Invalid threadId: ' + id);
                            // bytes 1..5: time in 6.5536 ms intervals since Jan 1, 1601 (UTC)
                            var dtbs = bytes.slice(1, 6).reverse().concat([1]);
                            var dtms = r256.number(dtbs) * dt100ns16 + (+dt1601);
                            this.time = new Web.Date(Web.Math.round(dtms));
                            // bytes 6..21: GUID (RFC 4122 specifies the order of bytes)
                            this.guid = guid.parse(bytes.slice(6, 22));
                            // bytes 22..(22 + Nx5): conversation continuations
                            this.next = [];
                            for (var i = 22, base = this.time; i < bytes.length; i += 5) {
                                // bytes 0..3: the time diff with the previous thread
                                var dtbs_1 = r256.number(bytes.slice(i, i + 4).reverse());
                                var diff = dtbs_1 >= kLowRes ? (dtbs_1 - kLowRes) * dt100ns23 : dtbs_1 * dt100ns18;
                                var time = new Web.Date((+base) + diff);
                                // bits 0..3 in byte 4: the sequence number
                                var seqn = bytes[i + 4] & 0x0F;
                                // bits 4..7 in byte 4: the random number
                                var rand = bytes[i + 4] >> 4;
                                this.next.push({
                                    time: time,
                                    seqn: seqn,
                                    rand: rand
                                });
                                // the next thread starts counting from this timestamp
                                base = time;
                            }
                        }
                    }
                    ThreadId.prototype.toString = function () {
                        // the first byte must be 0x01 (version?)
                        var bytes = [1];
                        // next 5 bytes: time in 6.5536 ms intervals since Jan 1, 1601 (UTC)
                        bytes.push.apply(bytes, r256.digits(((+this.time) - (+dt1601)) / dt100ns16).slice(0, 5).reverse().map(function (b) { return b | 0; }));
                        // next 16 bytes: GUID            
                        bytes.push.apply(bytes, guid.bytes(this.guid));
                        // next Nx5 bytes: conversation continuations
                        var time = this.time;
                        for (var _i = 0, _a = this.next; _i < _a.length; _i++) {
                            var leaf = _a[_i];
                            var diff = (+leaf.time) - (+time); // in milliseconds                
                            // next 4 bytes: the diff in either 26.2144 ms intervals or 838.8608 ms intervals
                            // if the most significant bit of the 1st byte is set (the 7-th bit)
                            var dtbs = r256.digits(diff / dt100ns18 < Web.Math.pow(2, 31) ?
                                Web.Math.round(diff / dt100ns18) :
                                Web.Math.round(diff / dt100ns23) + kLowRes);
                            for (var i = 3; i >= 0; i--)
                                bytes.push(dtbs[i] || 0);
                            // next 1 byte: a random number and the sequence number
                            bytes.push(((leaf.rand & 0x0F) << 4) | (leaf.seqn & 0x0F));
                            // the i-th 5-bytes block contains a diff between .next[i].time and .next[i-1].time
                            time = leaf.time;
                        }
                        return Base64.encodeBytes(bytes);
                    };
                    ThreadId.prototype.push = function (time, rand, seqn) {
                        if (time === void 0) { time = new Web.Date; }
                        if (rand === void 0) { rand = Web.Math.random() * 16 | 0; }
                        if (seqn === void 0) { seqn = this.next.length; }
                        this.next.push({
                            time: time,
                            rand: rand,
                            seqn: seqn
                        });
                    };
                    ThreadId.prototype.pop = function () {
                        this.next.pop();
                    };
                    return ThreadId;
                })();
                Internal.ThreadId = ThreadId;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="ThreadId.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_21) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var guid = Web.Utils.guid;
                var size = Web.Utils.size;
                var check = Web.Utils.check;
                var debug = Web.Utils.debug;
                var sleep = Web.Utils.sleep;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var random = Web.Utils.random;
                var repeat = Web.Utils.repeat;
                var indexOf = Web.Utils.indexOf;
                var inherit = Web.Utils.inherit;
                var debounced = Web.Utils.debounced;
                var getOption = Web.Utils.getOption;
                var repeatAndExit = Web.Utils.repeatAndExit;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Task = Web.Utils.Task;
                var Event = Web.Utils.Event;
                var Model = Web.Utils.Model;
                var Command = Web.Utils.Command;
                var DataUri = Web.Utils.DataUri;
                var WeakMap = Web.Utils.WeakMap;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var Collection = Web.Utils.Collection;
                var NumProperty = Web.Utils.NumProperty;
                var BoolProperty = Web.Utils.BoolProperty;
                var AsyncCommand = Web.Utils.AsyncCommand;
                var ConstProperty = Web.Utils.ConstProperty;
                var ENotSupported = Web.Utils.ENotSupported;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var DisabledAsyncCommand = Web.Utils.DisabledAsyncCommand;
                var ConstCollection = Web.Utils.ConstCollection;
                var SourcedProperty = Web.Utils.SourcedProperty;
                var ComputedProperty = Web.Utils.ComputedProperty;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var EnabledAsyncCommand = Web.Utils.EnabledAsyncCommand;
                /**
                 * An ongoing conversation with one or multiple participants.
                 *
                 * The conversation model consists of
                 *
                 *  - a collection of participants
                 *  - a collection of modalities (addModality adds a new modality)
                 *  - common properties (such as "subject")
                 *
                 * To start an outgoing IM conversation start a modality with a participant:
                 *
                 *      var messaging = conversation.chatService;
                 *
                 *      messaging.start({
                 *          message: 'How are you?',
                 *          to: 'sip:user@company.com'
                 *      });
                 *
                 * Participants can be added later via the addParticipant method:
                 *
                 *      conversation.addParticipant("sip:user2@contoso.com");
                 *      conversation.addParticipant("sip:user3@contoso.com");
                 *      conversation.addParticipant("sip:user4@contoso.com");
                 *
                 * @blame chfang
                 * @blame sosobov
                 * @blame antonkh
                 */
                var Conversation = (function () {
                    //#endregion
                    function Conversation(options) {
                        // a conversation is either incoming, outgoing, a meeting with a uri or a restored converstion:
                        // 1. an incoming conversation is identified by rInvitation
                        // 2. an outgoing conversation is identified by the thread id
                        // 3. a meeting is identified by a uri  (called from getConversationByUri)
                        // 4. a restored conversation is identified by href
                        // 5. an outgoing conversation created from an outgoing invitation that arrived from another tab
                        //#region Locals
                        var ucwa = options.ucwa;
                        var gcs = options.gcs;
                        var me = options.me;
                        var href = options.href;
                        var contactManager = options.contactManager;
                        var mediaPlugin = options.mediaPlugin;
                        var devices = options.devices;
                        var sharedResources = options.sharedResources;
                        var rInvitation = options.rInvitation;
                        var guestName = options.guestName;
                        var isIncoming = false; // assigned by processInvitation
                        // threadId identifies the conversation: it's specified by the client
                        // when the client starts an outgoing conversation and it's specified
                        // by the server when the client receives an incoming invitation from
                        // the server; every time the conversation is ended and continued, the
                        // threadId is appended a 5 byte block which encodes the time when it
                        // was continued; threadId is a base64 encoded binary format
                        var threadId = Property({ value: options.threadId || new Internal.ThreadId + '' });
                        var subject = Property({ value: options.topic || '' });
                        var priority = Property({ value: options.priority || 'Normal' });
                        // the uri of the onlineMeeting (if it exists)
                        var uri = Property({ value: options.uri || null });
                        /** Created once in the ctor. */
                        var localParticipant;
                        var tm = options.tm;
                        /**
                         * Participants are indexed by random unguessable keys.
                         * They aren't indexed by participant hrefs because
                         * the same participant object can be reused by this
                         * conversation model when it is reattached to different
                         * p2p sessions.
                         */
                        var participants = options.participants || Collection({
                            get: function () { return Task.run(function () {
                                return ucwa.send('GET', rConversation.link('participants').href).then(function (rParticipants) {
                                    var tasks = rParticipants.links('participant').map(function (r) {
                                        return ucwa.send('GET', r.href).catch();
                                    });
                                    return Task.waitAll(tasks).then(restoreParticipants);
                                });
                            }).catch(); }
                        });
                        var isConferenceByDefault = getOption(options, 'isConference', true);
                        var isConference = BoolProperty(rInvitation ? rInvitation.rel == 'onlineMeetingInvitation' : isConferenceByDefault);
                        options = null; // no need to use options beyond this point
                        var state = Property({ value: Conversation.State.Created });
                        var modalities = Collection();
                        var changed = new Event({
                            added: function (listener) { return listener(); }
                        });
                        var rConversation; // rel=conversation
                        var isChatActive = Property({ value: false });
                        var isAudioActive = Property({ value: false });
                        var isVideoActive = Property({ value: false });
                        var isSharingActive = Property({ value: false });
                        var isCollabActive = Property({ value: false });
                        var canAddParticipant = Property({ value: false });
                        var canAcknowledge = Property({ value: false });
                        var isConferencing = state.equalsAny(Conversation.State.Conferenced, Conversation.State.Conferencing);
                        var activityItems = Collection();
                        /** Tells where the next getMoreActivityItems call
                            should continue reading transcripts from. */
                        var nextTranscript = {
                            /** /conversationLog[i] */
                            logIndex: 0,
                            /** /conversationLogTranscript[i] */
                            transcriptIndex: 0
                        };
                        var chat;
                        var proto = Model();
                        // it's hidden because it's used internally and because adding a new property
                        // in the conversation object will require updates in numerous unit tests
                        setHiddenProperty(proto, 'threadId', threadId.asReadOnly());
                        var self = inherit(proto, {
                            /** Once set, the id cannot be changed: that's
                                the contract between the SDK and the UI. */
                            id: ConstProperty(guid()),
                            /** Deprecated. */
                            changed: changed.observer,
                            state: state.asReadOnly(),
                            isJoiningEnabled: ConstProperty(true),
                            topic: subject.fork(Command(function (x) { return x; }, state.equals('Created'))),
                            priority: priority.asReadOnly(),
                            uri: uri.asReadOnly(),
                            context: getInvitationContext(),
                            modalities: modalities.asReadOnly(),
                            activeModalities: Model({
                                chat: isChatActive.asReadOnly(),
                                audio: isAudioActive.asReadOnly(),
                                video: isVideoActive.asReadOnly(),
                                screenSharing: isSharingActive.asReadOnly(),
                                dataCollaboration: isCollabActive.asReadOnly()
                            }),
                            isGroupConversation: isConference.asReadOnly(),
                            acknowledge: AsyncCommand(debounced(acknowledge), canAcknowledge),
                            addModality: addModality,
                            addMeeting: addMeeting,
                            addParticipant: AsyncCommand(inviteParticipantByUri, canAddParticipant),
                            // .leave must be disabled when state = Diconnected:
                            // it's a requirement from the UI team
                            leave: AsyncCommand(stop, state.map(function (x) { return x != 'Created' && x != 'Disconnected'; })),
                            createParticipant: EnabledCommand(createParticipantFromPersonOrUri),
                            participantsCount: participants.size,
                            participants: participants.fork({
                                add: Command(addParticipant, state.equalsAny('Created', 'Connected', 'Conferenced')),
                                remove: AsyncCommand(removeParticipant, participants.reduce(function (f, p) { return f ||
                                    p.eject && p.eject.enabled() || p.state && p.state() == 'Disconnected'; }, false))
                            }),
                            avatarUrlSmall: ConstProperty(null),
                            avatarUrlLarge: ConstProperty(null),
                            createInvitation: function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i - 0] = arguments[_i];
                                }
                                return void 0;
                            },
                            pendingInvitations: Collection.empty,
                            spawnedConversation: ConstProperty(null)
                        });
                        /** participantHrefs.get(p) is the href property given to p */
                        var participantHrefs = new WeakMap();
                        /** initial number of remote participants upon joining the conference (local included)
                            as reported by "conversation added/updated" events */
                        var participantCountOnJoin = NumProperty();
                        /** number of participants joined the conference (local included) as reported by
                            "participant added" events */
                        var participantCount = NumProperty(0);
                        /** ignoring participant added/deleted events for some time after joining the conference
                            to avoid multiple notifications for all participants who are already in the conference */
                        var pactivityTimeoutExpired = BoolProperty(false);
                        /** allow "participant joined/left" activity items */
                        var allowPActivityItems = ComputedProperty([isConferencing, participantCountOnJoin, participantCount, pactivityTimeoutExpired], function (isConf, pcJoin, pc, expired) {
                            return isConf && (pc > pcJoin || expired);
                        });
                        /** The task is resolved by changing corresponding "href" proeprty. */
                        var dfdLocalParticipantHref = new Task();
                        /** Setting the value of this property immediately resolves the
                            corresponding task which the Participant model is waiting on. */
                        var pLocalParticipantHref = Property({
                            get: function () { return pLocalParticipantHref() || dfdLocalParticipantHref.promise; }
                        });
                        pLocalParticipantHref.changed(function (href) {
                            if (href && dfdLocalParticipantHref) {
                                dfdLocalParticipantHref.resolve(href);
                                dfdLocalParticipantHref = null;
                            }
                        });
                        var avm;
                        //#endregion
                        //#region participantActivityItems
                        /** add a participant activity item */
                        function addParticipantActivityItem(itemType, participant, error, key, reason) {
                            var person = participant.person;
                            var item = new Internal.ActivityItem(itemType, key, {
                                author: person,
                                persons: ConstCollection([person]),
                                context: ConstProperty(void 0, ENotSupported()),
                                status: ConstProperty(error ? 'Failed' : 'Succeeded', reason || error)
                            });
                            item.isRead(true);
                            activityItems.add(item);
                        }
                        /** sets up conditional creation of participant activity items */
                        function initParticipantActivityItems(localParticipant) {
                            state.when('Conferenced', function () {
                                addParticipantActivityItem('ParticipantJoined', localParticipant);
                                state.once('Disconnected', function (reason) {
                                    addParticipantActivityItem('ParticipantLeft', localParticipant, null, null, reason);
                                });
                            });
                            participants.added(function (p) {
                                p.isJoined.changed(function (val) {
                                    if (allowPActivityItems())
                                        addParticipantActivityItem(val ? 'ParticipantJoined' : 'ParticipantLeft', p);
                                });
                            });
                        }
                        //#endregion
                        //#region calling activity items
                        /**
                         * CallMissed = a transition from Connecting to Disconnected that bypasses Connected.
                         * CallStarted = a transition to Connected
                         * CallEnded = a transition to Disconnected
                         */
                        function initCallingActivityItems(state) {
                            state.when(function (x) { return x == (isIncoming ? 'Notified' : 'Connecting'); }, function () {
                                var dir = isIncoming ? 'Incoming' : 'Outgoing';
                                var sub = isIncoming && state.once('Disconnected', function () {
                                    var ended = new Internal.ActivityItem('CallMissed', null, {
                                        direction: ConstProperty(dir),
                                        duration: ConstProperty(null)
                                    });
                                    ended.isRead(true);
                                    activityItems.add(ended);
                                });
                                state.once('Connected', function () {
                                    sub && sub.dispose();
                                    var started = new Internal.ActivityItem('CallStarted', null, {
                                        direction: ConstProperty(dir),
                                        duration: ConstProperty(null)
                                    });
                                    started.isRead(true);
                                    activityItems.add(started);
                                    state.once('Disconnected', function () {
                                        var ended = new Internal.ActivityItem('CallEnded', null, {
                                            direction: ConstProperty(dir),
                                            duration: ConstProperty((new Web.Date - started.timestamp()) / 1000) // seconds
                                        });
                                        ended.isRead(true);
                                        activityItems.add(ended);
                                    });
                                });
                            });
                        }
                        //#endregion
                        //#region createAvatarUrl
                        /** sets up conversation avatar url depending on the conversation type */
                        function createAvatarUrl() {
                            var avatarSub;
                            var avatarUrl = SourcedProperty();
                            // Note that isConference may change its value exactly once: 
                            // when a 1:1 conversation is escalated to a conference (false -> true)
                            isConference.when(false, function () {
                                // in 1:1 conversations we use the remote participant's photo
                                avatarSub = participants.size.when(1, function () { return avatarUrl.setSource(participants(0).person.avatarUrl); });
                            });
                            isConference.when(true, function () {
                                // UCWA does not have a conference picture concept, nothing to set
                                avatarUrl.setSource(ConstProperty(null));
                                // need to dispose to avoid avatar change if only one remote participant
                                // is left in a conversation escalated to a conference from a 1:1 conv.
                                if (avatarSub) {
                                    avatarSub.dispose();
                                    avatarSub = null;
                                }
                            });
                            return avatarUrl.asReadOnly();
                        }
                        //#endregion
                        //#region processInvitation
                        /** this function may be called first time when the conversation model is
                            being initialized by init(), or when this conversation is disconnected
                            and then receives a new invitation event */
                        function processInvitation(r) {
                            rInvitation = r;
                            isIncoming = rInvitation.get('direction') == 'Incoming';
                            setResource(ucwa.get(rInvitation.link('conversation').href));
                            threadId.set(rInvitation.get('threadId') + '');
                            // in outgoing invitation /from points to the local participant
                            // which must not be added to the .participants collection
                            if (rInvitation.hasLink('from') && isIncoming) {
                                var senderHref = rInvitation.link('from').href; // rel=participant
                                var senderName = ucwa.get(senderHref).get('name', void 0);
                                resolveParticipant(senderHref, senderName);
                            }
                            else if (rInvitation.hasLink('to') && !isIncoming) {
                                var receiverHref = rInvitation.link('to').href; // rel=person
                                var matchingParticipants = participants.filter(function (p) { return p.person[Internal.sHref] == receiverHref; });
                                if (matchingParticipants.size() == 0) {
                                    var person = contactManager.get(receiverHref);
                                    var participant = createParticipantFromPersonOrUri(person);
                                    addParticipant(participant);
                                }
                            }
                            state(isIncoming ? Conversation.State.Incoming : Conversation.State.Connecting);
                            if (rInvitation.rel == 'onlineMeetingInvitation') {
                                self.meeting = new Internal.OnlineMeeting({
                                    ucwa: ucwa,
                                    rInvitation: rInvitation,
                                    from: isIncoming ? participants(0) : localParticipant,
                                    conversation: self,
                                    contactManager: contactManager
                                });
                                changed.fire();
                            }
                        }
                        //#endregion
                        /** It's invoked once and essentially plays the role of the constructor. */
                        function init() {
                            setHiddenProperty(proto, Internal.sHref, href);
                            setHiddenProperty(proto, Internal.sInternal, {
                                inviteParticipants: inviteParticipants,
                                processInvitation: processInvitation
                            });
                            if (href) {
                                setResource(ucwa.get(href));
                                threadId.set(rConversation.get('threadId', threadId()));
                                restoreParticipants();
                                restoreMeeting();
                            }
                            localParticipant = createParticipant({
                                href: pLocalParticipantHref.asReadOnly(),
                                person: me,
                                convState: state,
                                isLocal: true
                            });
                            self.selfParticipant = localParticipant;
                            if (rInvitation) {
                                processInvitation(rInvitation);
                            }
                            else if (uri()) {
                                // called from getConversationByUri to create
                                // a meeting based on the meeting's uri
                                self.meeting = new Internal.OnlineMeeting({
                                    ucwa: ucwa,
                                    threadId: threadId(),
                                    subject: subject(),
                                    priority: priority(),
                                    conversation: self,
                                    contactManager: contactManager
                                });
                            }
                            if (self.meeting)
                                self.meeting.uri.changed(uri);
                            chat = new Internal.ChatService({
                                ucwa: ucwa,
                                guestName: guestName,
                                conversation: self,
                                rInvitation: rInvitation && rInvitation.rel == 'messagingInvitation' && rInvitation,
                                tm: tm
                            });
                            self.chatService = chat;
                            // the Created state is for internal use only, map it to Disconnected for external users
                            localParticipant.chat.state = chat.state.map(function (v) { return v == 'Created' ? 'Disconnected' : v; });
                            var unreadCount = NumProperty(0);
                            var lastModified = Property({ value: new Web.Date });
                            var keyPrefix = random();
                            var makeKey = function (key) { return keyPrefix + ':' + key; };
                            chat.messages.added(function (message, key) { return addMessageActivityItem(message, makeKey(key)); });
                            chat.messages.removed(function (message, key) { return activityItems.remove(makeKey(key)); });
                            // it's assumed that activity items are never removed
                            activityItems.added(function (item) {
                                // it's assumed that if an item gets read, it cannot be un-read
                                if (!item.isRead()) {
                                    unreadCount.inc();
                                    item.isRead.once(true, function () { return unreadCount.dec(); });
                                }
                                if (item.timestamp() > lastModified())
                                    lastModified(item.timestamp());
                            });
                            // at the moment this feature is incomplete
                            // and hence is enabled only for unit tests
                            var isConversationHistoryEnabled = Web.isUnitTested;
                            self.historyService = Model({
                                activityItems: activityItems.sort(function (lhs, rhs) { return lhs.timestamp() < rhs.timestamp(); }),
                                unreadActivityItemsCount: unreadCount.asReadOnly(),
                                isHistoryDisclosed: ConstProperty(false),
                                getMoreActivityItems: AsyncCommand(fetchLogs, ComputedProperty([isConference, participants.size], function (c, n) { return !c && n == 1 && isConversationHistoryEnabled; })),
                                markAllAsRead: EnabledAsyncCommand(function () { return activityItems.each(function (item) { return item.isRead(true); }); }),
                                removeAll: DisabledAsyncCommand()
                            });
                            // this method was needed in one project that wanted insert custom activity items
                            // and have a custom way of displaying them in the UI; the SDK doesn't need this method
                            setHiddenProperty(self.historyService, 'addCustomActivityItem', function (type, props) {
                                var item = new Internal.ActivityItem(type, null, props);
                                activityItems.add(item);
                            });
                            self.lastModificationTimestamp = lastModified.asReadOnly();
                            avm = new Internal.AudioVideoModality({
                                ucwa: ucwa,
                                guestName: guestName,
                                mediaPlugin: mediaPlugin,
                                devices: devices,
                                participants: participants.asReadOnly(),
                                selfParticipant: localParticipant,
                                conversation: self,
                                rConversation: rConversation,
                                me: me,
                                rInvitation: rInvitation,
                                tm: tm
                            });
                            var connectedAt = Property({ value: null });
                            avm.state.when(Internal.Modality.State.Connected, function () {
                                connectedAt(new Web.Date);
                                debug.log('%c Call connected ' + connectedAt(), 'color:green;font-weight:bold');
                            });
                            self.audioService = Model({
                                callConnected: connectedAt.asReadOnly(),
                                state: avm.audioState,
                                start: Command(avm.start, ComputedProperty([me.capabilities.audio, avm.audioState], function (enabled, state) { return enabled && state == Internal.Modality.State.Disconnected; })),
                                stop: Command(avm.stop, avm.audioState.equalsAny(Internal.Modality.State.Connected, Internal.Modality.State.Connecting)),
                                accept: Command(avm.accept, ComputedProperty([me.capabilities.audio, avm.audioState], function (enabled, state) { return enabled && state == Internal.Modality.State.Notified; })),
                                reject: Command(avm.decline, avm.audioState.equals(Internal.Modality.State.Notified)),
                                sendDtmf: avm.sendDtmf
                            });
                            self.videoService = Model({
                                state: avm.videoState,
                                start: AsyncCommand(function (options) { return avm.start(extend(options, { video: true })); }, ComputedProperty([me.capabilities.video, avm.audioState, avm.videoState], function (enabled, audio, video) { return enabled &&
                                    video == Internal.Modality.State.Disconnected &&
                                    (audio == Internal.Modality.State.Connected || audio == Internal.Modality.State.Disconnected); })),
                                stop: AsyncCommand(function () { return avm.stop('video'); }, avm.videoState.equalsAny(Internal.Modality.State.Connected, Internal.Modality.State.Connecting)),
                                accept: AsyncCommand(function (options) { return avm.accept(extend(options, { video: true })); }, ComputedProperty([me.capabilities.video, avm.videoState], function (enabled, state) {
                                    return enabled && state == Internal.Modality.State.Notified;
                                })),
                                reject: Command(avm.decline, avm.videoState.equals(Internal.Modality.State.Notified)),
                                maxVideos: ConstProperty(null),
                                activeSpeaker: void 0
                            });
                            self.screenSharingService = Model({
                                sharer: ConstProperty(null),
                                sharedResources: Collection.empty,
                                controller: ConstProperty(null),
                                controlRequesters: Collection.empty,
                                requestControl: DisabledAsyncCommand(),
                                releaseControl: DisabledAsyncCommand(),
                                acceptControlRequest: DisabledAsyncCommand(),
                                rejectControlRequest: DisabledAsyncCommand(),
                                start: DisabledAsyncCommand(),
                                stop: DisabledAsyncCommand(),
                                accept: DisabledAsyncCommand(),
                                reject: DisabledAsyncCommand()
                            });
                            self.fileTransferService = Model({
                                files: Collection.empty,
                                send: DisabledAsyncCommand()
                            });
                            // override properties of the self participant audio excluding isSpeaking
                            extend(localParticipant.audio, {
                                isMuted: avm.muted,
                                isOnHold: avm.onHold
                            });
                            // TODO: use SourcedModel to change the creator properly when resuming the conversation
                            self.creator = self.meeting ? self.meeting.creator :
                                isIncoming ? participants(0).person :
                                    rInvitation ? localParticipant.person :
                                        href ? restoreCreator() :
                                            localParticipant.person; // P2P outgoing conversation
                            state.changed(updateIsGroupConversation);
                            uri.changed(updateIsGroupConversation);
                            participants.size.changed(updateIsGroupConversation);
                            initParticipantActivityItems(localParticipant);
                            initCallingActivityItems(localParticipant.audio.state);
                            self.avatarUrl = createAvatarUrl();
                        }
                        //#region Internal Methods
                        //#region addMessageActivityItem
                        /** Internally the activity items aren't sorted.
                            However the interface exposes a list sorted by the timestamp. */
                        function addMessageActivityItem(message, key) {
                            var item = new Internal.ActivityItem('TextMessage', key, message);
                            if (message.direction() == 'Outgoing')
                                item.isRead(true);
                            activityItems.add(item, key);
                        }
                        //#endregion
                        //#region fetchLogs
                        /**
                         * Fetches the specified number of archived activities (which are usually just messages)
                         * related to this conversation. At the moment this works only for 1:1 conversations.
                         *
                         * @created Jul 2015
                         * @blame antonkh
                         */
                        function fetchLogs(count) {
                            function Skipped(message) {
                                this.message = message;
                            }
                            return gcs.conversationLogs.conversationLog.get().then(function (logs) {
                                return repeatAndExit(function (exit) {
                                    var log = logs[nextTranscript.logIndex];
                                    var recipients = log.conversationLogRecipient;
                                    var subject = log.subject;
                                    return Task.waitAll([subject.get(), recipients.get()]).then(function () {
                                        if (recipients().length != 1)
                                            throw new Skipped('conference');
                                        return recipients(0).sipUri.get();
                                    }).then(function (sip) {
                                        if (sip != participants(0).uri())
                                            throw new Skipped('different participant');
                                        return log.conversationLogTranscripts.conversationLogTranscript.get();
                                    }).then(function (transcripts) {
                                        return repeat(function () {
                                            var transcript = transcripts[nextTranscript.transcriptIndex++];
                                            if (!transcript)
                                                throw new Skipped('no more transcripts');
                                            var messageTranscript = transcript.messageTranscript;
                                            var html = messageTranscript.htmlMessage.href;
                                            var text = messageTranscript.plainMessage.href;
                                            var time = transcript.timeStamp;
                                            var href = transcript.contact.href;
                                            var dir = log.direction;
                                            var message = new Internal.Message({
                                                ucwa: ucwa,
                                                href: dir() == 'Incoming' ? '' : null,
                                                sender: { person: contactManager.get(href) },
                                                time: time(),
                                                text: text(),
                                                html: html(),
                                                direction: dir()
                                            });
                                            addMessageActivityItem(message);
                                            count--;
                                            if (count < 1)
                                                exit();
                                        });
                                    }).catch(function (err) {
                                        if (err instanceof Skipped) {
                                            nextTranscript.logIndex++;
                                            nextTranscript.transcriptIndex = 0;
                                        }
                                        else {
                                            throw err;
                                        }
                                    });
                                });
                            });
                        }
                        //#endregion
                        function updateIsGroupConversation() {
                            if (!!uri()) {
                                isConference(true);
                            }
                            else {
                                switch (state()) {
                                    case Conversation.State.Created:
                                        // we defer to the initial status even when there are no remote participants to
                                        // 1) avoid property change after a participant is added to a conversation
                                        // created with {isConference: false) parameter
                                        // 2) to support starting a conv. service with {to: sipUri} parameter 
                                        isConference(participants.size() > 1 || isConferenceByDefault);
                                        break;
                                    case Conversation.State.Connecting:
                                    case Conversation.State.Connected:
                                        isConference(false);
                                        break;
                                    case Conversation.State.Conferencing:
                                    case Conversation.State.Conferenced:
                                        isConference(true);
                                        break;
                                }
                            }
                        }
                        //#region createParticipant
                        /** this is the only function that should be called internally to
                            create participants (both self and remote) */
                        function createParticipant(options) {
                            extend(options, {
                                ucwa: ucwa,
                                contactManager: contactManager
                            });
                            var p = new Internal.Participant(options), selfEnabled = Property(), remoteEnabled = Property();
                            // show or remove participant video
                            function participantVideo(val) {
                                var dfd = val ?
                                    avm.showParticipantVideo(p) :
                                    avm.removeParticipantVideo(p);
                                return dfd.then(function () {
                                    return val;
                                });
                            }
                            // show or remove self participant video
                            function selfVideo(val) {
                                switch (p.video.state()) {
                                    case Internal.Modality.State.Disconnected:
                                    case Internal.Modality.State.Notified:
                                        return val;
                                    case Internal.Modality.State.Connected:
                                        return participantVideo(val);
                                    default:
                                        throw Exception('InvalidState');
                                }
                            }
                            if (options.isLocal) {
                                // TODO: convert to p.video.state.map(...)
                                p.video.state.changed(function (v) {
                                    selfEnabled(v != Internal.Modality.State.Connecting);
                                });
                                p.video.channels(0).isStarted = Property({
                                    set: Command(selfVideo, selfEnabled)
                                });
                            }
                            else {
                                // videoChanel.isStarted.set should be enabled for a remote participant only in a conference,
                                // so we need to observe both participant video state and conversation state changes.
                                p.video.state.changed(function (v) {
                                    remoteEnabled(isConferencing() && v == Internal.Modality.State.Connected);
                                });
                                isConferencing.changed(function (v) {
                                    remoteEnabled(v && p.video.state() == Internal.Modality.State.Connected);
                                });
                                p.video.channels(0).isStarted = Property({
                                    set: Command(participantVideo, remoteEnabled)
                                });
                            }
                            return p;
                        }
                        //#endregion
                        function getInvitationContext() {
                            var href = rInvitation && rInvitation.relatedHref('customContent');
                            var data, context, dataUri = DataUri(href || 'data:,');
                            try {
                                data = JSON.parse(dataUri.data);
                            }
                            catch (_) {
                                data = dataUri.data;
                            }
                            context = ConstProperty(data);
                            context.type = ConstProperty(dataUri.mime);
                            return context;
                        }
                        function restoreParticipants() {
                            var rParticipants = ucwa.find(function (r) {
                                return r.rel == 'participant' &&
                                    r.hasLink('conversation') &&
                                    r.link('conversation').href == rConversation.href;
                            });
                            rParticipants.forEach(function (rParticipant) {
                                if (rParticipant.get('local', false))
                                    pLocalParticipantHref(rParticipant.href);
                                else
                                    resolveParticipant(rParticipant.href, rParticipant.get('name', void 0));
                            });
                        }
                        function restoreMeeting() {
                            if (rConversation.hasLink('onlineMeeting')) {
                                self.meeting = new Internal.OnlineMeeting({
                                    ucwa: ucwa,
                                    rMeeting: ucwa.get(rConversation.link('onlineMeeting').href),
                                    conversation: self,
                                    contactManager: contactManager
                                });
                            }
                        }
                        function restoreCreator() {
                            var rInvitations = ucwa.find(function (r) {
                                return /Invitation$/.test(r.rel) &&
                                    r.hasLink('conversation') &&
                                    r.get('direction') == 'Incoming' &&
                                    r.link('conversation').href == rConversation.href;
                            });
                            return rInvitations.length > 0 ?
                                participants(0).person :
                                self.selfParticipant.person;
                        }
                        /** handles conversation resource updates and resource deletion */
                        function setResource(r) {
                            href = r.href;
                            rConversation = r;
                            setHiddenProperty(self, Internal.sHref, href);
                            rConversation.deleted(function (reason) {
                                self[Internal.sHref] = null;
                                href = null;
                                rConversation = null;
                                rInvitation = null;
                                // next time if the conversation object is used to continue the conversation,
                                // the threadId for that continued conversation must be derived in a special
                                // way; however this doesn't mean that the derived threadId will be used: if
                                // shortly after the conversation is ended, an incoming invitation from the
                                // same person or to the same conference arrives, the incoming threadId will
                                // replace this derived id
                                try {
                                    var t = new Internal.ThreadId(threadId());
                                    t.push(); // derive a threadId for the next conversation
                                    threadId.set(t + '');
                                }
                                catch (e) {
                                }
                                // the participant href contains the conversation id, so
                                // it becomes invalid once the conversation is gone
                                for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                    var p = _a[_i];
                                    participantHrefs.get(p).set(null);
                                }
                                // when leaving a meeting we remove all remote participants
                                if (isConference())
                                    participants.empty();
                                // setting to undefined initially before we get the real count from ucwa
                                // would still fail the comparison with this value
                                participantCountOnJoin(void 0);
                                participantCount(0);
                                delete self.meeting;
                                changed.fire();
                                state(Conversation.State.Disconnected, reason);
                            });
                            rConversation.updated(function () {
                                function update(attr, prop, excluded) {
                                    // if the property isn't available in rel=conversation,
                                    // do not change the corresponding model property
                                    if (rConversation.has(attr) && !(excluded && rConversation.get(attr) == excluded))
                                        prop(disableHtmlInText('' + rConversation.get(attr)));
                                }
                                update('state', state, 'Disconnected');
                                update('importance', priority);
                                update('subject', subject);
                            });
                            rConversation.updated(function () {
                                var modalities = rConversation.get('activeModalities', []);
                                isChatActive(indexOf(modalities, 'Messaging') >= 0);
                                isAudioActive(indexOf(modalities, 'Audio') >= 0);
                                isVideoActive(indexOf(modalities, 'Video') >= 0);
                                isSharingActive(indexOf(modalities, 'ApplicationSharing') >= 0);
                                isCollabActive(indexOf(modalities, 'DataCollaboration') >= 0);
                            });
                            rConversation.updated(function () {
                                canAddParticipant(rConversation.hasLink('addParticipant'));
                                canAcknowledge(rConversation.hasLink('userAcknowledged'));
                            });
                            // initial participant count in meetings
                            var subPCountOnJoin = rConversation.updated(function () {
                                if (rConversation.has('participantCount'))
                                    participantCountOnJoin(+rConversation.get('participantCount'));
                            });
                            // if we start a new adhoc meeting and immediately invite participants 
                            // (by creating a new conversation, adding participants and starting 
                            // any conversation service), rConversation.participantCount will take the
                            // initial count of 1 for local participant and then will be updated when
                            // some of the added participants join. We need to keep the initial value 
                            // and ignore subsequent updates. The check for 'adhoc' uri works because
                            // uri is updated by "onlineMeetingInvitation added" event which always
                            // preceeds "conversation added". Note that later "onlineMeetingInvitation
                            // updated" event will change uri to the real meeting uri.
                            participantCountOnJoin.once(function (v) { return v > 0 && (uri() == 'adhoc' || !uri()); }, function () { return subPCountOnJoin.dispose(); });
                            pactivityTimeoutExpired(false);
                            sleep(10).then(function () { return pactivityTimeoutExpired(true); });
                        }
                        // participant-related events
                        ucwa.event(function (event) {
                            var sender = event.sender;
                            var target = event.target;
                            var context = event['in'];
                            if (sender.href == href && /^(localParticipant|participant)$/.test(target.rel)) {
                                // it's necessary to check the presence of the "in" property, because
                                // if in.rel = "typingParticipants" then the event means that a
                                // participant started or stopped typing, but is still in the
                                // conversation
                                if (!context) {
                                    if (event.type == 'deleted') {
                                        // in a 1:1 conversation the remote participant must remain in the collection 
                                        // but switch to the "disconnected" state which is implemented in the 
                                        // Participant model; participants who left the meeting are deleted
                                        if (isConferencing() && target.rel == 'participant') {
                                            // no need to null the entry in participantHrefs weak map because the value
                                            // (href) in that map is contained in the key (participant), so deleting the 
                                            // participant would delete the map entry. If we do it anyway p[sHref]
                                            // will be nulled and we won't be able to find participant for removal below.
                                            var n = participants.removeAll(function (p) { return p[Internal.sHref] == target.href; });
                                            if (n == 0) {
                                            }
                                        }
                                    }
                                    else if (event.type == 'added') {
                                        participantCount.inc();
                                        if (target.rel == 'localParticipant')
                                            pLocalParticipantHref(target.href);
                                        else
                                            resolveParticipant(target.href, target.title);
                                    }
                                }
                                else if (event.type == 'added' && context.rel == 'lobby') {
                                    // if a participant in lobby event is added, the participant must be in this 
                                    // conversation already, and its state should be updated to 'InLobby'.
                                    var participant = getParticipant(target.href);
                                    participant[Internal.sInternal].state('InLobby');
                                }
                            }
                        });
                        // onlineMeeting
                        ucwa.event(function (event) {
                            var target = event.target;
                            var context = event['in'] || {};
                            // if in a peer to peer conversation the remote participant adds
                            // another participant to escalate the conversation to the multiparty
                            // mode, this participant receives a bunch of events with two among them:
                            //
                            //      conversation updated - rel=conversation.state becomes "Conferenced"
                            //      onlineMeeting added in conversation - rel=conversation/rel=onlineMeeting appears
                            //
                            if (event.type == 'added' && target.rel == 'onlineMeeting' && context.href == href) {
                                // if self.meeting is already there, then the conversation model
                                // was created to react to an onlineMeetingInvitation event, so
                                // no need to recreate it
                                if (!self.meeting) {
                                    // TODO: use a sourced model here instead of replacing the member
                                    self.meeting = new Internal.OnlineMeeting({
                                        ucwa: ucwa,
                                        rMeeting: event.resource,
                                        conversation: self,
                                        contactManager: contactManager
                                    });
                                    // TODO: use a sourced model here instead of replacing the member
                                    self.creator = self.meeting.creator;
                                    self.meeting.uri.changed(uri);
                                    changed.fire();
                                }
                            }
                        });
                        ucwa.event(function (event) {
                            // after an onlineMeetingInvitation is completed, the conversation
                            // resource is not updated promptly (possibly due to a UCWA bug).
                            // This would cause the 'userAcknowledged' link not to appear in
                            // the auto-accept scenario; so we need to fetch the conversation
                            // resource explicitly in order to correctly enable/disable the
                            // acknowledge command
                            if (event.type == 'completed' && event.target.rel == 'onlineMeetingInvitation' &&
                                event.status == 'Success' && event.resource.link('conversation').href == href)
                                ucwa.send('GET', href);
                        });
                        // extracts rel=conversation href
                        ucwa.event(function (event) {
                            var resource = event.resource;
                            // for outgoing conversations the client specifies threadId
                            // and the server sends the href of the created "conversation"
                            // resource
                            if (resource && resource.rel == 'conversation' && resource.get('threadId', '') == threadId() && !rConversation)
                                setResource(resource);
                        });
                        // merges incoming invitations with the same threadId
                        ucwa.event(function (event) {
                            var resource = event.resource;
                            if (!href && event.type == 'started' && resource.get('threadId', '') == threadId() &&
                                /Invitation$/.test(resource.rel) && resource.get('direction', '') == 'Incoming')
                                processInvitation(resource);
                        });
                        // participantAudio/participantVideo
                        ucwa.event(function (event) {
                            var sender = event.sender;
                            var target = event.target;
                            var context = event['in'] || {};
                            // in meetings we receive the participantAudio/Video events even if we don't have AudioVideo modality (we
                            // hooked up messaging only). After we add A/V we won't get these events again. Moreover, even if we join
                            // a meeting with A/V right away, 'participantAudio/Video added' events for participants that are already
                            // in the meeting are fired before we even issued an AV invitation. So we need to track MSIs for such
                            // participants here.
                            if (sender.href == href && isConferencing() && context.rel == 'participant' && /^participant(Audio|Video)$/.test(target.rel)) {
                                var participant = getParticipant(context.href);
                                if (participant) {
                                    // if video is on, a deleted event should be handled by AVModality; otherwise AVModality
                                    // won't be able to take this participant out of the media roster because by the 
                                    // time it has a chance to process this event the participant media source ids 
                                    // will have have already been reset by this handler 
                                    if (event.type == 'added' || event.type == 'updated' || !isVideoActive())
                                        participant[Internal.sInternal].setMediaSourceId(event);
                                    var modalityState = event.type == 'deleted' ?
                                        Internal.Modality.State.Disconnected :
                                        Internal.Modality.State.Connected;
                                    if (target.rel == 'participantAudio')
                                        participant[Internal.sInternal].audioState(modalityState);
                                    else
                                        participant[Internal.sInternal].videoState(modalityState);
                                }
                            }
                        });
                        function getParticipant(href) {
                            return find(participants(), function (p) { return p[Internal.sHref] == href; });
                        }
                        //#region resolveParticipant
                        /**
                         * For a given participant href adds a new participant model to the collection if it wasn't
                         * there or matches an existing participant model created from a person model or a SIP URI
                         * to the given href.
                         */
                        function resolveParticipant(href, name) {
                            return Task.run(function () {
                                // Find unresolved participants, i.e. those that were created based on a person model 
                                // or a SIP URI and thus don't have an href. A participant in a disconnected 1:1
                                // conversation becomes an uresolved participant as well, because his href is nulled
                                // when the conversation is disconnected (terminated).  
                                var locals = {}; // indexed by /contact.href or SIP URI
                                for (var _i = 0, _a = participants(); _i < _a.length; _i++) {
                                    var p = _a[_i];
                                    // First check if the participant already exists in the collection.
                                    // One common scenario when this "merging" happens is: messagingInvitation/from
                                    // points to a rel=participant which is immediately added to the collection, then
                                    // UCWA sends a `participant added` event for the same participant, so it gets merged.
                                    if (p[Internal.sHref] == href)
                                        return p;
                                    // collect unresolved participants
                                    if (!p[Internal.sHref]) {
                                        var cHref = p.person[Internal.sHref];
                                        var cUri = p.person.id();
                                        assert(cHref || cUri, 'either /contact.href or uri must be known');
                                        locals[cHref || cUri.toLowerCase()] = p;
                                    }
                                }
                                // If no participants were added to the conversation by this client there is no
                                // need for getting the contact href of this participant to find the matching
                                // Participant model and we can avoid one extra GET per participant which would
                                // be nice when we join a meeting with many participants.
                                if (size(locals) == 0)
                                    return null;
                                // It's just a guess to avoid fetching rel=participant: if it's a p2p conversation,
                                // the only participant in the collection must be the one who the `participant added`
                                // event is targeting at.
                                if (participants.size() == 1 && !isConference())
                                    return participants(0);
                                // In the worst case we don't know which of the locally added participants
                                // corresponds to the `participant added` event and hence we need to get
                                // the /contact href or /participant.uri to find it.
                                var notfound = {};
                                function resolve() {
                                    var r = ucwa.get(href); // rel=participant
                                    var link = r.hasLink('contact') && r.link('contact');
                                    var uri = r.has('uri') && r.get('uri') || '';
                                    var p = link && locals[link.href] || locals[uri.toLowerCase()];
                                    if (p)
                                        return p;
                                    if (link && uri)
                                        throw notfound;
                                }
                                return Task.run(function () {
                                    return resolve() || ucwa.send('GET', href).then(resolve);
                                }).catch(function (err) {
                                    if (err === notfound)
                                        return null;
                                    throw err;
                                });
                            }).then(function (participant) {
                                if (participant) {
                                    // if the participant matching the given href is found
                                    // in the collection, update the href property given to
                                    // that participant object: this resolves href.get() which
                                    // the participant object is waiting for
                                    var pHref = participantHrefs.get(participant);
                                    pHref(href);
                                }
                                else {
                                    // if there is no matching participant object, create one:
                                    // this usually happens after a `participant added` event
                                    var pHRef = Property({ value: href });
                                    // local participant is not a member of the participants collection
                                    assert(!ucwa.get(href).get('local', false));
                                    participant = createParticipant({
                                        href: pHRef.asReadOnly(),
                                        name: name
                                    });
                                    participants.add(participant);
                                    participantHrefs.set(participant, pHRef);
                                }
                            });
                        }
                        //#endregion
                        //#region createParticipantFromPerson
                        /** this is the Conversation::createParticipant method */
                        function createParticipantFromPersonOrUri(person) {
                            var dfd = new Task();
                            dfd.promise.then(); // this task cannot be cancelled
                            var href = Property({
                                get: function () { return href() || dfd.promise; }
                            });
                            href.changed(function (href) {
                                if (href && dfd) {
                                    dfd.resolve(href);
                                    dfd = null;
                                }
                            });
                            if (typeof person === 'object') {
                                // this assertion simply says that the given
                                // person model must be based on an existing
                                // rel=contact resource which is the case if
                                // the person was obtained from a search; this
                                // is needed to match the locally created participant
                                // model with "participant added" events from UCWA
                                assert(person[Internal.sHref], 'rel=contact is unknown');
                            }
                            var participant = createParticipant((_a = {
                                    href: href.asReadOnly()
                                },
                                _a[typeof person === 'object' ? 'person' : 'uri'] = person,
                                _a
                            ));
                            participantHrefs.set(participant, href);
                            return participant;
                            var _a;
                        }
                        //#endregion
                        //#region addParticipant
                        /** this is the Conversation::participants.add method */
                        function addParticipant(participant) {
                            if (typeof participant === 'string')
                                participant = createParticipantFromPersonOrUri(participant);
                            // ts@1.5.0-beta wasn't able to see that `participant` here is a Participant, not a string
                            if (typeof participant === 'object') {
                                if (!participantHrefs.has(participant))
                                    throw EInvalidArgument('participant', 'is not created by this conversation');
                                participants.add(participant);
                                if (state() == 'Connected' || state() == 'Conferenced')
                                    return inviteParticipant(participant);
                            }
                        }
                        //#endregion
                        //#region removeParticipant
                        /** this is the Conversation::participants.remove method */
                        function removeParticipant(participant) {
                            if (typeof participant === 'string') {
                                participant = find(participants(), function (p) {
                                    var lhs = (p.uri() + '').toLowerCase();
                                    var rhs = (participant + '').toLowerCase();
                                    return lhs == rhs;
                                });
                            }
                            // ts@1.5.0-beta wasn't able to see that `participant` here is a Participant, not a string
                            if (typeof participant === 'object') {
                                // check that the participant has been added to the collection
                                if (participants.contains(function (p) { return p === participant; })) {
                                    return Task.run(function () {
                                        // if the /participant/eject link is present,
                                        // the participant is in the conference                        
                                        if (participant.eject.enabled())
                                            return participant.eject();
                                        if (participant.state() == 'Disconnected')
                                            return;
                                        // TODO: what about p2p conversations?
                                        // TODO: removing a participant that is being added is not supported yet
                                        throw Exception('InvalidState');
                                    }).then(function () {
                                        participants.removeAll(function (p) { return p === participant; });
                                        participantHrefs.delete(participant);
                                    });
                                }
                            }
                            // either the participant was created by Conversation::createParticipant and hasn't
                            // been added or it was created by another conversation object; either way there is
                            // nothing to remove
                            throw Exception('InvalidState');
                        }
                        //#endregion
                        //#endregion
                        //#region inviteParticipantByUri
                        /**
                         * If the conversation was in the 1:1 (peer-to-peer) mode, it will be
                         * escalated to the 1:N (multiparty) mode. If the conversation was already
                         * in the 1:N mode, it will merely get a new participant.
                         *
                         * The new participant gets added to the Conversation::participants collection
                         * after the server notifies the client that the participant has been successfully
                         * invited.
                         *
                         * The endpoint that is adding a participant observes these events:
                         *
                         *      - participantInvitation started
                         *      - conversation updated (the state changes to "Conferenced")
                         *      - localParticipant updated (the role changes to "Leader")
                         *      - participant added in leaders (the participant denotes the local participant)
                         *      - onlineMeeting added in conversation
                         *      - participant added (the remote participant gets added)
                         *      - participantInvitation completed
                         *
                         * The participant being added observes these events:
                         *
                         *      - onlineMeetingInvitation started
                         *      - conversation added
                         *      - onlineMeeting added in conversation
                         *      - onlineMeetingInvitation completed
                         *
                         * The other participant that has been in the conversation observes these events:
                         *
                         *      - conversation updated (the state changes to "Conferenced")
                         *      - onlineMeeting added in conversation
                         *
                         * @created Jan 2014
                         * @blame antonkh
                         */
                        function inviteParticipantByUri(uri) {
                            return ucwa.send('POST', rConversation.link('addParticipant').href, {
                                data: { to: uri }
                            }).then(function (rParticipantInvitation) {
                                return ucwa.wait({
                                    type: 'completed',
                                    target: { rel: 'participantInvitation', href: rParticipantInvitation.href }
                                });
                            }).then(function (event) {
                                if (event.status != 'Success')
                                    throw Internal.EInvitationFailed(event.reason);
                            });
                        }
                        //#endregion
                        //#region acknowledge
                        /**
                         * Acknowledge that the user is aware of an auto-accepted conversation.
                         *
                         * @created Sep 2015
                         * @blame yodu
                         */
                        function acknowledge() {
                            return ucwa.send('POST', rConversation.link('userAcknowledged').href);
                        }
                        //#endregion
                        //#region inviteParticipants (internal)
                        /**
                         * Reconciles participants added to the conversation by the local participant
                         * with the participants that are already in the conversation.
                         *
                         * Called by start() method of a conversation service.
                         *
                         * A typical scenario:
                         *    conv = convManager.createConversation();
                         *    conv.participants.add(p1);
                         *    conv.participants.add(p2);
                         *    conv.chatService.start();
                         *
                         * This results in a conversation model that represents a new online meeting. The
                         * participants p1 and p2 must be added to the conversation after the meeting
                         * is created.
                         *
                         *    conv.chatService.stop();
                         *    ....
                         *    conv.chatService.start();
                         *
                         * If the chat service is stopped participants are still in the conversation. When
                         * the chat service is restarted we should not add participants again.
                         *
                         * @created Dec 2014
                         * @blame sosobov
                         */
                        function inviteParticipants() {
                            participants.each(function (p) {
                                // in an outgoing invitation different modalities may invoke
                                // the method multiple times: the AV modality invokes the method
                                // as a reaction to "conversation updated" and then the IM modality
                                // invokes it as a reaction to "meetingInvitation completed" event
                                if (!p[Internal.sHref] && p.state() == 'Disconnected')
                                    inviteParticipant(p);
                            });
                        }
                        //#endregion
                        //#region inviteParticipant (internal)
                        /**
                         * Invites participants added to the conversation by the local participant
                         *
                         * @created Dec 2014
                         * @blame sosobov
                         */
                        function inviteParticipant(p) {
                            assert(!p[Internal.sHref] && p.state() == 'Disconnected');
                            p[Internal.sInternal].state('Connecting');
                            return inviteParticipantByUri(p.person.id()).then(function (res) { return p[Internal.sInternal].state('Connected'); }, function (err) {
                                p[Internal.sInternal].state('Disconnected', err);
                                addParticipantActivityItem('ParticipantJoinFailed', p, err);
                                participants.removeAll(function (pcur) { return p === pcur; });
                                participantHrefs.delete(p);
                            });
                        }
                        //#endregion
                        //#region addModality
                        /**
                         * Adds a new modality to the conversation.
                         *
                         * @param {Conversation.ModalityType} type
                         * @param {Object} [options] - Options for the constructor of the modality.
                         *
                         * @returns {Modality} - The created modality.
                         */
                        function addModality(type, options) {
                            check(type == Conversation.ModalityType.AppSharing, 'NotImplemented', { modality: type });
                            assert(!modalities(type), 'AlreadyExists', { item: type });
                            var modality;
                            options = options || {};
                            // every modality needs these objects
                            extend(options, {
                                ucwa: ucwa,
                                contactManager: contactManager,
                                participants: participants.asReadOnly(),
                                threadId: threadId(),
                                rConversation: rConversation,
                                me: me,
                                topic: subject(),
                                priority: priority()
                            });
                            if (options.resource) {
                                options.invitation = Internal.AppSharingInvitation({
                                    resource: options.resource,
                                    // TODO: remove once AppSharing is converted to a service
                                    createParticipant: function (resource) {
                                        return new Internal.Participant({
                                            href: resource.href,
                                            ucwa: ucwa,
                                            contactManager: contactManager
                                        });
                                    },
                                    ucwa: ucwa
                                });
                            }
                            options.mediaPlugin = mediaPlugin;
                            options.sharedResources = sharedResources;
                            modality = Internal.AppSharingModality(options);
                            modalities.add(modality, type);
                            modality.state.when('Disconnected', function () {
                                modalities.remove(type);
                            });
                            return modality;
                        }
                        //#endregion
                        function addMeeting() {
                            assert(!self.meeting);
                            self.meeting = new Internal.OnlineMeeting({
                                ucwa: ucwa,
                                threadId: threadId(),
                                subject: subject(),
                                priority: priority(),
                                conversation: self,
                                contactManager: contactManager
                            });
                            self.meeting.uri.changed(uri);
                            changed.fire();
                            return self.meeting;
                        }
                        //#region stop
                        /**
                         * After UCWA accepts all requests to stop the modalities,
                         * it also sends a "conversation deleted" event and this conversation
                         * model disappears from the conversations collection.
                         *
                         * @returns {Promise}
                         *
                         *      A task that resolves after all modalities report
                         *      that they are done with stopping themselves.
                         */
                        function stop() {
                            var tasks = [];
                            if (state() == Conversation.State.Disconnected)
                                return;
                            for (var _i = 0, _a = modalities(); _i < _a.length; _i++) {
                                var m = _a[_i];
                                tasks.push(m.stop().catch());
                            }
                            // ignore all errors from the .stop() call
                            tasks.push(chat.stop().catch());
                            tasks.push(self.audioService.stop().catch());
                            return Task.waitAll(tasks).then(function () {
                                // DELETE rel=conversation to quit the conference;
                                // if the conversation is peer-to-peer, there is no harm in deleting
                                // the rel=conversation resource explicitly
                                if (rConversation)
                                    return ucwa.send('DELETE', rConversation.href);
                            });
                        }
                        //#endregion
                        init();
                        return self;
                    }
                    return Conversation;
                })();
                Internal.Conversation = Conversation;
                var Conversation;
                (function (Conversation) {
                    var State;
                    (function (State) {
                        State.Created = 'Created';
                        State.Conferenced = 'Conferenced';
                        State.Conferencing = 'Conferencing';
                        State.Connected = 'Connected';
                        State.Connecting = 'Connecting';
                        State.Disconnected = 'Disconnected';
                        State.Disconnecting = 'Disconnecting';
                        State.Incoming = 'Incoming';
                        /** InLobby is a transient state while the client is joining an online
                            meeting anonymously. After an owner of the meeting admits the anonymous
                            participant, the state goes from InLobby to Conferenced. */
                        State.InLobby = 'InLobby';
                    })(State = Conversation.State || (Conversation.State = {}));
                    ;
                    var ModalityType;
                    (function (ModalityType) {
                        ModalityType.AppSharing = 'AppSharing';
                    })(ModalityType = Conversation.ModalityType || (Conversation.ModalityType = {}));
                })(Conversation = Internal.Conversation || (Internal.Conversation = {}));
            })(Internal = Model_21.Internal || (Model_21.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_22) {
            var Internal;
            (function (Internal) {
                'use strict';
                var find = Web.Utils.find;
                var hash = Web.Utils.hash;
                var assert = Web.Utils.assert;
                var extend = Web.Utils.extend;
                var filter = Web.Utils.filter;
                var foreach = Web.Utils.foreach;
                var isVoid = Web.Utils.isVoid;
                var getOption = Web.Utils.getOption;
                var isString = Web.Utils.isString;
                var isDictionary = Web.Utils.isDictionary;
                var isNotEmptyString = Web.Utils.isNotEmptyString;
                var disableHtmlInText = Web.Utils.disableHtmlInText;
                var Task = Web.Utils.Task;
                var Model = Web.Utils.Model;
                var Property = Web.Utils.Property;
                var Collection = Web.Utils.Collection;
                var NumProperty = Web.Utils.NumProperty;
                var AsyncCommand = Web.Utils.AsyncCommand;
                var ConstProperty = Web.Utils.ConstProperty;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var ConversationsManager = (function () {
                    //#endregion
                    function ConversationsManager(_a) {
                        var ucwa = _a.ucwa, me = _a.me, gcs = _a.gcs, contactManager = _a.contactManager, mediaPlugin = _a.mediaPlugin, devices = _a.devices, sharedResources = _a.sharedResources, guestName = _a.guestName, tm = _a.tm;
                        /** indexed by Conversation::id */
                        var conversations = Collection({
                            subscribed: function () { return conversations.get(); },
                            // In some scenarios, the local conversations collection might not be in sync
                            // with active conversations of the UCWA application instance. So, one can fetch the
                            // active conversations by calling: conversations.get();
                            get: function () { return ucwa.send('GET', { rel: 'conversations' }).then(function (rActiveConversations) {
                                // TODO: if the conversation exists and its properties are not in
                                // sync with the corresponding server instance, we will need to update the local
                                // conversation object accordingly.
                                var isHrefKnown = function (href) { return conversations.contains(function (c) { return c[Internal.sHref] == href; }); };
                                var tasks = rActiveConversations.links('conversation').filter(function (link) {
                                    return !isHrefKnown(link.href);
                                }).map(function (link) {
                                    return ucwa.send('GET', link.href).then(function (r) {
                                        return Task.waitAll([
                                            ucwa.send('GET', r.link('localParticipant').href),
                                            ucwa.send('GET', r.link('messaging').href),
                                            r.hasLink('onlineMeeting') && ucwa.send('GET', r.link('onlineMeeting').href).then(function (r) {
                                                // there might be an existing conversation object with uri, but without href:
                                                // such a conversation represents an ongoing invitation that might get one of
                                                // hrefs returned by GET /conversations
                                                var uris = conversations()
                                                    .filter(function (c) { return !c[Internal.sHref] && !!c.uri(); })
                                                    .map(function (c) { return c.uri().toLowerCase(); });
                                                var uri = r.get('onlineMeetingUri', '').toLowerCase();
                                                if (uris.indexOf(uri) >= 0)
                                                    throw uri; // throw something as it'll be caught later anyway
                                            })
                                        ]);
                                    }).then(function () {
                                        // By this moment the conversation's href may have been resolved.
                                        // TODO: What happens if one of pending conversations get its href shortly
                                        // after this check is made? There will be a duplicate conversation object.
                                        if (isHrefKnown(link.href))
                                            throw link; // throw something as it'll be caught later anyway
                                        var conversation = createConversationModel({
                                            href: link.href,
                                            threadId: ucwa.get(link.href).get('threadId')
                                        });
                                        addConversation(conversation);
                                        return conversation.participants.get(); // GET /participants
                                    }).catch();
                                });
                                return Task.waitAll(tasks).then(function () { return null; }); // get() must return a Promise<void>
                            }); }
                        });
                        var isHistoryEnabled = (gcs ? gcs.conversationHistory : ConstProperty(null)).map(function (value) { return value == 'Enabled'; }, // the mapping function
                        function (// the mapping function
                            isEnabled) { return isEnabled ? 'Enabled' : 'Disabled'; }); // the unmapping function
                        var getMoreConversationsEnabled = Property({ value: true });
                        var unreadConversationsCount = NumProperty(0);
                        //#region initialization
                        function createConversationModel(options) {
                            extend(options, {
                                ucwa: ucwa,
                                me: me,
                                gcs: gcs,
                                guestName: guestName,
                                sharedResources: sharedResources,
                                contactManager: contactManager,
                                mediaPlugin: mediaPlugin,
                                devices: devices,
                                tm: tm
                            });
                            return new Internal.Conversation(options);
                        }
                        ucwa.init().then(function () {
                            var connected = ucwa.find({
                                rel: 'conversation'
                            }).filter(function (rConversation) {
                                return rConversation.get('state', '') in { Connected: 1, Conferenced: 1 };
                            });
                            foreach(connected, function (rConversation) {
                                var conversation = createConversationModel({
                                    href: rConversation.href,
                                    threadId: rConversation.get('threadId')
                                });
                                addConversation(conversation);
                            });
                        });
                        //#endregion
                        //#region public methods
                        /**
                        * Creates an empty conversation model.
                        *
                        * The created conversation model is empty: it has no modalities, no participants
                        * and it's not connected to the server. To make it connected, add modalities,
                        * start them and add participants:
                        *
                        *     var conversation = client.conversationsManager.createConversation();
                        *     var messaging = conversation.chatService;
                        *
                        *     conversation.participants.add("sip:johndoe@contoso.com");
                        *
                        *     messaging.start().then(() => {
                        *         console.log("messaging started");
                        *     });
                        *
                        * Right after the conversation is created, it appears in the `conversations` collection.
                        */
                        function createConversation(options) {
                            assert(isVoid(options) || isDictionary(options));
                            options = options || {};
                            var conversation = createConversationModel({
                                isConference: getOption(options, 'isConference', true),
                                threadId: options.threadId,
                                topic: options.topic,
                                priority: options.priority,
                                participants: options.participants // unit tests may give a collection mock
                            });
                            addConversation(conversation);
                            return conversation;
                        }
                        /** Either find an existing conversation model that represents an existing multiparty conversation
                            (meeting) or create a new model representing that meeting. */
                        function getConversationByUri(uri, args) {
                            assert(isNotEmptyString(uri));
                            var conversation = find(conversations(), function (conv) { return conv.uri() == uri; });
                            if (!conversation) {
                                var threadId;
                                if (args && args.wac && uri) {
                                    var timeStamp = args.timeStamp || new Web.Date();
                                    timeStamp.setHours(0, 0, 0, 0);
                                    threadId = new Internal.ThreadId(timeStamp, hash(uri)) + '';
                                }
                                conversation = createConversationModel({ uri: uri, threadId: threadId });
                                addConversation(conversation);
                            }
                            return conversation;
                        }
                        /** Either find an existing 1:1 conversation with this person or create a new one. */
                        function getConversation(person, options) {
                            assert(isVoid(options) || isDictionary(options));
                            options = options || {};
                            var convs = filter(conversations(), function (conv) {
                                // Multiparty conversations with one remote participant are excluded per interface contract:
                                // this method is supposed to return a 1:1 conversation only (the single Skype conversation).
                                // TODO: In a meeting a participant may have a person object without the contact href,
                                // or other unique properties so we would have to fetch the contact ref which would make this
                                // method async.
                                return conv.participants.size() == 1 && !conv.isGroupConversation() &&
                                    (isString(person) ? conv.participants(0).person.id().toLowerCase() === person.toLowerCase() :
                                        conv.participants(0).person[Internal.sHref] == person[Internal.sHref]);
                            });
                            // There may be multiple ongoing conversations with the same participant,
                            // so we return the first one.
                            if (convs.length > 0)
                                return convs[0];
                            var conversation = createConversationModel({
                                isConference: false,
                                threadId: options.threadId,
                                topic: options.topic,
                                priority: options.priority
                            });
                            addConversation(conversation);
                            var participant = conversation.createParticipant(person);
                            conversation.participants.add(participant);
                            return conversation;
                        }
                        /** Fetch active conversations for this client. */
                        function getMoreConversations() {
                            return conversations.get().then(function () { return getMoreConversationsEnabled(false); });
                        }
                        //#endregion
                        ucwa.event(function (event) {
                            var invitation = event.resource;
                            // Creates a conversation on the first incoming invitation. All subsequent invitiations for other
                            // modalities should be handled by the respective services. For example, this handler creates a
                            // new conversation when an audio/video invitation is received. Later, when the remote party adds
                            // messaging, the messagingInvitation is not handled here but is processed by the conversation's
                            // chat service.
                            //
                            // In the multitab scenario this handler is used to react on an outgoing invitation sent by another
                            // tab: that tab starts a conversation, while other tabs receive the same sequence of events and
                            // create matching conversation objects.
                            if (event.type == 'started' && /^(messaging|audioVideo|onlineMeeting|applicationSharing)Invitation$/.test(invitation.rel)) {
                                var threadId = invitation.get('threadId') + '';
                                var isIncoming = invitation.get('direction') == 'Incoming';
                                // this invitation could be initiated by an existing conversation object:
                                // if this is the case, such an invitation will be handled by that conversation
                                var conversation = find(conversations(), function (cv) { return cv.threadId() == threadId; });
                                // All p2p conversations with the same peson should be merged into one.
                                // If it's a p2p incoming invitation, find a disconnected p2p conversation
                                // with the same person: if such a conversation exists, it can be used to
                                // handle this invitation. The point of this merging is to simplify UI.
                                if (!conversation) {
                                    var disconnected = conversations().filter(function (c) {
                                        return c.state() == Internal.Conversation.State.Disconnected ||
                                            c.state() == Internal.Conversation.State.Created;
                                    });
                                    if (invitation.rel == 'onlineMeetingInvitation') {
                                        var meetingUri = invitation.get('onlineMeetingUri', '').toLowerCase();
                                        conversation = find(disconnected, function (cv) {
                                            return (cv.uri() + '').toLowerCase() == meetingUri;
                                        });
                                    }
                                    else {
                                        // find a disconnected p2p conversation with the same person
                                        conversation = find(disconnected, function (cv) {
                                            if (cv.isGroupConversation() || cv.participants.size() != 1)
                                                return false;
                                            var remote = cv.participants(0).person;
                                            if (isIncoming) {
                                                var from = ucwa.get(invitation.link('from').href); // rel=participant
                                                return (remote.id() + '').toLowerCase() == (from.get('uri') + '').toLowerCase() ||
                                                    remote[Internal.sHref] == from.link('contact').href;
                                            }
                                            else {
                                                // it's a disconnected conversation revived by an outgoing invitation
                                                // sent by another tab to this contact
                                                return remote[Internal.sHref] == invitation.link('to').href; // rel=contact
                                            }
                                        });
                                    }
                                    if (conversation)
                                        // processInvitation supports outgoing and incoming 1:1 and 1:N invitation
                                        conversation[Internal.sInternal].processInvitation(invitation);
                                }
                                if (!conversation) {
                                    conversation = createConversationModel({
                                        rInvitation: invitation,
                                        threadId: threadId,
                                        topic: disableHtmlInText(invitation.get('subject', '')),
                                        priority: invitation.get('importance', 'Normal')
                                    });
                                    addConversation(conversation);
                                }
                                // TODO: this is the update part that will go away once we have ScreenSharing service
                                if (invitation.rel == 'applicationSharingInvitation')
                                    conversation.addModality(Internal.Conversation.ModalityType.AppSharing, { resource: invitation });
                            }
                        });
                        function addConversation(conversation) {
                            if (!conversations(conversation.id()))
                                conversations.add(conversation, conversation.id());
                            conversation.historyService.unreadActivityItemsCount.changed(function () {
                                unreadConversationsCount(conversations().filter(function (conversation) {
                                    return conversation.historyService.unreadActivityItemsCount() > 0;
                                }).length);
                            });
                        }
                        function removeConversation(conversation) {
                            return conversation.leave().catch().then(function () { return conversations.remove(conversation.id()); });
                        }
                        // All these commands are enabled only when signed in.
                        // Some commands can be theoretically enabled any time,
                        // but then they will need a more sophisticated implementation.
                        return Model({
                            conversations: conversations.asWritable({
                                add: EnabledCommand(addConversation),
                                remove: EnabledCommand(removeConversation)
                            }),
                            unreadConversationsCount: unreadConversationsCount.asReadOnly(),
                            isHistoryEnabled: isHistoryEnabled,
                            createConversation: EnabledCommand(createConversation),
                            getConversation: EnabledCommand(getConversation),
                            getConversationByUri: EnabledCommand(getConversationByUri),
                            getMoreConversations: AsyncCommand(getMoreConversations, getMoreConversationsEnabled),
                            createSearchQuery: EnabledCommand(function () { return new Internal.ConversationSearchQuery(conversations); })
                        });
                    }
                    return ConversationsManager;
                })();
                Internal.ConversationsManager = ConversationsManager;
            })(Internal = Model_22.Internal || (Model_22.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            var Internal;
            (function (Internal) {
                'use strict';
                var timeStampToDate = Web.Utils.timeStampToDate;
                var DataUri = Web.Utils.DataUri;
                /**
                 * Wraps /communication into an observable model.
                 *
                 * @created Jun, 2015
                 * @blame antonkh
                 */
                var Communication = (function () {
                    function Communication(ucwa) {
                        // TODO: once ObservableResource becomes a class,
                        // this must be converted into a super(...) call
                        return Internal.ObservableResource(ucwa, { rel: 'communication' }, function ($) {
                            $.member('conversationLogs', function ($) {
                                $.collection('conversationLog', function ($) {
                                    $.collection('conversationLogRecipient', function ($) {
                                        return $.property('sipUri');
                                    });
                                    $.member('conversationLogTranscripts', function ($) {
                                        $.collection('conversationLogTranscript', function ($) {
                                            $.member('messageTranscript', function ($) {
                                                $.member('htmlMessage', function ($) {
                                                    return $.property('href', function (href) { return DataUri(href).data; });
                                                });
                                                $.member('plainMessage', function ($) {
                                                    return $.property('href', function (href) { return DataUri(href).data; });
                                                });
                                            });
                                            $.member('contact', function ($) {
                                                return $.property('href');
                                            });
                                            $.property('timeStamp', timeStampToDate);
                                        });
                                    });
                                    $.property('subject');
                                    $.property('threadId');
                                    $.property('direction');
                                    $.property('totalRecipientsCount');
                                });
                            });
                            $.property('conversationHistory');
                            $.command('joinOnlineMeeting');
                        });
                    }
                    return Communication;
                })();
                Internal.Communication = Communication;
            })(Internal = Model.Internal || (Model.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="SignInManager.ts" />
/// <reference path="GeneralPolicies.ts" />
/// <reference path="Search.ts" />
/// <reference path="Group.ts" />
/// <reference path="RootGroup.ts" />
/// <reference path="PersonsAndGroupsManager.ts" />
/// <reference path="ContactManager.ts" />
/// <reference path="PresenceSubscription.ts" />
/// <reference path="PresenceSubscriptionManager.ts" />
/// <reference path="OnlineMeeting.ts" />
/// <reference path="MyOnlineMeeting.ts" />
/// <reference path="Message.ts" />
/// <reference path="ActivityItem.ts" />
/// <reference path="Person.ts" />
/// <reference path="MePerson.ts" />
/// <reference path="ChatService.ts" />
/// <reference path="Participant.ts" />
/// <reference path="Conversation.ts" />
/// <reference path="ConversationsManager.ts" />
/// <reference path="Communication.ts" />
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model_23) {
            var Internal;
            (function (Internal) {
                'use strict';
                var keys = Web.Utils.keys;
                var hash = Web.Utils.hash;
                var async = Web.Utils.async;
                var debug = Web.Utils.debug;
                var sleep = Web.Utils.sleep;
                var extend = Web.Utils.extend;
                var indexOf = Web.Utils.indexOf;
                var getOption = Web.Utils.getOption;
                var repeatAndExit = Web.Utils.repeatAndExit;
                var setHiddenProperty = Web.Utils.setHiddenProperty;
                var Model = Web.Utils.Model;
                var Symbol = Web.Utils.Symbol;
                var Command = Web.Utils.Command;
                var Property = Web.Utils.Property;
                var Exception = Web.Utils.Exception;
                var EnabledCommand = Web.Utils.EnabledCommand;
                var EInvalidArgument = Web.Utils.EInvalidArgument;
                var DisabledCommand = Web.Utils.DisabledCommand;
                var UCWA = Web.Stack.UCWA;
                /** application[sUCWA] = the UCWA stack for the app */
                var sUCWA = Symbol('ucwa');
                /** window[sInstances] keeps the list of all created apps */
                var sInstances = Symbol('apps');
                /**
                 * The root object in the object model.
                 *
                 * One instance of Application creates one UCWA endpoint that
                 * can sign in with its own credentials. The constructor
                 * is not a singleton as it is possible to create several
                 * UCWA endpoints in one web app and make them chat with
                 * each other via the UCWA protocol.
                 *
                 * @created Jul 2013
                 * @blame sosobov
                 * @blame antonkh
                 */
                var Application = (function () {
                    //#endregion
                    function Application(options) {
                        if (options === void 0) { options = {}; }
                        var state = Property();
                        var settings = options.settings || {};
                        var app = Model();
                        var ConversationsManagerCtor = options.ConversationsManager || Internal.ConversationsManager;
                        var telemetryManager = options.telemetryManager;
                        var tenantToken = settings.cafeTenantToken;
                        var tm = new Web.TelemetryRecorder(telemetryManager, tenantToken);
                        var ucwa = options.ucwa || new UCWA({ tm: tm }); // a unit test may give a mock of the UCWA stack
                        var guestName = Property();
                        var dfdSignedIn;
                        var dfdSignedOut;
                        var conversationsManager;
                        function init() {
                            state(Application.State.SignedOut);
                            app.suspended = ucwa.suspended;
                            // expose the UCWA stack to simplify debugging
                            // with the dev console, but make it impossible
                            // to use by other js code
                            setHiddenProperty(app, sUCWA, ucwa);
                            // eventually some of these settings might become a part of
                            // the external interface, but for now they remain internal
                            var gcs = new Internal.Communication(ucwa);
                            var me = new Internal.MePerson(ucwa, {
                                guestName: guestName.asReadOnly(),
                                supportsConferencing: gcs.joinOnlineMeeting.enabled.asReadOnly(),
                                tm: tm
                            });
                            var psm = new Internal.PresenceSubscriptionManager(ucwa, settings.presenceSubscriptionsBatchSize, settings.presenceSubscriptionDuration, tm);
                            var contactManager = new Internal.ContactManager(ucwa, psm);
                            var mediaPlugin = new Internal.MediaPlugin(ucwa);
                            var devices = new Internal.DevicesManager(mediaPlugin);
                            var sharedResources = Internal.SharedResources(mediaPlugin);
                            var pgm = new Internal.PersonsAndGroupsManager({
                                ucwa: ucwa,
                                psm: psm,
                                contactmgr: contactManager,
                                me: me,
                                tm: tm
                            });
                            conversationsManager = new ConversationsManagerCtor({
                                ucwa: ucwa,
                                me: me,
                                gcs: gcs,
                                guestName: guestName.asReadOnly(),
                                mediaPlugin: mediaPlugin,
                                contactManager: contactManager,
                                devices: devices,
                                sharedResources: sharedResources,
                                tm: tm
                            });
                            app.mediaPolicies = new Internal.MediaPolicies(ucwa);
                            app.personsAndGroupsManager = pgm;
                            app.conversationsManager = conversationsManager;
                            app.windows = sharedResources.windows;
                            app.monitors = sharedResources.monitors;
                            app.policies = new Internal.GeneralPolicies(ucwa);
                            app.devicesManager = devices;
                            state.when(Application.State.SignedIn, function () {
                                // .connected means connected to the event channel,
                                // so the stack can be signed in but disconnected
                                var sub = ucwa.connected.when(false, function (reason, wasConnected) {
                                    // right after sign in the stack may still be connecting
                                    if (wasConnected) {
                                        debug.log('%c The server has terminated the event channel with this endpoint.', 'color:red;font-weight:bold', reason);
                                        state(Application.State.SignedOut, reason);
                                    }
                                });
                                // publish the self presence and let others send IMs to this client
                                me.available(true);
                                // the setting can be changed only when the stack is connected
                                // to the server and when rel=communication has an etag value
                                conversationsManager.isHistoryEnabled.set.enabled.once(true, function () {
                                    var delay = 4.12;
                                    // If the PUT /communication is sent after POST /makeMeAvailable
                                    // and before the "communication updated" event with a new etag
                                    // value, the PUT will be rejected with a 412.PreconditionFailed.
                                    // This happens because the POST changes the etag once the server
                                    // gets the request, but the client remains unaware of the new etag
                                    // value until the "updated" event arrives.
                                    repeatAndExit(function (exit) {
                                        // without a delay an attempt to enable the conversation history
                                        // flag results in a cryptic error: 412 code=PreconditionFailed;
                                        // and a delay of 4.12 seconds seems to be good enough to fix it
                                        return sleep(delay).then(function () {
                                            delay *= 2;
                                            // unconditionally enable the conversation history feature:
                                            // this will also make UCWA auto-accept IM requests and archive
                                            // them in Exchange; otherwise if this is the only available
                                            // endpoint and it gets an IM request which is not accepted,
                                            // it gets auto-declined and not archived anywhere
                                            return conversationsManager.isHistoryEnabled.set(true).then(exit, function (err) {
                                                // there is a subcode=PreconditionFailed field in the response body,
                                                // but since the status code 412 already means that a precondition
                                                // failed, the subcode is ignored
                                                var is412 = err.code == 'RequestFailed' && err.rsp.status == 412;
                                                if (!is412)
                                                    throw err;
                                            });
                                        });
                                    });
                                });
                                state.once(Application.State.SignedOut, function () {
                                    if (mediaPlugin)
                                        mediaPlugin.uninitMedia();
                                    sub.dispose();
                                    ucwa.uninit();
                                });
                            });
                        }
                        function defineCommand(states, fn) {
                            var enabled = Property();
                            var command = Command(fn, enabled);
                            state.changed(function (value) {
                                enabled(indexOf(states, value) >= 0);
                            });
                            return command;
                        }
                        function defineAsyncCommand(states, fn) {
                            return defineCommand(states, async(fn));
                        }
                        //#region signIn
                        var cmdSignIn = settings.supportsSignIn === false ?
                            DisabledCommand(Exception('ECS')) :
                            defineAsyncCommand([Application.State.SignedOut], function (options) {
                                if (tm)
                                    tm.defaults.appVersion = options.version; // this prop may be missing, which is fine
                                if (options.meeting) {
                                    if (!options.name)
                                        throw EInvalidArgument('name', 'Default display name in anonymous meetings is required.');
                                    guestName(options.name);
                                    delete options.name; // the name parameter tells the stack to use the p2p anon auth
                                }
                                if (settings.lockEndpointId) {
                                    if (options.id)
                                        throw new Error('.id cannot be set as it is computed automatically');
                                    if (!options.version)
                                        throw new Error('.version is mandatory');
                                    options.id = hash(options.version);
                                }
                                var capabilities = app.personsAndGroupsManager.mePerson.capabilities;
                                var internal = options.enableInternalNS;
                                // as of Dec 2015 the internal flag is required to use the UCWA media APIs
                                capabilities.chat.text(getOption(settings, 'supportsText', getOption(settings, 'supportsMessaging', true)));
                                capabilities.chat.html(getOption(settings, 'supportsHtml', getOption(settings, 'supportsMessaging', true)));
                                capabilities.audio(getOption(settings, 'supportsAudio', internal));
                                capabilities.video(getOption(settings, 'supportsVideo', internal));
                                capabilities.screenSharing(getOption(settings, 'supportsSharing', internal));
                                state(Application.State.SigningIn);
                                // ucwa should have been uninitialized already and thus
                                // a call to .init(...) shouldn't throw any exceptions
                                dfdSignedIn = ucwa.init(options).then(function (res) {
                                    state(Application.State.SignedIn);
                                }, function (err) {
                                    state(Application.State.SignedOut, err);
                                    throw err;
                                });
                                tm && tm.monitor(dfdSignedIn, 'signin', {}, 15000);
                                return dfdSignedIn;
                            });
                        //#endregion
                        //#region signOut
                        var cmdSignOut = defineAsyncCommand(keys(Application.State), function () {
                            switch (state()) {
                                case Application.State.SignedOut:
                                    return; // already signed out
                                case Application.State.SigningIn:
                                    dfdSignedIn.cancel(Exception('SignedOut'));
                                    // suppress all errors as signout must always succeed
                                    return dfdSignedIn.catch();
                                case Application.State.SigningOut:
                                    return dfdSignedOut;
                                case Application.State.SignedIn:
                                    state(Application.State.SigningOut);
                                    // even though the DELETE request may fail,
                                    // the client still goes to the signed-out state,
                                    // because otherwise the client won't be usable at all
                                    dfdSignedOut = ucwa.send('DELETE', { rel: 'application' }).then(function (res) {
                                        state(Application.State.SignedOut);
                                    }, function (err) {
                                        state(Application.State.SignedOut, err);
                                        throw err;
                                    });
                                    tm && tm.monitor(dfdSignedOut, 'signout');
                                    return dfdSignedOut;
                            }
                        });
                        //#endregion
                        //#region startMessaging
                        /**
                         * Starts an IM conversation with a given participant.
                         *
                         * @param {String} to - SIP URI of the participant.
                         * @param {String} [message=""]
                         * @param {String} [priority="Normal"]
                         * @param {String} [topic=""]
                         * @param [context]
                         *
                         * @returns {Promise<Conversation>}
                         *
                         * @example
                         *
                         *      client.startMessaging({
                         *          to: 'sip:johndoe@contoso.com',
                         *          message: 'How are you?',
                         *          topic: 'A very important conversation',
                         *          priority: 'Urgent'
                         *      }).then(function (conversation) {
                         *          console.log('conversation started');
                         *          return conversation.chatService.sendMessage('Hi!');
                         *      }).then(function () {
                         *          console.log('IM sent');
                         *      });
                         */
                        var cmdStartMessaging = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            var conversation = app.conversationsManager.createConversation({
                                isConference: false,
                                topic: options.topic,
                                priority: options.priority,
                                threadId: options.threadId
                            });
                            var messaging = conversation.chatService;
                            return messaging.start({
                                to: options.to,
                                message: options.message,
                                context: options.context,
                                // these are given by unit tests:
                                boundary: options.boundary,
                                operationId: options.operationId,
                                sessionContext: options.sessionContext
                            }).then(function () {
                                return conversation;
                            });
                        });
                        //#endregion
                        //#region startAudioVideo
                        /**
                         * Starts an audio/video call with a given participant.
                         *
                         * @param {String} to - SIP URI of the participant.
                         * @param {Dictionary} [video] - If present start an audio/video call, otherwise start just an audio call.
                         *
                         *      {HTMLElement} container - parent DOM element for video window
                         *
                         * @returns {Promise<Conversation>}
                         *
                         * @example
                         *
                         *      // start audio
                         *      client.startAudioVideo({
                         *          to: 'sip:johndoe@contoso.com'
                         *      }).then(function (conversation) {
                         *          console.log('audio started');
                         *          conversation.audioService.stop();
                         *      }).then(function () {
                         *          console.log('audio stopped');
                         *      });
                         *
                         *      // start audio and video
                         *      client.startAudioVideo({
                         *          to: 'sip:johndoe@contoso.com',
                         *          video: { container: document.getElementById('myVideoWindowContainer') }
                         *      });
                         */
                        var cmdStartAudioVideo = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            var conversation = app.conversationsManager.createConversation({
                                isConference: false,
                                threadId: options.threadId
                            });
                            var dfd = options.video ?
                                conversation.videoService.start(options) :
                                conversation.audioService.start(options);
                            return dfd.then(function () { return conversation; });
                        });
                        //#endregion
                        //#region startAppSharing
                        /**
                         * Starts an app-sharing call with a given participant.
                         *
                         * @param {String} to - SIP URI of the participant.
                         * @param {ShareableWindow} window - Window resource to share
                         * @param {ShareableMonitor} monitor - Monitor resource to share
                         * @param {HTMLElement} container - DOM element used for viewing shared content
                         *
                         * @returns {Promise<Conversation>}
                         *
                         * @example
                         *
                         *      // start app-sharing
                         *      client.startAppSharing({
                         *          to: 'sip:johndoe@contoso.com',
                         *          window: window,
                         *          monitor: monitor,
                         *          container: document.getElementById('appSharingViewer')
                         *      }).then(function (conversation) {
                         *          console.log('app-sharing started');
                         *          var appSharing = conversation.modalities('AppSharing');
                         *          appSharing.stop();
                         *      }).then(function () {
                         *          console.log('app-sharing stopped');
                         *      });
                         */
                        var cmdStartAppSharing = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            var conversation = app.conversationsManager.createConversation({
                                isConference: false,
                                threadId: options.threadId
                            });
                            var as = conversation.addModality(Internal.Conversation.ModalityType.AppSharing);
                            return as.start(options).then(function () { return conversation; });
                        });
                        //#endregion
                        //#region startMeeting
                        /**
                         * Creates an online meeting. The created meeting is represented by a
                         * Conversation model with an OnlineMeeting model inside. The created
                         * conversation does not have any modalities, so needed modalities
                         * need to be added first and then needed participants need to be
                         * brought into the meeting:
                         *
                         *      client.startMeeting({
                         *          topic: 'A very important meeting.',
                         *          priority: 'Urgent'
                         *      }).then(function (conversation) {
                         *          conversation.addParticipant('sip:user1@contoso.com');
                         *          conversation.addParticipant('sip:user2@contoso.com');
                         *          conversation.addParticipant('sip:user3@contoso.com');
                         *      });
                         *
                         * Note, that modalities have to be added before participants.
                         * The created conversation has the messaging modality, so it can
                         * be used to send and receive messages right away. To join an existing
                         * meeting with a known URI, specify the "uri" parameter:
                         *
                         *      client.startMeeting({
                         *          uri: "sip:user5@contoso.com;gruu;opaque=app:conf:focus:id:WHBSYO8R"
                         *      }).then(function (conversation) {
                         *          var text = "Hi everybody! I'm " + client.personsAndGroupsManager.mePerson.name() + ".";
                         *          conversation.chatService.sendMessage(text);
                         *      });
                         *
                         * @param {String} [topic=""]
                         * @param {String} [priority="Normal"]
                         * @param {String} [uri] - The URI of an existing meeting to join.
                         * @param {String} [name] - The guest name when joining an online meeting anonymously.
                         *
                         * @returns {Promise<Conversation>}
                         * @created antonkh, Jan 2014
                         */
                        var cmdStartMeeting = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            if (options === void 0) { options = {}; }
                            var conversation = app.conversationsManager.createConversation({
                                isConference: true,
                                topic: options.topic,
                                priority: options.priority,
                                threadId: options.threadId
                            });
                            return conversation.addMeeting().start({
                                uri: options.uri,
                                name: options.name
                            }).then(function () {
                                return conversation.chatService.start();
                            }).then(function () {
                                return conversation;
                            });
                        });
                        //#endregion
                        //#region scheduleMeeting
                        /**
                         * Schedules an online meeting. The created meeting is represented by a MyOnlineMeeting
                         * model containing observable properties. The returned model can be used with startMeeting
                         * to start/join the meeting. All parameters are optional:
                         *
                         *      client.scheduleMeeting().then(function (meeting) {
                         *          return client.startMeeting({
                         *              uri: meeting.onlineMeetingUri()
                         *          });
                         *      }).then(function (conversation) {
                         *          return conversation.chatService.sendMessage("Hello");
                         *      });
                         *
                         * @param {String} [accessLevel] - Controls who is let into the meeting.
                         *
                         *  - Everyone
                         *  - Invited - Only users in the attendees/leaders, all others are put in the lobby.
                         *  - Locked - All users except the organizer are put into the lobby.
                         *  - SameEnterprise - Only users from the same enterprise, all others are put in the lobby.
                         *
                         * @param {Array<String>} [attendees] - SIP URIs of users to include as attendees.
                         * @param {String} [automaticLeaderAssignment] - Which participants are automatically promoted to leaders.
                         *
                         *  An online meeting organizer can schedule a meeting so that users are automatically promoted
                         *  to the leader role when they join the meeting. For example, if the meeting is scheduled with
                         *  automatic promotion policy set to "SameEnterprise", then any participants
                         *  from the organizer's company are automatically promoted to leaders when they join the meeting.
                         *  Conference leaders can still promote specific users to the leader role, including anonymous users.
                         *
                         * @param {String} [description] - Purpose of the meeting
                         * @param {String} [entryExitAnnouncement] - The attendance announcements status for the online meeting.
                         *
                         *  When attendance announcements are enabled, the online meeting will announce the names
                         *  of the participants who join the meeting through audio.
                         *
                         * @param {Date} [expirationTime] - The UTC date and time after which the online meeting can be deleted.
                         *
                         *  The day and time must be between one year before, and ten years after,
                         *  the current date and time on the server. If the expiration time is specified,
                         *  it must point to a moment in the future. Consider this example that schedules a meeting
                         *  valid for one day:
                         *
                         *      client.scheduleMeeting({
                         *          expirationTime: new Date(+new Date + 24 * 60 * 60 * 1000)
                         *      });
                         *
                         * @param {Array<String>} [leaders] - Array of SIP URIs of users to include as leaders.
                         *
                         *  The organizer will automatically be added to the leaders list.
                         *
                         * @param {String} [lobbyBypassForPhoneUsers] - When enabled phone users will skip the meeting lobby.
                         * @param {String} [phoneUserAdmission] - Whether participants can join the online meeting over the phone.
                         *
                         *  Setting this property to true means that online meeting participants can join the meeting
                         *  over the phone through the Conferencing Auto Attendant (CAA) service.
                         *
                         * @param {String} [subject] - The subject of the online meeting.
                         *
                         * @returns {Promise<MyOnlineMeeting>}
                         * @created v-shagma, Jul 2014
                         */
                        var cmdScheduleMeeting = defineAsyncCommand([Application.State.SignedIn], function (options) {
                            if (options === void 0) { options = {}; }
                            return ucwa.send('POST', { rel: 'myOnlineMeetings' }, {
                                data: {
                                    accessLevel: options.accessLevel,
                                    attendees: options.attendees,
                                    automaticLeaderAssignment: options.automaticLeaderAssignment,
                                    description: options.description,
                                    entryExitAnnouncement: options.entryExitAnnouncement,
                                    expirationTime: options.expirationTime && options.expirationTime.toJSON(),
                                    leaders: options.leaders,
                                    lobbyBypassForPhoneUsers: options.lobbyBypassForPhoneUsers,
                                    phoneUserAdmission: options.phoneUserAdmission,
                                    subject: options.subject
                                }
                            }).then(function (r) {
                                return Internal.MyOnlineMeeting(ucwa, {
                                    source: r.href
                                });
                            });
                        });
                        //#endregion
                        //#region getSnapshot
                        var cmdGetSnapshot = defineCommand([Application.State.SignedIn], function () {
                            return ucwa.getSnapshot();
                        });
                        //#endregion
                        if (!Web.isUnitTested)
                            Web.window[sInstances].push(app);
                        init();
                        return extend(app, {
                            signInManager: Model({
                                state: state.asReadOnly(),
                                createPasswordSignInParameter: EnabledCommand(function (x) { return extend(x, { type: 'Password' }); }),
                                createImplicitOAuthSignInParameter: EnabledCommand(function (x) { return extend(x, { type: 'ImplicitOAuth' }); }),
                                signIn: cmdSignIn,
                                signOut: cmdSignOut
                            }),
                            startMessaging: cmdStartMessaging,
                            startAudioVideo: cmdStartAudioVideo,
                            startAppSharing: cmdStartAppSharing,
                            startMeeting: cmdStartMeeting,
                            scheduleMeeting: cmdScheduleMeeting,
                            getSnapshot: cmdGetSnapshot,
                            conversationsManager: conversationsManager
                        });
                    }
                    return Application;
                })();
                Internal.Application = Application;
                // the app may not want to make these apps accessible to anyone,
                // so to expose this array in the debugging console and yet to
                // not break encapsulation, the array is accessible at a hidden
                // symbol which can be read manually in the dev console, but cannot
                // be read programmatically; note, that in unit tests symbols are
                // plain strings, so tests can access this property directly
                setHiddenProperty(Web.window, sInstances, []);
                var Application;
                (function (Application) {
                    var State;
                    (function (State) {
                        State.SignedOut = 'SignedOut';
                        State.SignedIn = 'SignedIn';
                        State.SigningOut = 'SigningOut';
                        State.SigningIn = 'SigningIn';
                    })(State = Application.State || (Application.State = {}));
                })(Application = Internal.Application || (Internal.Application = {}));
            })(Internal = Model_23.Internal || (Model_23.Internal = {}));
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
/// <reference path="ttt.ts" />
/// <reference path="telemetry.ts" />
/// <reference path="ucwa.ts" />
/// <reference path="media-model.ts" />
/// <reference path="model/Application.ts" />
/// <reference path="../spec/s4b.sdk/Application.d.ts"/>
/// <reference path="../spec/int/Application.d.ts"/>
/**
 * The model layer built on top of the stack layer.
 *
 * The model creates the stack and subscribes to its events.
 * In turn it creates models that are subscribed to stack objects
 * and provides observable properties and collections to which
 * the view model can bind.
 *
 * As an example Model.Person uses Stack.Application to send and
 * receive HTTP requests, Stack.Connection to listen to the event
 * channel and Stack.Repository to have access to the UCWA resource
 * representing the contact.
 *
 * To the view model, the Person offers a set of observable properties:
 * the Person updates these properties when it receive events from
 * the stack layer and the view model gets notified when these properties
 * are changed.
 *
 * Here is an example how the view model can bind to a Person's presence status:
 *
 *      person1.status.changed(function (status) {
 *          console.log("availability: " + status);
 *      });
 *
 * In this example when the view model subscribes to the contact's presence,
 * the contact creates the presence subscription on the server and when the
 * view model unsubscribes from the presence, the contact deletes the
 * presence subscription.
 *
 * @created July 2013
 */
var Skype;
(function (Skype) {
    var Web;
    (function (Web) {
        var Model;
        (function (Model) {
            'use strict';
            Model.Application = Model.Internal.Application;
            if (Web.ttt) {
                Web.ttt.ctor = Model.Application;
                Model.Application = (function (args) { return Web.ttt.root(args); });
            }
            try {
                define({
                    Application: Model.Application,
                    version: Web.version,
                    settings: Web.Settings
                });
            }
            catch (_) {
            }
        })(Model = Web.Model || (Web.Model = {}));
    })(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));

var Skype; (function (Skype) {
var Web; (function (Web) {
var Media; (function (Media) {
var constants, vendorSdpTransform, helper, msSdpTransform, webRtcSessionDescription, userAgentAdapter, webRtcSession, ortcTransport, ortcParameters, ortcMediaChannel, ortcSdp, ortcSession, session, deviceManager, mediaAgent;
constants = {
  MEDIA_STATE: {
    send: 'sendonly',
    receive: 'recvonly',
    sendReceive: 'sendrecv',
    inactive: 'inactive'
  },
  MEDIA_DEVICE: {
    camera: 'camera',
    microphone: 'microphone',
    speaker: 'speaker'
  },
  MEDIA_ERROR: {
    iceConnectionError: 'iceConnectionError',
    internalError: 'internalError'
  },
  RENEGOTIATION_ERROR: {
    local: 'local',
    //error happened locally
    glare: 'glare',
    //when two sides start renegotiation then one gets rejected by glare, glare also means next renegotiation offer will come
    signaling: 'signaling',
    //this is generic signaling error including timeouts
    media: 'media'  //when error happens on the renegotiation answerer this is reported back to offerer
  },
  MSI: {
    unsubscribe: -1,
    subscribeAny: -2
  },
  MEDIA_LABEL: {
    audio: 'main-audio',
    video: 'main-video',
    screensharing: 'applicationsharing-video'
  },
  MEDIA_TYPE: {
    audio: 'audio',
    video: 'video'
  }
};
!function (e) {
  if ('object' == typeof exports && 'undefined' != typeof module)
    module.exports = e();
  else if (true)
    vendorSdpTransform = function () {
      return typeof e === 'function' ? e() : e;
    }();
  else {
    var f;
    'undefined' != typeof window ? f = window : 'undefined' != typeof global ? f = global : 'undefined' != typeof self && (f = self), f.sdpTransform = e();
  }
}(function () {
  var define, module, exports;
  return function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == 'function' && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error('Cannot find module \'' + o + '\'');
          throw f.code = 'MODULE_NOT_FOUND', f;
        }
        var l = n[o] = { exports: {} };
        t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == 'function' && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  }({
    1: [
      function (require, module, exports) {
        var grammar = module.exports = {
          v: [{
              name: 'version',
              reg: /^(\d*)$/
            }],
          o: [{
              //o=- 20518 0 IN IP4 203.0.113.1
              // NB: sessionId will be a String in most cases because it is huge
              name: 'origin',
              reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
              names: [
                'username',
                'sessionId',
                'sessionVersion',
                'netType',
                'ipVer',
                'address'
              ],
              format: '%s %s %d %s IP%d %s'
            }],
          // default parsing of these only (though some of these feel outdated)
          s: [{ name: 'name' }],
          i: [{ name: 'description' }],
          u: [{ name: 'uri' }],
          e: [{ name: 'email' }],
          p: [{ name: 'phone' }],
          z: [{ name: 'timezones' }],
          // TODO: this one can actually be parsed properly..
          r: [{ name: 'repeats' }],
          // TODO: this one can also be parsed properly
          //k: [{}], // outdated thing ignored
          t: [{
              //t=0 0
              name: 'timing',
              reg: /^(\d*) (\d*)/,
              names: [
                'start',
                'stop'
              ],
              format: '%d %d'
            }],
          c: [{
              //c=IN IP4 10.47.197.26
              name: 'connection',
              reg: /^IN IP(\d) (\S*)/,
              names: [
                'version',
                'ip'
              ],
              format: 'IN IP%d %s'
            }],
          b: [{
              //b=AS:4000
              push: 'bandwidth',
              reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
              names: [
                'type',
                'limit'
              ],
              format: '%s:%s'
            }],
          m: [{
              //m=video 51744 RTP/AVP 126 97 98 34 31
              // NB: special - pushes to session
              // TODO: rtp/fmtp should be filtered by the payloads found here?
              reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
              names: [
                'type',
                'port',
                'protocol',
                'payloads'
              ],
              format: '%s %d %s %s'
            }],
          a: [
            {
              //x-ssrc-range:3408802048-3408802048
              name: 'xSsrcRange',
              reg: /^x-ssrc-range:(\d*)-(\d*)/,
              names: [
                'ssrcMin',
                'ssrcMax'
              ],
              format: 'x-ssrc-range:%d-%d'
            },
            {
              //a=rtcp-fb:98 trr-int 100
              push: 'rtcpFbTrrInt',
              reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
              names: [
                'payload',
                'value'
              ],
              format: 'rtcp-fb:%d trr-int %d'
            },
            {
              //a=rtcp-fb:98 nack rpsi
              push: 'rtcpFb',
              reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
              names: [
                'payload',
                'type',
                'subtype'
              ],
              format: function (o) {
                return o.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s';
              }
            },
            {
              //rtcp-rsize
              name: 'rtcpRsize',
              reg: /^(rtcp-rsize)/,
              format: 'rtcp-rsize'
            },
            {
              // label:main-video (rfc4574)
              name: 'label',
              reg: /^label:(\S*)/,
              format: 'label:%s'
            },
            {
              // x-source:main-video
              name: 'xSource',
              reg: /^x-source:(\S*)/,
              format: 'x-source:%s'
            },
            {
              //a=ice-ufrag:F7gI
              name: 'iceUfrag',
              reg: /^ice-ufrag:(\S*)/,
              format: 'ice-ufrag:%s'
            },
            {
              //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
              name: 'icePwd',
              reg: /^ice-pwd:(\S*)/,
              format: 'ice-pwd:%s'
            },
            {
              //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
              name: 'fingerprint',
              reg: /^fingerprint:(\S*) (\S*)/,
              names: [
                'type',
                'hash'
              ],
              format: 'fingerprint:%s %s'
            },
            {
              //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
              //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0
              //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
              push: 'candidates',
              reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?/,
              names: [
                'foundation',
                'component',
                'transport',
                'priority',
                'ip',
                'port',
                'type',
                'raddr',
                'rport',
                'tcptype',
                'generation'
              ],
              format: function (o) {
                var str = 'candidate:%s %d %s %d %s %d typ %s';
                // NB: candidate has two optional chunks, so %void middle one if it's missing
                str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';
                str += o.tcptype != null ? ' tcptype %s' : '%v';
                if (o.generation != null) {
                  str += ' generation %d';
                }
                return str;
              }
            },
            {
              //a=x-candidate-ipv6:0 1 UDP 2113667327 2001:0:5ef5:79fb:245f:3ec1:3dba:97fb 54400 typ host
              //a=x-candidate-ipv6:1162875081 1 udp 2113937151 2001:0:5ef5:79fb:245f:3ec1:3dba:97fb 60017 typ host generation 0
              //a=x-candidate-ipv6:3289912957 2 udp 1845501695 2001:0:5ef5:79fb:245f:3ec1:3dba:97fb 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
              push: 'xCandidatesIpv6',
              reg: /^x-candidate-ipv6:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?/,
              names: [
                'foundation',
                'component',
                'transport',
                'priority',
                'ip',
                'port',
                'type',
                'raddr',
                'rport',
                'tcptype',
                'generation'
              ],
              format: function (o) {
                var str = 'x-candidate-ipv6:%s %d %s %d %s %d typ %s';
                // NB: candidate has two optional chunks, so %void middle one if it's missing
                str += o.raddr != null ? ' raddr %s rport %d' : '%v%v';
                str += o.tcptype != null ? ' tcptype %s' : '%v';
                if (o.generation != null) {
                  str += ' generation %d';
                }
                return str;
              }
            },
            {
              //a=cryptoscale:1 client AES_CM_128_HMAC_SHA1_80 inline:4CRQeUGzMG/lb4oIMDq4A2J6IeY9AQFD62ic92xs|2^31|1:1
              //a=cryptoscale:1 server AES_CM_128_HMAC_SHA1_80 inline:4CRQeUGzMG/lb4oIMDq4A2J6IeY9AQFD62ic92xs|2^31|1:1
              push: 'cryptoscale',
              reg: /^cryptoscale:(\d*) (client|server) ([\w_]*) (\S*)(?: (\S*))?/,
              names: [
                'id',
                'flavor',
                'suite',
                'config',
                'sessionConfig'
              ],
              format: function (o) {
                return o.sessionConfig != null ? 'cryptoscale:%d %s %s %s %s' : 'cryptoscale:%d %s %s %s';
              }
            },
            {
              //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
              push: 'crypto',
              reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
              names: [
                'id',
                'suite',
                'config',
                'sessionConfig'
              ],
              format: function (o) {
                return o.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s';
              }
            },
            {
              //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
              name: 'remoteCandidates',
              reg: /^remote-candidates:(.*)/,
              format: 'remote-candidates:%s'
            },
            {
              //a=maxptime:60
              name: 'maxptime',
              reg: /^maxptime:(\d*)/,
              format: 'maxptime:%d'
            },
            {
              //a=rtcp:65179 IN IP4 193.84.77.194
              name: 'rtcp',
              reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
              names: [
                'port',
                'netType',
                'ipVer',
                'address'
              ],
              format: function (o) {
                return o.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d';
              }
            },
            {
              //a=rtpmap:110 opus/48000/2
              push: 'rtp',
              reg: /^rtpmap:(\d*) ([\w\-]*)\/(\d*)(?:\s*\/(\S*))?/,
              names: [
                'payload',
                'codec',
                'rate',
                'encoding'
              ],
              format: function (o) {
                return o.encoding ? 'rtpmap:%d %s/%s/%s' : 'rtpmap:%d %s/%s';
              }
            },
            {
              //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
              push: 'fmtp',
              reg: /^fmtp:(\d*) (.*)/,
              names: [
                'payload',
                'config'
              ],
              format: 'fmtp:%d %s'
            },
            {
              //a=rtcp-mux
              name: 'rtcpMux',
              reg: /^(rtcp-mux)/,
              format: 'rtcp-mux'
            },
            {
              //a=ptime:20
              name: 'ptime',
              reg: /^ptime:(\d*)/,
              format: 'ptime:%d'
            },
            {
              //a=control:streamid=0
              name: 'control',
              reg: /^control:(.*)/,
              format: 'control:%s'
            },
            {
              //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
              //a=extmap:1/recvonly URI-gps-string
              push: 'ext',
              reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
              names: [
                'value',
                'uri',
                'config'
              ],
              // value may include "/direction" suffix
              format: function (o) {
                return o.config != null ? 'extmap:%s %s %s' : 'extmap:%s %s';
              }
            },
            {
              //a=setup:actpass
              name: 'setup',
              reg: /^setup:(\w*)/,
              format: 'setup:%s'
            },
            {
              //a=mid:1
              name: 'mid',
              reg: /^mid:(\w*)/,
              format: 'mid:%s'
            },
            {
              //a=sendrecv
              name: 'direction',
              reg: /^(sendrecv|recvonly|sendonly|inactive)/
            },
            {
              //a=ice-lite
              name: 'icelite',
              reg: /^(ice-lite)/
            },
            {
              //a=ice-options:google-ice
              name: 'iceOptions',
              reg: /^ice-options:(\S*)/,
              format: 'ice-options:%s'
            },
            {
              //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
              push: 'ssrcs',
              reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
              names: [
                'id',
                'attribute',
                'value'
              ],
              format: 'ssrc:%d %s:%s'
            },
            {
              //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
              name: 'msidSemantic',
              reg: /^msid-semantic: (\w*) (\S*)/,
              names: [
                'semantic',
                'token'
              ],
              format: 'msid-semantic: %s %s'  // space after ":" is not accidental
            },
            {
              //a=group:BUNDLE audio video
              push: 'groups',
              reg: /^group:(\w*) (.*)/,
              names: [
                'type',
                'mids'
              ],
              format: 'group:%s %s'
            },
            {
              //a=x-mediabw:main-video send=8100;recv=8000
              name: 'xMediaBw',
              reg: /^x-mediabw:(\S*) send=(\d*);recv=(\d*)/,
              names: [
                'label',
                'sendBw',
                'receiveBw'
              ],
              format: 'x-mediabw:%s send=%d;recv=%d'
            },
            {
              // x-caps:121 263:1920:1080:30.0:2000000:1;4359:1280:720:30.0:1500000:1;8455:640:480:30.0:600000:1;12551:640:360:30.0:600000:1;16647:352:288:15.0:250000:1;20743:424:240:15.0:250000:1;24839:176:144:15.0:180000:1
              name: 'xCaps',
              reg: /^x-caps:(\d*) (\S*)/,
              names: [
                'payloadType',
                'value'
              ],
              format: 'x-caps:%d %s'
            },
            {
              // any a= that we don't understand is kepts verbatim on media.invalid
              push: 'invalid',
              names: ['value']
            }
          ]
        };
        // set sensible defaults to avoid polluting the grammar with boring details
        Object.keys(grammar).forEach(function (key) {
          var objs = grammar[key];
          objs.forEach(function (obj) {
            if (!obj.reg) {
              obj.reg = /(.*)/;
            }
            if (!obj.format) {
              obj.format = '%s';
            }
          });
        });
        return exports;
      },
      {}
    ],
    2: [
      function (require, module, exports) {
        var toIntIfInt = function (v) {
          return String(Number(v)) === v ? Number(v) : v;
        };
        var attachProperties = function (match, location, names, rawName) {
          if (rawName && !names) {
            location[rawName] = toIntIfInt(match[1]);
          } else {
            for (var i = 0; i < names.length; i += 1) {
              if (match[i + 1] != null) {
                location[names[i]] = toIntIfInt(match[i + 1]);
              }
            }
          }
        };
        var parseReg = function (obj, location, content) {
          var needsBlank = obj.name && obj.names;
          if (obj.push && !location[obj.push]) {
            location[obj.push] = [];
          } else if (needsBlank && !location[obj.name]) {
            location[obj.name] = {};
          }
          var keyLocation = obj.push ? {} : // blank object that will be pushed
          needsBlank ? location[obj.name] : location;
          // otherwise, named location or root
          attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
          if (obj.push) {
            location[obj.push].push(keyLocation);
          }
        };
        var grammar = require('./grammar');
        var validLine = function (line) {
          return new RegExp(/^([a-z])=(.*)/).test(line);
        };
        exports.parse = function (sdp) {
          var session = {}, media = [], location = session;
          // points at where properties go under (one of the above)
          // parse lines we understand
          sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
            var type = l[0];
            var content = l.slice(2);
            if (type === 'm') {
              media.push({
                rtp: [],
                fmtp: []
              });
              location = media[media.length - 1];  // point at latest media line
            }
            for (var j = 0; j < (grammar[type] || []).length; j += 1) {
              var obj = grammar[type][j];
              if (obj.reg.test(content)) {
                return parseReg(obj, location, content);
              }
            }
          });
          session.media = media;
          // link it up
          return session;
        };
        var fmtpReducer = function (acc, expr) {
          var s = expr.split('=');
          if (s.length === 2) {
            acc[s[0]] = toIntIfInt(s[1]);
          }
          return acc;
        };
        exports.parseFmtpConfig = function (str) {
          return str.split(';').reduce(fmtpReducer, {});
        };
        exports.parsePayloads = function (str) {
          return str.split(' ').map(Number);
        };
        exports.parseRemoteCandidates = function (str) {
          var candidates = [];
          var parts = str.split(' ').map(toIntIfInt);
          for (var i = 0; i < parts.length; i += 3) {
            candidates.push({
              component: parts[i],
              ip: parts[i + 1],
              port: parts[i + 2]
            });
          }
          return candidates;
        };
        return exports;
      },
      { './grammar': 1 }
    ],
    3: [
      function (require, module, exports) {
        var grammar = require('./grammar');
        // customized util.format - discards excess arguments and can void middle ones
        var formatRegExp = /%[sdv%]/g;
        var format = function (formatStr) {
          var i = 1;
          var args = arguments;
          var len = args.length;
          return formatStr.replace(formatRegExp, function (x) {
            if (i >= len) {
              return x;  // missing argument
            }
            var arg = args[i];
            i += 1;
            switch (x) {
            case '%%':
              return '%';
            case '%s':
              return String(arg);
            case '%d':
              return Number(arg);
            case '%v':
              return '';
            }
          });  // NB: we discard excess arguments - they are typically undefined from makeLine
        };
        var makeLine = function (type, obj, location) {
          var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
          var args = [type + '=' + str];
          if (obj.names) {
            for (var i = 0; i < obj.names.length; i += 1) {
              var n = obj.names[i];
              if (obj.name) {
                args.push(location[obj.name][n]);
              } else {
                // for mLine and push attributes
                args.push(location[obj.names[i]]);
              }
            }
          } else {
            args.push(location[obj.name]);
          }
          return format.apply(null, args);
        };
        // RFC specified order
        // TODO: extend this with all the rest
        var defaultOuterOrder = [
          'v',
          'o',
          's',
          'i',
          'u',
          'e',
          'p',
          'c',
          'b',
          't',
          'r',
          'z',
          'a'
        ];
        var defaultInnerOrder = [
          'i',
          'c',
          'b',
          'a'
        ];
        module.exports = function (session, opts) {
          opts = opts || {};
          // ensure certain properties exist
          if (session.version == null) {
            session.version = 0;  // "v=0" must be there (only defined version atm)
          }
          if (session.name == null) {
            session.name = ' ';  // "s= " must be there if no meaningful name set
          }
          session.media.forEach(function (mLine) {
            if (mLine.payloads == null) {
              mLine.payloads = '';
            }
          });
          var outerOrder = opts.outerOrder || defaultOuterOrder;
          var innerOrder = opts.innerOrder || defaultInnerOrder;
          var sdp = [];
          // loop through outerOrder for matching properties on session
          outerOrder.forEach(function (type) {
            grammar[type].forEach(function (obj) {
              if (obj.name in session) {
                sdp.push(makeLine(type, obj, session));
              } else if (obj.push in session) {
                session[obj.push].forEach(function (el) {
                  sdp.push(makeLine(type, obj, el));
                });
              }
            });
          });
          // then for each media line, follow the innerOrder
          session.media.forEach(function (mLine) {
            sdp.push(makeLine('m', grammar.m[0], mLine));
            innerOrder.forEach(function (type) {
              grammar[type].forEach(function (obj) {
                if (obj.name in mLine) {
                  sdp.push(makeLine(type, obj, mLine));
                } else if (obj.push in mLine) {
                  mLine[obj.push].forEach(function (el) {
                    sdp.push(makeLine(type, obj, el));
                  });
                }
              });
            });
          });
          return sdp.join('\r\n') + '\r\n';
        };
        return exports;
      },
      { './grammar': 1 }
    ],
    'sdp-transform': [
      function (require, module, exports) {
        var parser = require('./parser');
        var writer = require('./writer');
        exports.write = writer;
        exports.parse = parser.parse;
        exports.parseFmtpConfig = parser.parseFmtpConfig;
        exports.parsePayloads = parser.parsePayloads;
        exports.parseRemoteCandidates = parser.parseRemoteCandidates;
        return exports;
      },
      {
        './parser': 2,
        './writer': 3
      }
    ]
  }, {}, [])('sdp-transform');
});
helper = function (CONSTANTS, SdpT) {
  function invertDirectionality(directionality) {
    switch (directionality) {
    case CONSTANTS.MEDIA_STATE.send:
      return CONSTANTS.MEDIA_STATE.receive;
    case CONSTANTS.MEDIA_STATE.receive:
      return CONSTANTS.MEDIA_STATE.send;
    default:
      return directionality;
    }
  }
  function invertModalities(modalities) {
    var ret = {};
    var audio = invertDirectionality(modalities.audio);
    if (audio) {
      ret.audio = audio;
    }
    var video = invertDirectionality(modalities.video);
    if (video) {
      ret.video = video;
    }
    return ret;
  }
  function hasSendDirectionality(directionality) {
    return directionality === CONSTANTS.MEDIA_STATE.send || directionality === CONSTANTS.MEDIA_STATE.sendReceive;
  }
  function hasReceiveDirectionality(directionality) {
    return directionality === CONSTANTS.MEDIA_STATE.receive || directionality === CONSTANTS.MEDIA_STATE.sendReceive;
  }
  function negotiateDirectionality(acceptable, local) {
    //computes subset of what acceptable (remote) can do and what local can do
    //local send direction can be seen as what i want to do and local receive direction what i can do
    //acceptable send direction means i can receive and acceptable receive direction that i want to send
    //thus acceptable directions are assumed to be "inverted" if compared to the local direction direction on remote itself
    var canSend = hasSendDirectionality(acceptable) && hasSendDirectionality(local), canReceive = hasReceiveDirectionality(acceptable) && hasReceiveDirectionality(local);
    if (canSend && canReceive) {
      return CONSTANTS.MEDIA_STATE.sendReceive;
    } else if (canSend) {
      return CONSTANTS.MEDIA_STATE.send;
    } else if (canReceive) {
      return CONSTANTS.MEDIA_STATE.receive;
    } else if (acceptable === CONSTANTS.MEDIA_STATE.inactive && local) {
      //call on hold
      return CONSTANTS.MEDIA_STATE.inactive;
    }
    return void 0;  //rejecting
  }
  function negotiateModalities(acceptableModalities, localModalities) {
    //returns subset (downgraded) modalities that are acceptable (remote offers) and local accepts
    //returned modalities are "valid" modalities in the sdp answer
    var ret = {};
    var audio = negotiateDirectionality(acceptableModalities.audio, localModalities.audio);
    if (audio) {
      ret.audio = audio;
    }
    var video = negotiateDirectionality(acceptableModalities.video, localModalities.video);
    if (video) {
      ret.video = video;
    }
    return ret;
  }
  function getModalitiesFromSDP(sdp, includeRejectedModalities) {
    var offerParsed = SdpT.parse(sdp), media, modalities = {
        audio: void 0,
        video: void 0
      };
    for (var i = 0; i < offerParsed.media.length; ++i) {
      media = offerParsed.media[i];
      if (media.port !== 0 || includeRejectedModalities) {
        if (media.type === 'audio') {
          modalities.audio = media.direction || CONSTANTS.MEDIA_STATE.sendReceive;
        } else if (media.type === 'video') {
          modalities.video = media.direction || CONSTANTS.MEDIA_STATE.sendReceive;
        }
      }
    }
    return modalities;
  }
  function areModalitiesEqual(a, b) {
    return !(!a || !b || a.audio !== b.audio || a.video !== b.video);  //iff both are undefined then they are not equal
  }
  function getParameterByName(name, defaultValue) {
    name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
    var regex = new RegExp('[\\?&]' + name + '=([^&#]*)'), results = regex.exec(location.search), value = defaultValue;
    if (results) {
      var strRes = decodeURIComponent(results[1].replace(/\+/g, ' '));
      try {
        // convert "false"-> false "0" -> 0 etc
        value = JSON.parse(strRes);
      } catch (e) {
        value = strRes;
      }
    }
    console.log('getParameterByName', 'name:', name, 'return:', value, 'default:', defaultValue, 'location.search:', window.location.search);
    return value;
  }
  function areNegotiatedDirectionsAcceptable(modalities, negotiatingModalities, negotiatedModalities) {
    //modalities - most recent modalities user wants to have, negotiatingModalities - modalities user had configured when negotiation had to generate offer
    function isNegotiatedDirectionAcceptable(direction, negotiatingDirection, negotiatedDirection) {
      //check user has not turned send or receive direction on during negotiation
      //check that if we don't want to send or receive that we really don't send or receive (for case user has turned send direction off during negotiation)
      var isSendDirectionAcceptable = hasSendDirectionality(direction) && hasSendDirectionality(negotiatingDirection) || !hasSendDirectionality(direction) && !hasSendDirectionality(negotiatedDirection), isReceiveDirectionAcceptable = hasReceiveDirectionality(direction) && hasReceiveDirectionality(negotiatingDirection) || !hasReceiveDirectionality(direction) && !hasReceiveDirectionality(negotiatedDirection);
      return isSendDirectionAcceptable && isReceiveDirectionAcceptable;
    }
    return isNegotiatedDirectionAcceptable(modalities.audio, negotiatingModalities.audio, negotiatedModalities.audio) && isNegotiatedDirectionAcceptable(modalities.video, negotiatingModalities.video, negotiatedModalities.video);
  }
  function areNegotiatedDirectionsFulfilled(modalities, negotiatedModalities) {
    function isNegotiatedDirectionFulfilled(direction, negotiatedDirection) {
      var isSendDirectionFulfilled = hasSendDirectionality(direction) === hasSendDirectionality(negotiatedDirection), isReceiveDirectionFulfilled = hasReceiveDirectionality(direction) === hasReceiveDirectionality(negotiatedDirection);
      return isSendDirectionFulfilled && isReceiveDirectionFulfilled;
    }
    return isNegotiatedDirectionFulfilled(modalities.audio, negotiatedModalities.audio) && isNegotiatedDirectionFulfilled(modalities.video, negotiatedModalities.video);
  }
  function shallowClone(obj) {
    var copy = {};
    for (var attr in obj) {
      if (obj.hasOwnProperty(attr)) {
        copy[attr] = obj[attr];
      }
    }
    return copy;
  }
  function isMsBrowser() {
    return typeof RTCIceGatherer !== 'undefined';
  }
  function defer() {
    var resolve, reject, isPending = true, promise = new Promise(function (resolve_, reject_) {
        resolve = resolve_;
        reject = reject_;
      });
    return {
      isPending: function () {
        return isPending;
      },
      promise: promise,
      resolve: function () {
        if (isPending) {
          resolve.apply(null, arguments);
          isPending = false;
        }
      },
      reject: function () {
        if (isPending) {
          reject.apply(null, arguments);
          isPending = false;
        }
      }
    };
  }
  function delay(time) {
    return new Promise(function (fulfill) {
      setTimeout(fulfill, time);
    });
  }
  function timeout(promise, time, promiseName) {
    return new Promise(function (resolve, reject) {
      resolve(promise);
      setTimeout(reject.bind(null, new Error('Promise timed out' + (promiseName ? ': ' + promiseName : '') + 'after ' + time + 'ms')), time);
    });
  }
  return {
    invertDirectionality: invertDirectionality,
    invertModalities: invertModalities,
    hasSendDirectionality: hasSendDirectionality,
    hasReceiveDirectionality: hasReceiveDirectionality,
    negotiateDirectionality: negotiateDirectionality,
    negotiateModalities: negotiateModalities,
    getModalitiesFromSDP: getModalitiesFromSDP,
    areModalitiesEqual: areModalitiesEqual,
    getParameterByName: getParameterByName,
    areNegotiatedDirectionsFulfilled: areNegotiatedDirectionsFulfilled,
    areNegotiatedDirectionsAcceptable: areNegotiatedDirectionsAcceptable,
    shallowClone: shallowClone,
    isMsBrowser: isMsBrowser,
    defer: defer,
    delay: delay,
    timeout: timeout
  };
}(constants, vendorSdpTransform);
msSdpTransform = function () {
  function _toMsSdp(sdp, context) {
    sdp.media.forEach(function (media) {
      var i;
      media.protocol = 'RTP/SAVP';
      if (media.port === 0) {
        return;
      }
      if (media.ssrcs && media.ssrcs[0]) {
        // add x-ssrc-range attribute
        media.xSsrcRange = {
          ssrcMin: media.ssrcs[0].id,
          ssrcMax: media.ssrcs[0].id
        };
        // remove ssrc attribute
        media.ssrcs = [];
      }
      // only remove http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time extension
      if (media.ext) {
        for (i = media.ext.length - 1; i >= 0; --i) {
          if (media.ext[i].uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time') {
            media.ext.splice(i, 1);
          }
        }
      }
      if (media.crypto) {
        // append |2^31 to the crypto attributes
        media.crypto.forEach(function (crypto) {
          crypto.config += '|2^31';
        });
      }
      // DTLS-SRTP
      // Firefox uses a session level fingerprint attribute, normalize it to media level
      if (sdp.fingerprint) {
        media.fingerprint = sdp.fingerprint;
      }
      if (media.fingerprint) {
        // remove setup:actpass attribute from all offers for compatibility with legacy clients
        if (_isOffer(context)) {
          delete media.setup;
        }
      }
      if (media.candidates) {
        var rtcpPort;
        for (i = media.candidates.length - 1; i >= 0; --i) {
          var candidate = media.candidates[i];
          // remove candidates which have same foundation and component..
          var removed = false;
          for (var j = i - 1; j >= 0; --j) {
            if (media.candidates[i].foundation === media.candidates[j].foundation && media.candidates[i].component === media.candidates[j].component) {
              media.candidates.splice(i, 1);
              removed = true;
              break;
            }
          }
          if (removed) {
            continue;
          }
          // move ipv6 candidate to x-candidate-ipv6 attribute
          if (candidate.ip.indexOf(':') !== -1) {
            /*
            media.xCandidatesIpv6 = media.xCandidatesIpv6 || [];
            media.xCandidatesIpv6.push(candidate);
            media.candidates.splice(i, 1);
            */
            continue;
          }
          if (candidate.type === 'host') {
            if (candidate.component === 1) {
              // replace the IP address field with the correct IP address in the following attribute lines, o=...., c=...., a:rtcp:.....
              sdp.origin.address = candidate.ip;
              media.connection.ip = candidate.ip;
              if (media.rtcp) {
                media.rtcp.address = candidate.ip;
              }
              // replace the port field in media line (m=......) with the correct port.
              media.port = candidate.port;
            } else {
              rtcpPort = candidate.port;
            }
          }
        }
        // sort candidates by foundation to make MP happy
        media.candidates.sort(function (a, b) {
          if (a.foundation === b.foundation) {
            return a.component - b.component;
          }
          return a.foundation - b.foundation;
        });
        // replace the port field in the a=rtcp.... attribute with the correct port
        if (media.rtcp) {
          media.rtcp.port = rtcpPort || media.port;
        }
      }
      if (media.type === 'audio') {
        // move the connection line (c=.....) to session level
        sdp.connection = media.connection;
      }
      // remove media level connection line
      delete media.connection;
      // remove msid attribute, unsupported by current version sdp-transform, will be removed by the following statement instead
      delete media.msid;
      // delete all invalid attributes
      delete media.invalid;
    });
    // remove session level fingerprint attribute
    delete sdp.fingerprint;
    if (context.addRejectedVideo) {
      sdp.media.push({
        type: 'video',
        protocol: 'RTP/SAVP',
        port: 0,
        payloads: '34'
      });
    }
    return sdp;
  }
  function _fromMsSdp(sdp, context) {
    for (var mi = sdp.media.length - 1; mi >= 0; --mi) {
      var media = sdp.media[mi];
      // remove video completely
      if (media.type === 'video') {
        sdp.media.splice(mi, 1);
        continue;
      }
      media.protocol = 'RTP/SAVPF';
      if (media.port === 0) {
        continue;
      }
      // we need to generate and preserve cnames and msids across re-negotiations for proper interop
      media.ssrcs = [];
      media.ssrcs.push({
        attribute: 'cname',
        id: media.xSsrcRange.ssrcMin,
        value: 'ZXVf3drwG3fT+Wh5'
      });
      media.ssrcs.push({
        attribute: 'msid',
        id: media.xSsrcRange.ssrcMin,
        value: 'esGl63EerPyTHNZK4HwO9DwHSgurO6Hjy1kF e031115a-4177-4830-bc2a-1fe17a418c07'
      });
      delete media.cryptoscale;
      // DTLS-SRTP
      if (media.fingerprint) {
        // WebRTC.org stack requires all offers to have a setup:actpass attribute. Neither RFC5763 nor Firefox
        // WebRTC stack have such a requirement, however, to keep things simple, we will always replace whatever
        // offer has with setup:actpass.
        if (_isOffer(context)) {
          media.setup = 'actpass';
        }
      }
      if (media.crypto) {
        for (var i = media.crypto.length - 1; i >= 0; --i) {
          var crypto = media.crypto[i];
          // allowing only those crypto attribute lines with no MKI field
          if (crypto.config.match(/.*\|\d+:\d+/)) {
            media.crypto.splice(i, 1);
            continue;
          }
          // ripping of the lifetime value of 2^31 from the line
          crypto.config = crypto.config.replace(/(.*)\|2\^\d+/, '$1');
        }
      }
      if (media.candidates) {
        for (var j = media.candidates.length - 1; j >= 0; --j) {
          var candidate = media.candidates[j];
          // change tcp-act, tcp-pass and tcp-so to tcp
          if (candidate.transport.match(/tcp-/i)) {
            candidate.transport = 'tcp';
          }
        }
      }
      if (media.xCandidatesIpv6) {
        media.candidates = media.candidates || [];
        for (var c = 0; c < media.xCandidatesIpv6.length; ++c) {
          media.candidates.push(media.xCandidatesIpv6[c]);
        }
        delete media.xCandidatesIpv6;
      }
    }
    return sdp;
  }
  function _isOffer(context) {
    return 'offer' === context.type;
  }
  return {
    toMsSdp: _toMsSdp,
    fromMsSdp: _fromMsSdp
  };
}();
webRtcSessionDescription = function (CONSTANTS, helper, SdpT, msSdpT) {
  function SessionDescription(context, sdp, type) {
    var settings = context.settings, model = SdpT.parse(sdp), medias;
    this.getMedias = function () {
      return _getModalitiesFromSDP(model);
    };
    this.toOffer = function () {
      if (!settings.disableMsSdp) {
        msSdpT.toMsSdp(model, {
          type: 'offer',
          addRejectedVideo: context.msSdpAddRejectedVideo
        });
      }
      if (_shouldFilterCandidates()) {
        _filterCandidates(model);
      }
      return SdpT.write(model);
    };
    this.toAnswer = function () {
      if (!settings.disableMsSdp) {
        msSdpT.toMsSdp(model, {
          type: 'answer',
          addRejectedVideo: context.msSdpAddRejectedVideo
        });
      }
      if (_shouldFilterCandidates()) {
        _filterCandidates(model);
      }
      return SdpT.write(model);
    };
    this.toLocal = function () {
      return SdpT.write(model);
    };
    this.toRemote = function () {
      if ('offer' === type) {
        if (!settings.disableMsSdp) {
          // NB this removes video modality completely. Therefore we need to remember if there was a rejected video and add it back in creteAnswer
          context.msSdpAddRejectedVideo = !!_getModalitiesFromSDP(model, true).video;
          msSdpT.fromMsSdp(model, { type: 'offer' });
        }
        return SdpT.write(model);
      }
      if (!settings.disableMsSdp) {
        // NB this removes video modality completely
        msSdpT.fromMsSdp(model, { type: 'answer' });
      }
      return SdpT.write(model);
    };
    this.setMedias = function (newMedias) {
      medias = newMedias;
      // make modification in sdp based on current modalities. This is done since peerconnection can't figure out correct modality by itself
      // but we want on protocol level it to be correct. Seems to have no effect on peerconnection behavior actually
      _fixupMedias(model, medias);
    };
    this.update = function (newSdp) {
      model = SdpT.parse(newSdp);
      if (medias) {
        _fixupMedias(model, medias);
      }
    };
    function _shouldFilterCandidates() {
      return settings.iceCandidateType || settings.iceCandidateTransport;
    }
    function _filterCandidates() {
      var filter = function (candidates) {
        return candidates.filter(function (candidate) {
          var candidateL = candidate.candidate.toLowerCase();
          var typeOk = true;
          var transpOk = true;
          // TODO: update sdp-transform version to support candidate parsing
          if (settings.iceCandidateType === 'relay') {
            typeOk = candidateL.indexOf('typ relay') !== -1;
          } else if (settings.iceCandidateType === 'direct') {
            typeOk = candidateL.indexOf('typ relay') === -1;
          }
          if (settings.iceCandidateTransport) {
            transpOk = candidateL.indexOf(settings.iceCandidateTransport) !== -1;
          }
          return typeOk && transpOk;
        });
      };
      model.media.forEach(function (media) {
        media.candidates = filter(media.candidates);
      });
    }
  }
  function _getModalitiesFromSDP(model, includeRejectedModalities) {
    var media, modalities = {
        audio: void 0,
        video: void 0
      };
    for (var i = 0; i < model.media.length; ++i) {
      media = model.media[i];
      if (media.port !== 0 || includeRejectedModalities) {
        if (media.type === 'audio') {
          modalities.audio = media.direction || CONSTANTS.MEDIA_STATE.sendReceive;
        } else if (media.type === 'video') {
          modalities.video = media.direction || CONSTANTS.MEDIA_STATE.sendReceive;
        }
      }
    }
    return modalities;
  }
  function _fixupMedias(model, actualModalities) {
    var fixupMedia = function (type, sdpMedia, actualModalities) {
      // modality removed - make sure port is 0
      if (!actualModalities[type]) {
        if (sdpMedia.port !== 0) {
          //_logger.warn('fixupOffer port => 0', 'type:', type, 'oldport:', sdpMedia.port);
          sdpMedia.port = 0;
        }
        for (var prop in sdpMedia) {
          // FF wants to have connection and direction attributes for disabled m-lines
          if (sdpMedia.hasOwnProperty(prop) && [
              'type',
              'video',
              'port',
              'protocol',
              'payloads',
              'connection',
              'direction'
            ].indexOf(prop) < 0) {
            delete sdpMedia[prop];
          }
        }
      }
      // sendonly modality - make sure media direction is actually sendonly
      if (actualModalities[type] === CONSTANTS.MEDIA_STATE.send) {
        if (sdpMedia.direction.toLowerCase() !== 'sendonly') {
          //_logger.warn('fixupOffer direction => sendonly', 'type:', type, 'olddirection:', sdpMedia.direction);
          sdpMedia.direction = 'sendonly';
        }
      }
      // modality inactive - make sure direction is inactive
      if (actualModalities[type] === CONSTANTS.MEDIA_STATE.inactive) {
        if (sdpMedia.direction.toLowerCase() !== 'inactive') {
          //_logger.warn('fixupOffer direction => inactive', 'type:', type, 'olddirection:', sdpMedia.direction);
          sdpMedia.direction = 'inactive';
        }
      }
    };
    for (var i = 0; i < model.media.length; i++) {
      if (model.media[i].type === 'audio') {
        fixupMedia('audio', model.media[i], actualModalities);
      } else if (model.media[i].type === 'video') {
        fixupMedia('video', model.media[i], actualModalities);
      }
    }
  }
  return {
    build: function (context) {
      context = context || {};
      return {
        createOffer: function (sdp) {
          return new SessionDescription(context, sdp, 'offer');
        },
        createAnswer: function (sdp) {
          return new SessionDescription(context, sdp, 'answer');
        }
      };
    }
  };
}(constants, helper, vendorSdpTransform, msSdpTransform);
userAgentAdapter = function () {
  window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
  window.MediaStream = window.MediaStream || window.webkitMediaStream || window.mozMediaStream || window.msMediaStream;
  function patchGetUserMediaConstraintsForModality(constraints) {
    if (constraints.deviceId && constraints.deviceId.exact) {
      if (!constraints.optional) {
        constraints.optional = [];
      }
      constraints.optional.push({ sourceId: constraints.deviceId.exact });
      delete constraints.deviceId;
    }
  }
  function patchGetUserMediaConstraints(constraints) {
    if (constraints) {
      if (constraints.audio) {
        patchGetUserMediaConstraintsForModality(constraints.audio);
      }
      if (constraints.video) {
        patchGetUserMediaConstraintsForModality(constraints.video);
      }
    }
  }
  window.attachMediaStream = function (elem, mediaStream) {
    if (typeof elem.srcObject !== 'undefined') {
      elem.srcObject = mediaStream;
    } else if (typeof elem.src !== 'undefined') {
      elem.src = window.URL.createObjectURL(mediaStream);
    }
  };
  window.detachMediaStream = function (elem) {
    if (typeof elem.srcObject !== 'undefined') {
      elem.srcObject = null;
    } else if (typeof elem.src !== 'undefined') {
      if (elem.src) {
        var oldSrc = elem.src;
        elem.src = '';
        //TreatNullAs=EmptyString] is not set
        window.URL.revokeObjectURL(oldSrc);  //maybe we dont need to revoke url...
      }
    }
  };
  window.stopMediaStream = function (mediaStream) {
    // NOTE: mediaStream.stop has been deprecated
    var tracks = mediaStream.getTracks();
    for (var i = 0; i < tracks.length; ++i) {
      var track = tracks[i];
      // NOTE: mediaTrack.stop is supported by all latest browsers now 2015-08-18
      track.stop();
    }
  };
  if (navigator.mozGetUserMedia) {
    console.log('WebRTC on Firefox');
    window.RTCPeerConnection = mozRTCPeerConnection;
    //window.RTCIceCandidate = mozRTCIceCandidate;
    window.RTCSessionDescription = mozRTCSessionDescription;
    navigator.getUserMedia = function (constraints, onSuccess, onFail) {
      patchGetUserMediaConstraints(constraints);
      return navigator.mozGetUserMedia(constraints, onSuccess, onFail);
    };
  } else if (navigator.webkitGetUserMedia) {
    console.log('WebRTC on Chrome');
    window.RTCPeerConnection = webkitRTCPeerConnection;
    navigator.getUserMedia = function (constraints, onSuccess, onFail) {
      patchGetUserMediaConstraints(constraints);
      return navigator.webkitGetUserMedia(constraints, onSuccess, onFail);
    };
  }
  if (typeof RTCIceGatherer !== 'undefined') {
    // older versions of Microsoft Edge don't have getStats implemented
    var getStats = function () {
      return Promise.resolve();
    };
    if (!RTCRtpSender.prototype.getStats) {
      RTCRtpSender.prototype.getStats = getStats;
    }
    if (!RTCRtpSender.prototype.msGetStats) {
      RTCRtpSender.prototype.msGetStats = getStats;
    }
    if (!RTCRtpReceiver.prototype.getStats) {
      RTCRtpReceiver.prototype.getStats = getStats;
    }
    if (!RTCRtpReceiver.prototype.msGetStats) {
      RTCRtpReceiver.prototype.msGetStats = getStats;
    }
    if (!RTCIceTransport.prototype.getStats) {
      RTCIceTransport.prototype.getStats = getStats;
    }
    if (!RTCIceTransport.prototype.msGetStats) {
      RTCIceTransport.prototype.msGetStats = getStats;
    }
    // same applies to contributing sources
    if (!RTCRtpReceiver.prototype.getContributingSources) {
      RTCRtpReceiver.prototype.getContributingSources = function () {
        return [];
      };
    }
    // as well as requestSendCSRC
    if (!RTCRtpReceiver.prototype.requestSendCSRC) {
      RTCRtpReceiver.prototype.requestSendCSRC = function () {
      };
    }
  }
}();
webRtcSession = function (CONSTANTS, helper, sessionDescription) {
  var WebRtcSession = function (_context, _callId, _callback) {
    this.configureModalitiesAsync = _configureModalitiesAsync;
    this.createOfferAsync = _createOffer;
    this.processOfferAsync = _processOffer;
    this.createAnswerAsync = _createAnswer;
    this.processAnswerAsync = _processAnswer;
    this.completeNegotiationAsync = _completeNegotiationAsync;
    this.rejectNegotiationAsync = _rejectNegotiationAsync;
    this.createRemoteRenderer = _createRemoteRenderer;
    this.getStatsAsync = _getStatsAsync;
    this.terminate = _terminate;
    this._deviceSelectionChanged = _deviceSelectionChanged;
    this._onTerminated = null;
    var _that = this;
    var _settings = _context.maContext.settings;
    var _logger = _context.getLogger();
    var _deviceManager = _context.getDeviceManager();
    var _sessionDescription = sessionDescription.build({ settings: _settings });
    var _peerConnection = null;
    var _peerConnectionPromise;
    var _recvVideoStream = null;
    //contains tracks for video and optionally for audio
    var _recvAudioOnlyStream = null;
    //contains only audio tracks
    var _audio = null;
    //html audio element, does not have to be in dom
    var _sendStreamRef = null;
    var _subscribedRenderers = [];
    var _iceCandidatesDeferred = helper.defer();
    var _canTriggerRenegotiation = true;
    var _forceMediaStreamUpdate = false;
    var _negotiatedModalities = {};
    var _offeredModalities;
    //on offerer this is snapshot of the configured modalities, on answerer what offerer offered
    var _configuredModalities;
    //most recently configured modalities
    var _negotiatingModalities;
    //snapshot of _configuredModalities when offer is created, used to detect cases where user configures different modalities during a renegotiation
    var _failNextOffer = false;
    var _suppressLocalFailure = false;
    //local failures are treated by default as "final" but sometimes we want to alter that behaviour...
    var _iceDisconnectedTimeoutMs = 10000;
    // how many ms to wait before triggering error when ICE state went to disconnected
    var _iceDisconnectedTimer = null;
    function _raiseError(mediaError) {
      _logger.error('Media error occurred', 'type:', mediaError.type, 'detail:', mediaError.detail);
      _callback.onSessionErrorOccurred(mediaError);
    }
    function _startSubscribedRenderers(stream) {
      //it is safe to call this function when we are already rendering video and need to change the stream only
      _recvVideoStream = stream;
      _subscribedRenderers.forEach(function (renderer) {
        renderer._updateStream();
      });
    }
    function _stopSubscribedRenderers(stream) {
      if (!!_recvVideoStream && stream === _recvVideoStream) {
        _recvVideoStream = null;
        _subscribedRenderers.forEach(function (renderer) {
          renderer._updateStream();  //note this will remove video element from the div!
        });
      }
    }
    function _unsubscribeRenderers() {
      _subscribedRenderers.forEach(function (renderer) {
        renderer._unsubscribeIfSubscribed();
      });
    }
    function _startAudio(stream) {
      //it is safe to call this function when we are already playing audio and need to change the stream only
      if (!_audio) {
        _audio = document.createElement('audio');
        document.body.appendChild(_audio);
        _audio.autoplay = true;
        _audio.addEventListener('error', function () {
          _logger.error('_audio.onerror', 'error:', _audio ? _audio.error : '<no audio element>');
        });
      } else {
        window.detachMediaStream(_audio);
      }
      window.attachMediaStream(_audio, stream);
      _recvAudioOnlyStream = stream;
    }
    function _stopAudio(stream) {
      if (!!_recvAudioOnlyStream && stream === _recvAudioOnlyStream) {
        if (_audio) {
          document.body.removeChild(_audio);
          window.detachMediaStream(_audio);
          _audio = null;
        }
        _recvAudioOnlyStream = null;
      }
    }
    function _resetPeerConnection() {
      _logger.log('reset peer connection');
      _stopSubscribedRenderers(_recvVideoStream);
      _stopAudio(_recvAudioOnlyStream);
      if (_peerConnection) {
        _peerConnection.close();
      }
      if (_sendStreamRef) {
        _sendStreamRef.dispose();
        _sendStreamRef = null;
      }
      _peerConnection = null;
      _peerConnectionPromise = null;
      _iceCandidatesDeferred = helper.defer();
      _canTriggerRenegotiation = true;
      _negotiatedModalities = {};
    }
    function _startIceDisconnectedTimer() {
      _iceDisconnectedTimer = setTimeout(function () {
        _logger.error('ice disconnected for ', _iceDisconnectedTimeoutMs, 'ms. Raise CONSTANTS.MEDIA_ERROR.iceConnectionError');
        _raiseError({
          type: CONSTANTS.MEDIA_ERROR.iceConnectionError,
          detail: 'iceConnectionState disconnected'
        });
      }, _iceDisconnectedTimeoutMs);
    }
    function _clearIceDisconnectedTimer() {
      if (_iceDisconnectedTimer) {
        clearTimeout(_iceDisconnectedTimer);
        _iceDisconnectedTimer = null;
      }
    }
    function _createIceServers(relays) {
      return relays.reduce(function (arr, relay) {
        relay.addresses.map(function (address) {
          function _createIceServer(port, transport) {
            return {
              urls: relay.type + ':' + address + ':' + port + (transport ? '?transport=' + transport : ''),
              credential: relay.password,
              username: relay.username
            };
          }
          if (relay.udpPort === relay.tcpPort) {
            arr.push(_createIceServer(relay.udpPort));
          } else {
            arr.push(_createIceServer(relay.udpPort, 'udp'));
            arr.push(_createIceServer(relay.tcpPort, 'tcp'));
          }
        });
        return arr;
      }, []);
    }
    function _assurePeerConnectionAsync() {
      if (!_peerConnectionPromise) {
        _peerConnectionPromise = _context.maContext.getRelayManager().queryRelaysAsync('turn', _context.config.isRemoteClientLync).then(function (relays) {
          var optional = {};
          _logger.log('create peer connection');
          if (_settings.sdes) {
            _logger.log('configuring peer connection to use SDES');
            optional.optional = [{ DtlsSrtpKeyAgreement: false }];
          }
          _peerConnection = new RTCPeerConnection({ iceServers: _createIceServers(relays) }, optional);
          _peerConnection.onnegotiationneeded = function (event) {
            var pc = event.target;
            _logger.log('onnegotiationneeded', 'signalingState:', pc.signalingState);  //we could _triggerRenegotiation but then we need to be sure user has called configureModalities before...
          };
          _peerConnection.onsignalingstatechange = function (event) {
            var pc = event.target;
            _logger.log('onsignalingstatechange', 'signalingState:', pc.signalingState);
          };
          _peerConnection.onaddstream = function (event) {
            //note on chrome onstream added for new stream can happen before previous one is removed
            _logger.log('onaddstream', 'stream:', event.stream);
            if (event.stream.getVideoTracks().length > 0) {
              _startSubscribedRenderers(event.stream);
            } else {
              _startAudio(event.stream);
            }
          };
          _peerConnection.ontrack = function (event) {
            _logger.log('ontrack', 'track:', event.track);  //....
          };
          _peerConnection.onremovestream = function (event) {
            _logger.log('onremovestream', 'stream:', event.stream);
            _stopSubscribedRenderers(event.stream);
            //only stops renderers those were started with same stream
            _stopAudio(event.stream);  //only stops if this was the stream to start audio
          };
          _peerConnection.onicecandidate = function (event) {
            //var pc = event.target;
            _logger.log('onicecandidate', 'candidate:', event.candidate);
            if (!event.candidate) {
              _iceCandidatesDeferred.resolve();
            }
          };
          _peerConnection.onicegatheringstatechange = function (event) {
            var pc = event.target;
            _logger.log('onicegatheringstatechange', 'iceGatheringState:', pc.iceGatheringState);
          };
          _peerConnection.oniceconnectionstatechange = function (event) {
            var pc = event.target;
            _logger.log('oniceconnectionstatechange', 'iceConnectionState:', pc.iceConnectionState, 'pc.signalingState:', pc.signalingState);
            if (pc.iceConnectionState === 'failed') {
              _raiseError({
                type: CONSTANTS.MEDIA_ERROR.iceConnectionError,
                detail: 'iceConnectionState failed'
              });
            }
            if (pc.iceConnectionState === 'disconnected') {
              _startIceDisconnectedTimer();
            } else {
              _clearIceDisconnectedTimer();
            }
          };
        });
      }
      return _peerConnectionPromise;
    }
    //make async functions, we could use some utility wrappers to help to reduce wrapping code, but for now it seems easier to debug if we can put breakpoints directly to the wrapper code
    function _pcCreateAnswerAsync() {
      return new Promise(function (resolve, reject) {
        _peerConnection.createAnswer(resolve, reject);
      });
    }
    function _pcCreateOfferAsync(constraints) {
      return new Promise(function (resolve, reject) {
        _peerConnection.createOffer(resolve, reject, constraints);
      });
    }
    function _pcSetLocalDescriptionAsync(answer) {
      return new Promise(function (resolve, reject) {
        _peerConnection.setLocalDescription(answer, resolve, reject);
      });
    }
    function _pcSetRemoteDescriptionAsync(description) {
      return new Promise(function (resolve, reject) {
        _peerConnection.setRemoteDescription(description, resolve, reject);
      });
    }
    function _throwIfModalitiesNotConfigured(message) {
      if (!_configuredModalities) {
        throw new Error(message);
      }
    }
    function _createNegotiationConstraints(modalities) {
      //add parameter here for offer/answer differentiation when needed
      function canReceive(direction) {
        //on case inactive ask offer and answer to contain receive direction Here is current behaviour on chrome
        //Even there are no media streams added to peer connection offer still contains modality with
        //send only direction! if we put canReceive then offer contains receive only on both cases we would have _fixupSDP
        //that would make direction to inactive. Now on the answerer side there is another side effect:
        //if offer has inactive direction and we dont have canReceive and no streams in peer connection then
        //the answer would have modality disabled, but if we put canReceive to answer options then the negotiated
        //modality would not be disabled and would stay inactive!
        //Have not investigated fully how this is in firefox!
        return !!direction && (helper.hasReceiveDirectionality(direction) || direction === 'inactive');
      }
      return {
        offerToReceiveAudio: canReceive(modalities.audio) ? 1 : 0,
        offerToReceiveVideo: canReceive(modalities.video) ? 1 : 0
      };
    }
    function _triggerRenegotiation() {
      if (_canTriggerRenegotiation && !_failNextOffer) {
        _canTriggerRenegotiation = false;
        _logger.log('trigger (re)negotiation');
        _callback.onNegotiationRequired();
      }
    }
    function _configureModalitiesAsync(modalities) {
      return new Promise(function (resolve) {
        var needNewRenegotiation = !helper.areNegotiatedDirectionsFulfilled(modalities, _negotiatedModalities);
        _configuredModalities = modalities;
        //assign always as if negotiated already confirms to desired but current configured is different (other side did not want to receive)
        _logger.log('configure modalities', 'audio:', modalities.audio, 'video:', modalities.video, 'peerconnection:', !!_peerConnection, 'pc.signalingState:', !!_peerConnection ? _peerConnection.signalingState : '-', 'needNewRenegotiation:', needNewRenegotiation);
        if (needNewRenegotiation) {
          _triggerRenegotiation();  //NB! if we ant to _triggerRenegotiation also from onnegotiationneeded then in here we could check for stable peer connection state also
        }
        resolve();
      });
    }
    function _updatePeerConnectionStreamsAsync(modalities) {
      var isSendingAudio = helper.hasSendDirectionality(_negotiatedModalities.audio), isSendingVideo = helper.hasSendDirectionality(_negotiatedModalities.video), wantSendAudio = helper.hasSendDirectionality(modalities.audio), wantSendVideo = helper.hasSendDirectionality(modalities.video);
      return _assurePeerConnectionAsync().then(function () {
        // stream constraints changed
        if (isSendingAudio !== wantSendAudio || isSendingVideo !== wantSendVideo || _forceMediaStreamUpdate) {
          _forceMediaStreamUpdate = false;
          if (!_peerConnection.addTrack) {
            var removeStream = function () {
              if (_sendStreamRef) {
                try {
                  var mediaStream = _sendStreamRef.getObject();
                  _logger.log('remove media stream', 'audio tracks:', mediaStream.getAudioTracks(), 'video tracks:', mediaStream.getVideoTracks());
                  //todo: maybe swallow exception while removing a stream
                  _peerConnection.removeStream(mediaStream);
                } finally {
                  _sendStreamRef.dispose();
                  //note: current implementation stops all tracks when last ref is dropped
                  _sendStreamRef = null;
                }
              }
            };
            if (wantSendAudio || wantSendVideo) {
              return _deviceManager.getMediaStreamRefAsync({
                audio: wantSendAudio,
                video: wantSendVideo
              }).then(function (streamRef) {
                try {
                  var mediaStream = streamRef.getObject();
                  _logger.log('received media(stream api) tracks', 'wantSendAudio:', wantSendAudio, 'wantSendVideo:', wantSendVideo);
                  removeStream();
                  _logger.log('add media stream', 'audio tracks:', mediaStream.getAudioTracks(), 'video tracks:', mediaStream.getVideoTracks());
                  _peerConnection.addStream(mediaStream);
                  _sendStreamRef = streamRef;
                } catch (error) {
                  try {
                    removeStream();
                  } finally {
                    streamRef.dispose();
                  }
                  throw error;
                }
              });
            } else {
              _logger.log('not using any media(stream api) track, remove stream');
              removeStream();
            }
          } else {
            var removeTracks = function () {
              if (_sendStreamRef) {
                try {
                  _peerConnection.getSenders().forEach(function (sender) {
                    _logger.log('remove sender', 'track kind:', sender.track.kind, 'track id:', sender.track.id);
                    // FIXME swallow exception while removing a track, due to
                    // a Mozilla bug when removing tracks when negotiation state is not stable : https://bugzilla.mozilla.org/show_bug.cgi?id=1133874
                    _peerConnection.removeTrack(sender);
                  });
                } catch (e) {
                  _logger.warn('removeTrack returned error(maybe the mozilla bug, check code for comment)', e);
                } finally {
                  _sendStreamRef.dispose();
                  //note: current implementation stops all tracks when last ref is dropped
                  _sendStreamRef = null;
                }
              }
            };
            if (wantSendAudio || wantSendVideo) {
              return _deviceManager.getMediaStreamRefAsync({
                audio: wantSendAudio,
                video: wantSendVideo
              }).then(function (streamRef) {
                try {
                  _logger.log('received media(track api) tracks', 'wantSendAudio:', wantSendAudio, 'wantSendVideo:', wantSendVideo);
                  removeTracks();
                  streamRef.getObject().getTracks().forEach(function (track) {
                    _logger.log('add stream', 'track kind:', track.kind, 'track id:', track.id);
                    _peerConnection.addTrack(track, streamRef.getObject());
                  });
                  _sendStreamRef = streamRef;
                } catch (error) {
                  try {
                    removeTracks();
                  } finally {
                    streamRef.dispose();
                  }
                  throw error;
                }
              });
            } else {
              _logger.log('not using any media(track api) track, remove all senders');
              removeTracks();
            }
          }
        }
      });
    }
    function _throwIfFailureIsPendingForOffer() {
      if (_failNextOffer) {
        _failNextOffer = false;
        _suppressLocalFailure = true;
        //when renegotiation is rejected we dont want to mark it completed
        throw new Error('fail offer as previous GLARE invalidated pc state!');
      }
    }
    function _createOffer() {
      return new Promise(function (resolve) {
        var description;
        _logger.log('create [offer] configured:', _configuredModalities);
        _throwIfModalitiesNotConfigured('no configured modalities to create offer for');
        _canTriggerRenegotiation = false;
        _negotiatingModalities = _configuredModalities;
        //take snapshot of _configuredModalities
        _offeredModalities = _configuredModalities;
        //we offer what has been configured
        // in case of msSdp, we do not support video at all
        if (!_settings.disableMsSdp) {
          _offeredModalities.video = void 0;
        }
        resolve(_updatePeerConnectionStreamsAsync(_offeredModalities).then(function () {
          var constraints = _createNegotiationConstraints(_offeredModalities);
          _logger.log('[offer]', 'offered:', _offeredModalities, 'constraints:', constraints);
          return _pcCreateOfferAsync(constraints);
        }).then(function (offer) {
          _logger.debug('offer from peer connection', 'sdp:', offer.sdp);
          _logger.log('[offer] created, collect ice candidates and set local description');
          description = _sessionDescription.createOffer(offer.sdp);
          description.setMedias(_offeredModalities);
          // setLocalDescription is what will start ICE candidate gathering
          return Promise.all([
            _pcSetLocalDescriptionAsync(new RTCSessionDescription({
              sdp: description.toLocal(),
              type: 'offer'
            })),
            _iceCandidatesDeferred.promise
          ]);
        }).then(function () {
          description.update(_peerConnection.localDescription.sdp);
          var offer = description.toOffer();
          _logger.debug('CREATE OFFER', 'sdp:', offer);
          return offer;
        }));
      });
    }
    function _processOffer(offer) {
      var description;
      return new Promise(function (resolve) {
        _logger.debug('process [offer]', 'sdp:', offer);
        description = _sessionDescription.createOffer(offer);
        _canTriggerRenegotiation = false;
        _offeredModalities = helper.invertModalities(description.getMedias());
        _logger.log('process [offer]', 'offered:', _offeredModalities);
        _throwIfFailureIsPendingForOffer();
        resolve(_assurePeerConnectionAsync());
      }).then(function () {
        return _pcSetRemoteDescriptionAsync(new RTCSessionDescription({
          sdp: description.toRemote(),
          type: 'offer'
        }));
      }).then(function () {
        return _offeredModalities;
      });
    }
    function _createAnswer(provisional) {
      return new Promise(function (resolve) {
        if (provisional) {
          resolve('');
        } else {
          _logger.log('create [answer]', 'offered:', _offeredModalities, 'configured:', _configuredModalities);
          _throwIfModalitiesNotConfigured('no configured modalities to create answer for');
          _negotiatingModalities = _configuredModalities;
          //take snapshot of _configuredModalities
          var modalities = helper.negotiateModalities(_offeredModalities, _configuredModalities);
          var description;
          resolve(_updatePeerConnectionStreamsAsync(modalities).then(function () {
            _negotiatedModalities = modalities;
            _logger.log('[answer]', 'negotiated:', _negotiatedModalities);
            return _pcCreateAnswerAsync();
          }).then(function (answer) {
            _logger.debug('answer from peer connection', 'sdp:', answer.sdp);
            _logger.log('[answer] created, collect ice candidates and set local description');
            description = _sessionDescription.createAnswer(answer.sdp);
            description.setMedias(_negotiatedModalities);
            return Promise.all([
              _pcSetLocalDescriptionAsync(new RTCSessionDescription({
                sdp: description.toLocal(),
                type: 'answer'
              })),
              _iceCandidatesDeferred.promise
            ]);
          }).then(function () {
            description.update(_peerConnection.localDescription.sdp);
            var answer = description.toAnswer();
            _logger.debug('CREATE ANSWER', 'sdp:', answer);
            return answer;
          }));
        }
      });
    }
    function _processAnswer(answer, provisional) {
      return new Promise(function (resolve) {
        _logger.debug(provisional ? 'PROCESS PRANSWER' : 'PROCESS ANSWER', 'sdp:', answer);
        if (provisional) {
          _logger.log('process [pranswer]');
          // we do not set provisional answer, since no of the browsers support it correctly
          resolve('');
        } else {
          var description = _sessionDescription.createAnswer(answer);
          _negotiatedModalities = helper.invertModalities(description.getMedias());
          _logger.log('process [answer]', 'negotiated:', _negotiatedModalities);
          resolve(_pcSetRemoteDescriptionAsync(new RTCSessionDescription({
            sdp: description.toRemote(),
            type: 'answer'
          })).then(function () {
            return _negotiatedModalities;
          }));
        }
      });
    }
    function _completeNegotiationAsync() {
      return new Promise(function (resolve) {
        //note with current implementation if initial offer did not have video receive capability then there is no new renegotiation triggered
        //this is feature of current implementation we will change when needed
        var needNewRenegotiation = _forceMediaStreamUpdate || !helper.areNegotiatedDirectionsAcceptable(_configuredModalities, _negotiatingModalities, _negotiatedModalities), isComplete = !needNewRenegotiation;
        _canTriggerRenegotiation = true;
        _logger.log('negotiation completed', 'isComplete:', isComplete, 'configured:', _configuredModalities, 'negotiating:', _negotiatingModalities, 'offered:', _offeredModalities, 'negotiated:', _negotiatedModalities);
        if (needNewRenegotiation) {
          _triggerRenegotiation();
        }
        resolve({
          isComplete: isComplete,
          activeModalities: _negotiatedModalities,
          configuredModalities: _configuredModalities
        });
      });
    }
    function _rejectNegotiationAsync(error) {
      return new Promise(function (resolve) {
        var isComplete = error === CONSTANTS.RENEGOTIATION_ERROR.local && !_suppressLocalFailure;
        _suppressLocalFailure = false;
        _logger.warn('negotiation rejected', 'isComplete:', isComplete, 'error:', error, 'configured:', _configuredModalities, 'negotiating:', _negotiatingModalities, 'offered:', _offeredModalities, 'negotiated:', _negotiatedModalities);
        _resetPeerConnection();
        //_canTriggerRenegotiation is true;
        if (error === CONSTANTS.RENEGOTIATION_ERROR.glare) {
          // in case of GLARE we will fail next offer in order to trigger _rejectNegotiationAsync and peer connection reset on remote side as well!
          _failNextOffer = true;
          _canTriggerRenegotiation = false;  //block also renegotiations for now until we have failed next offer
                                             // it is definite that we will get next offer (unless some other signaling issue)
        } else if (error === CONSTANTS.RENEGOTIATION_ERROR.signaling || error === CONSTANTS.RENEGOTIATION_ERROR.media) {
          _triggerRenegotiation();
        }
        //don't trigger renegotiation when we had local error
        resolve({
          isComplete: isComplete,
          activeModalities: _negotiatedModalities,
          configuredModalities: _configuredModalities
        });
      });
    }
    function _createRemoteRenderer(element, cb) {
      var RemoteRenderer = function (_element, _cb) {
        _deviceManager.Renderer.call(this, _element, _cb);
        var _that = this, _baseDispose = this.dispose, _deferredSubscribe = null;
        this._updateStream = function () {
          _that._attachMediaStream(_recvVideoStream);
          if (_deferredSubscribe) {
            _deferredSubscribe.resolve();
            _deferredSubscribe = null;
          }
        };
        this._unsubscribeIfSubscribed = function () {
          if (_deferredSubscribe) {
            _deferredSubscribe.reject();
            _deferredSubscribe = null;
          }
          var index = _subscribedRenderers.indexOf(_that);
          if (index !== -1) {
            _subscribedRenderers.splice(index, 1);
          }
        };
        this.subscribeVideoAsync = function (msi) {
          _logger.info('subscribeVideoAsync', 'msi:', msi);
          return new Promise(function (resolve) {
            _that._unsubscribeIfSubscribed();
            var index = _subscribedRenderers.indexOf(_that);
            if (index === -1) {
              _subscribedRenderers.push(_that);
            }
            if (!_recvVideoStream) {
              _deferredSubscribe = helper.defer();
              resolve(_deferredSubscribe.promise);
            } else {
              _that._attachMediaStream(_recvVideoStream);
              resolve();
            }
          });
        };
        this.dispose = function () {
          _that._unsubscribeIfSubscribed();
          _baseDispose();
        };
      };
      return new RemoteRenderer(element, cb);
    }
    function _deviceSelectionChanged() {
      //currently deviceSelectionChanged does not tell us what devices changed but it could, however this information seems not needed right now...
      if (_peerConnection) {
        _forceMediaStreamUpdate = true;
        _triggerRenegotiation();
      }
    }
    function _terminate() {
      _logger.log('terminate');
      _unsubscribeRenderers();
      _resetPeerConnection();
      _clearIceDisconnectedTimer();
      if (_that._onTerminated) {
        _that._onTerminated(_that);
      }
    }
    function _getStatsAsync() {
      return new Promise(function (resolve) {
        var newStats = {
          localStreams: [],
          remoteStreams: []
        };
        if (_peerConnection) {
          _peerConnection.getLocalStreams().forEach(function (stream) {
            var localStreamStats = { tracks: [] };
            newStats.localStreams.push(localStreamStats);
            stream.getTracks().forEach(function (track) {
              // TODO: for Rejection tests sake check negotiated modalities here since local streams do not get removed if audio/video is rejected from other side...
              if (track.kind === 'audio' && helper.hasSendDirectionality(_negotiatedModalities.audio) || track.kind === 'video' && helper.hasSendDirectionality(_negotiatedModalities.video)) {
                var trackStats = {
                  stream: stream,
                  track: track
                };
                localStreamStats.tracks.push(trackStats);
              }  /* _peerConnection.getStats(track, function (stats) {
                 trackStats.stats = stats;
                 /*var results = stats.result();
                 for (var entry = 0; entry < results.length; ++entry) {
                 var report = results[entry];
                 _logger.log("!!!", report.type, report);
                 if (report.type === 'VideoBwe') {
                 _logger.log('Video BWE: ' + report.stat('googActualEncBitrate') + '/' + report.stat('googTargetEncBitrate') + ' send/recv: ' + report.stat('googAvailableSendBandwidth') + '/' + report.stat('googAvailableReceiveBandwidth'));
                 } else if (report.type === 'AudioBwe') {
                 } else if (report.type === 'ssrc') {
                 var names = report.names();
                 var output = 'SSRC: ';
                 for (var n = 0; n < names.length; ++n) {
                 output += names[n] + '=' + report.stat(names[n]) + '; ';
                 }
                 _logger.log(output);
                 }
                 }
                 }); */
            });
          });
          _peerConnection.getRemoteStreams().forEach(function (stream) {
            var remoteStreamStats = { tracks: [] };
            newStats.remoteStreams.push(remoteStreamStats);
            stream.getTracks().forEach(function (track) {
              // TODO: for Rejection tests sake check negotiated modalities here since remote streams do not get removed if audio/video is rejected...
              if (track.kind === 'audio' && helper.hasReceiveDirectionality(_negotiatedModalities.audio) || track.kind === 'video' && helper.hasReceiveDirectionality(_negotiatedModalities.video)) {
                var trackStats = {
                  stream: stream,
                  track: track
                };
                remoteStreamStats.tracks.push(trackStats);
              }
            });
          });
        }
        resolve(newStats);
      });
    }
  };
  return WebRtcSession;
}(constants, helper, webRtcSessionDescription);
ortcTransport = function (helper) {
  function IceTransport(_type, _logger, _iceCompletionMonitor, _raiseError, _iceOptions, _parentGatherer, _parentTransport) {
    var _that = this;
    var _deferredLocalCandidates = helper.defer();
    var _iceCompletedCb;
    var _started;
    this.nominatedCandidatePair = null;
    _logger.log('create RTCIceGatherer', 'options:', JSON.stringify(_iceOptions.iceGathererOptions));
    if (!_parentGatherer) {
      this.iceGatherer = new RTCIceGatherer(_iceOptions.iceGathererOptions);
    } else {
      this.iceGatherer = _parentGatherer.createAssociatedGatherer();
    }
    _logger.log('create RTCIceTransport');
    if (!_parentTransport) {
      this.iceTransport = new RTCIceTransport();
    } else {
      this.iceTransport = _parentTransport.createAssociatedTransport();
    }
    this.getLocalCandidatesAsync = function () {
      return _deferredLocalCandidates.promise;
    };
    this.start = function (remoteIceCandidates, remoteIceParams) {
      if (_started) {
        throw new Error('already started!');
      }
      _started = true;
      _iceCompletedCb = _iceCompletionMonitor.createCb(_iceOptions.iceRole);
      _logger.log('RTCIceTransport setRemoteCandidates', 'candidates:', JSON.stringify(remoteIceCandidates));
      _that.iceTransport.setRemoteCandidates(remoteIceCandidates);
      _logger.log('RTCIceTransport start', 'remoteIceParams:', JSON.stringify(remoteIceParams), 'role:', _iceOptions.iceRole);
      _that.iceTransport.start(_that.iceGatherer, remoteIceParams, _iceOptions.iceRole);
      _logger.log('RTCIceTransport start', 'role:', _that.iceTransport.role);
    };
    this.dispose = function () {
      _logger.log('dispose');
      //            if (_started) { TODO: for some reason we need to call stop for rtcp icetransport even if we haven't started it!
      _that.iceTransport.stop();
      //            }
      _that.iceTransport = null;
      _that.iceGatherer = null;
      if (_deferredLocalCandidates.isPending()) {
        _deferredLocalCandidates.reject(new Error('operation canceled due to stop'));
      }
      if (_iceCompletedCb) {
        _iceCompletedCb.dispose();
      }
    };
    this.iceGatherer.onlocalcandidate = function (event) {
      _logger.log('RTCIceGatherer.onlocalcandidate', 'candidate:', JSON.stringify(event.candidate));
      if (Object.keys(event.candidate).length === 0) {
        _deferredLocalCandidates.resolve();
      }
    };
    this.iceGatherer.onerror = function (event) {
      _logger.error('RTCIceGatherer.onerror', 'event:', event);
      _deferredLocalCandidates.reject(new Error('IceGatherer failed!'));
    };
    this.iceTransport.onicestatechange = function () {
      if (_that.iceTransport) {
        _logger.log('RTCIceTransport.onicestatechange', 'state:', _that.iceTransport.state);
        if (_that.iceTransport.state === 'completed') {
          _logger.log('pair:', JSON.stringify(_that.iceTransport.getNominatedCandidatePair()));
          _that.nominatedCandidatePair = _that.iceTransport.getNominatedCandidatePair();
          _iceCompletedCb.iceCompleted();
        }
        // end call when audio transport gets disconnected!
        if (_type === 'audio' && _that.iceTransport.state === 'disconnected') {
          _logger.error('audio ICE transport disconnected, ending call!');
          _raiseError(event);
        }
      }
    };
    this.iceTransport.oncandidatepairchange = function (event) {
      _logger.log('RTCIceTransport.oncandidatepairchange', 'event:', event);
    };
  }
  function DtlsTransport(_logger, _iceTransport, _raiseError) {
    var _that = this;
    var _started = false;
    this.dtlsTransport = new RTCDtlsTransport(_iceTransport);
    this.dtlsTransport.ondtlsstatechange = function () {
      _logger.log('RTCDtlsTransport.ondtlsstatechange', 'state:', event.state, 'role:', _that.dtlsTransport ? _that.dtlsTransport.getLocalParameters().role : '');
    };
    this.dtlsTransport.onerror = function (event) {
      _logger.error('RTCDtlsTransport.onerror', 'event:', event);
      _raiseError(event);
    };
    this.startAsync = function (remoteDtlsParams) {
      if (_started) {
        throw new Error('already started!');
      }
      _started = true;
      _logger.log('RTCDtlsTransport.start', 'params:', JSON.stringify(remoteDtlsParams));
      _that.dtlsTransport.start(remoteDtlsParams);
      return Promise.resolve();
    };
    this.dispose = function () {
      if (_started) {
        _that.dtlsTransport.stop();
      }
      _that.dtlsTransport = null;
    };
  }
  function MediaTransport(_type, _logger, _iceCompletionMonitor, _raiseError, _iceOptions, _enableRtcpDemux) {
    var _iceTransport, _rtcpIceTransport, _dtlsTransport;
    var _started = false;
    _iceTransport = new IceTransport(_type, _logger.createChild('IceT'), _iceCompletionMonitor, _raiseError, _iceOptions);
    _dtlsTransport = new DtlsTransport(_logger.createChild('DtlsT'), _iceTransport.iceTransport, _raiseError);
    if (_enableRtcpDemux) {
      _rtcpIceTransport = new IceTransport(_type, _logger.createChild('RtcpIceT'), _iceCompletionMonitor, _raiseError, _iceOptions, _iceTransport.iceGatherer, _iceTransport.iceTransport);
    }
    Object.defineProperty(this, 'iceTransport', {
      get: function () {
        return _iceTransport.iceTransport;
      }
    });
    Object.defineProperty(this, 'dtlsTransport', {
      get: function () {
        return _dtlsTransport ? _dtlsTransport.dtlsTransport : null;
      }
    });
    function _filterCandidates(candidates) {
      var filtered = candidates;
      if (_iceOptions.iceCandidateType || _iceOptions.iceCandidateTransport) {
        filtered = filtered.filter(function (candidate) {
          var typeOk = true;
          var transpOk = true;
          if (_iceOptions.iceCandidateType === 'relay') {
            typeOk = candidate.type.toLowerCase() === 'relay';
          } else if (_iceOptions.iceCandidateType === 'direct') {
            typeOk = candidate.type.toLowerCase() !== 'relay';
          }
          if (_iceOptions.iceCandidateTransport) {
            transpOk = candidate.protocol.toLowerCase().substring(0, _iceOptions.iceCandidateTransport.length) === _iceOptions.iceCandidateTransport;
          }
          return typeOk && transpOk;
        });
      }
      return filtered;
    }
    function _getLocalParams() {
      return {
        iceParams: _iceTransport.iceGatherer.getLocalParameters(),
        iceCandidates: _filterCandidates(_iceTransport.iceGatherer.getLocalCandidates()),
        iceCandidatePair: _iceTransport.nominatedCandidatePair,
        dtlsParams: _dtlsTransport ? _dtlsTransport.dtlsTransport.getLocalParameters() : null,
        rtcpIceParams: _rtcpIceTransport ? _rtcpIceTransport.iceGatherer.getLocalParameters() : null,
        rtcpIceCandidates: _rtcpIceTransport ? _filterCandidates(_rtcpIceTransport.iceGatherer.getLocalCandidates()) : null,
        rtcpIceCandidatePair: _rtcpIceTransport ? _rtcpIceTransport.nominatedCandidatePair : null
      };
    }
    this.getLocalParamsAsync = function () {
      var getParamsPromise;
      if (_rtcpIceTransport) {
        getParamsPromise = Promise.all([
          _iceTransport.getLocalCandidatesAsync(),
          _rtcpIceTransport.getLocalCandidatesAsync()
        ]);
      } else {
        getParamsPromise = _iceTransport.getLocalCandidatesAsync();
      }
      return getParamsPromise.then(function () {
        return _getLocalParams();
      });
    };
    this.startAsync = function (remoteParams) {
      if (_started) {
        throw new Error('already started!');
      }
      var ret = Promise.resolve();
      _started = true;
      _iceTransport.start(remoteParams.iceCandidates, remoteParams.iceParams);
      if (_rtcpIceTransport) {
        if (!remoteParams.doRtcpMux) {
          _rtcpIceTransport.start(remoteParams.rtcpIceCandidates, remoteParams.rtcpIceParams);
        } else {
          _rtcpIceTransport.dispose();
          _rtcpIceTransport = null;
        }
      }
      if (remoteParams.enableDtls) {
        ret = _dtlsTransport.startAsync(remoteParams.dtlsParams);
      }
      return ret;
    };
    // call this before throwing the object away
    this.dispose = function () {
      _logger.log('dispose');
      _iceTransport.dispose();
      _iceTransport = null;
      if (_rtcpIceTransport) {
        _rtcpIceTransport.dispose();
        _rtcpIceTransport = null;
      }
      if (_dtlsTransport) {
        _dtlsTransport.dispose();
        _dtlsTransport = null;
      }
    };
  }
  function IceCompletionMonitor(_logger, _transportCb) {
    var _callbacks = [];
    var _triggeredIceReinvite = false;
    var _deferredWaitCallbacks = helper.defer();
    var _controllingTransportCount = 0;
    function Callback(_iceRole) {
      this.dispose = function () {
        var index = _callbacks.indexOf(this);
        if (index !== -1) {
          _callbacks.splice(index, 1);
        }
      };
      this.gotCallback = false;
      this.iceCompleted = function () {
        this.gotCallback = true;
        this.gotCallbackFromControlling = _iceRole === 'controlling';
        var arrivedCallbacs = 0;
        var arrivedCallbacsFromControlling = 0;
        for (var i = 0; i < _callbacks.length; i++) {
          if (_callbacks[i].gotCallback) {
            arrivedCallbacs++;
          }
          if (_callbacks[i].gotCallbackFromControlling) {
            arrivedCallbacsFromControlling++;
          }
        }
        //                _logger.log('IceCompletionMonitor', 'gotCb:', this.gotCallback, '_callbacks.length:', _callbacks.length,
        //                    'arrivedCallbacs:', arrivedCallbacs, '_controllingTransportCount:', _controllingTransportCount,
        //                    'arrivedCallbacsFromControlling', arrivedCallbacsFromControlling, '_triggeredIceReinvite:', _triggeredIceReinvite);
        if (arrivedCallbacsFromControlling && arrivedCallbacsFromControlling === _controllingTransportCount && !_triggeredIceReinvite) {
          _logger.log('IceCompletionMonitor REINVITE');
          _triggeredIceReinvite = true;
          _transportCb.triggerIceReinvite();
        }
        if (arrivedCallbacs && arrivedCallbacs === _callbacks.length) {
          _logger.log('IceCompletionMonitor ALL COMPLETE');
          _deferredWaitCallbacks.resolve();
        }
      };
    }
    this.createCb = function (iceRole) {
      var cb = new Callback(iceRole);
      _callbacks.push(cb);
      if (iceRole === 'controlling') {
        _triggeredIceReinvite = false;
        _controllingTransportCount++;
      }
      // reset promise. nobody should be waiting at this point actually
      _deferredWaitCallbacks.reject();
      _deferredWaitCallbacks = helper.defer();
      return cb;
    };
    this.waitAllCallbacksAsync = function () {
      return _deferredWaitCallbacks.promise;
    };
  }
  function OrtcTransport(_logger, _settings, _transportCb, _relayMgr, _isRemoteClientLync, _enableRtcpDemux) {
    var _aTransport, _vTransport;
    var _startedModalities = [
      false,
      false
    ];
    var _iceCompletionMonitor = new IceCompletionMonitor(_logger, _transportCb);
    var _relayPromise;
    Object.defineProperty(this, 'audioTransport', {
      get: function () {
        return _aTransport ? _aTransport : null;
      }
    });
    Object.defineProperty(this, 'videoTransport', {
      get: function () {
        return _vTransport ? _vTransport : null;
      }
    });
    function _queryRelaysAsync() {
      if (!_relayPromise) {
        _relayPromise = _relayMgr.queryRelaysAsync('msturn', _isRemoteClientLync);
      }
      return _relayPromise;
    }
    this.assureInitAsync = function (iceRole, modalities) {
      return new Promise(function (resolve) {
        _logger.log('assureInitAsync');
        var ret = _queryRelaysAsync().then(function (relays) {
          var iceOptions = {
            iceRole: iceRole,
            iceCandidateType: _settings.iceCandidateType,
            iceCandidateTransport: _settings.iceCandidateTransport,
            iceGathererOptions: {
              'gatherPolicy': 'all',
              'iceServers': relays.reduce(function (arr, relay) {
                //todo: urls can be string or sequence (array) thus we can merge two iceServers elements in to single one
                relay.addresses.map(function (address) {
                  arr.push({
                    urls: relay.type + ':' + address + ':' + relay.udpPort + '?transport=udp',
                    credential: relay.password,
                    username: relay.username
                  });
                  arr.push({
                    urls: relay.type + ':' + address + ':' + relay.tcpPort + '?transport=tcp',
                    credential: relay.password,
                    username: relay.username
                  });
                });
                return arr;
              }, [])
            }
          };
          if (!_aTransport && modalities[0]) {
            _logger.log('assureInitAsync AUDIO' + iceOptions.iceRole);
            _aTransport = new MediaTransport('audio', _logger.createChild('AT'), _iceCompletionMonitor, _transportCb.raiseError, iceOptions, _enableRtcpDemux);
          }
          if (!_vTransport && modalities[1]) {
            _logger.log('assureInitAsync VIDEO' + iceOptions.iceRole);
            _vTransport = new MediaTransport('video', _logger.createChild('VT'), _iceCompletionMonitor, _transportCb.raiseError, iceOptions, _enableRtcpDemux);
          }
        });
        resolve(ret);
      });
    };
    // gather local candidates and other params
    this.getLocalParamsAsync = function () {
      _logger.log('getLocalParamsAsync');
      return new Promise(function (resolve) {
        var aPromise = Promise.resolve(), vPromise = Promise.resolve();
        if (_aTransport) {
          aPromise = _aTransport.getLocalParamsAsync();
        }
        if (_vTransport) {
          vPromise = _vTransport.getLocalParamsAsync();
        }
        resolve(Promise.all([
          aPromise,
          vPromise
        ]));
      });
    };
    this.waitIceCompletionIfNeededAsync = function (remoteParams) {
      return new Promise(function (resolve) {
        var ret = '';
        // if remote offer contained candidate pair then need to wait ice completed state before sending answer!
        if (remoteParams[0] && remoteParams[0].iceCandidatePair || remoteParams[1] && remoteParams[1].iceCandidatePair) {
          _logger.log('waiting ICE completed state!');
          ret = _iceCompletionMonitor.waitAllCallbacksAsync();
        }
        resolve(ret);
      });
    };
    this.configureTransportAsync = function (remoteParams, modalities) {
      return new Promise(function (resolve) {
        var aPromise = Promise.resolve(), vPromise = Promise.resolve();
        if (modalities[0] && !_startedModalities[0]) {
          aPromise = _aTransport.startAsync(remoteParams[0]);
        } else if (!modalities[0] && _startedModalities[0]) {
          _aTransport.dispose();
          _aTransport = null;
        }
        if (modalities[1] && !_startedModalities[1]) {
          vPromise = _vTransport.startAsync(remoteParams[1]);
        } else if (!modalities[1] && _startedModalities[1]) {
          _vTransport.dispose();
          _vTransport = null;
        }
        _startedModalities = modalities;
        resolve(Promise.all([
          aPromise,
          vPromise
        ]));
      });
    };
    // call this before throwing the object away
    this.stop = function () {
      if (_aTransport) {
        _aTransport.dispose();
        _aTransport = null;
      }
      if (_vTransport) {
        _vTransport.dispose();
        _vTransport = null;
      }
    };
  }
  return OrtcTransport;
}(helper);
ortcParameters = function (helper) {
  function compareStr(a, b) {
    return a.toLowerCase() === b.toLowerCase();
  }
  function OrtcParameters() {
    function matchCodecCaps(local, remote, useLocalPayloadType) {
      var codecs = [];
      if (local && remote) {
        local.forEach(function (lcodec) {
          for (var i = 0; i < remote.length; i++) {
            var rcodec = remote[i];
            if (compareStr(lcodec.name, rcodec.name) && compareStr(lcodec.kind, rcodec.kind) && lcodec.numChannels === rcodec.numChannels && lcodec.clockRate === rcodec.clockRate) {
              var codec = helper.shallowClone(lcodec);
              codec.preferredPayloadType = useLocalPayloadType ? lcodec.preferredPayloadType : rcodec.preferredPayloadType;
              codecs.push(codec);
              break;
            }
          }
        });
      }
      return codecs;
    }
    this.findMatchingSdesParams = function (localSdesParamsList, remoteSdesParamsList) {
      //NB! this function is not fully complete and it depends on the order of the elements in the lists as first successful match is taken
      function _doSdesParamsMatch(a, b) {
        var aKeyParams0 = a.keyParams[0];
        var bKeyParams0 = b.keyParams[0];
        return a.cryptoSuite === b.cryptoSuite && aKeyParams0.mkiLength === bKeyParams0.mkiLength && aKeyParams0.mkiValue === bKeyParams0.mkiValue;
      }
      for (var i = 0; i < remoteSdesParamsList.length; ++i) {
        var sdesRemote = remoteSdesParamsList[i];
        for (var j = 0; j < localSdesParamsList.length; ++j) {
          var sdesLocal = localSdesParamsList[j];
          if (_doSdesParamsMatch(sdesRemote, sdesLocal)) {
            return {
              localSdesParams: helper.shallowClone(sdesLocal),
              remoteSdesParams: helper.shallowClone(sdesRemote)
            };
          }
        }
      }
      return null;
    };
    function matchHeaderExtensions(local, remote) {
      var hrdExtPrms = [];
      if (local && remote) {
        local.forEach(function (lenc) {
          for (var i = 0; i < remote.length; i++) {
            var renc = remote[i];
            if (lenc.kind === renc.kind && lenc.uri === renc.uri) {
              hrdExtPrms.push(lenc);
            }
          }
        });
      }
      return hrdExtPrms;
    }
    this.matchRtpCaps = function (local, remote, useLocalPayloadType) {
      var rtpCaps = null;
      if (local && remote) {
        rtpCaps = {
          codecs: matchCodecCaps(local.codecs, remote.codecs, useLocalPayloadType),
          headerExtensions: matchHeaderExtensions(local.headerExtensions, remote.headerExtensions),
          fecMechanisms: local.fecMechanisms.filter(function (n) {
            return remote.fecMechanisms.indexOf(n) !== -1;
          })
        };
      }
      return rtpCaps;
    };
    this.getSendParams = function (rtpCaps, ssrcRange, rtcpSsrc, rtcpReducecdSize, doRtcpMux) {
      return _that.RTCRtpParameters('', codecCapsToCodecParams(rtpCaps.codecs), hdrExtToHdrExtParams(rtpCaps.headerExtensions), getEncParams(rtpCaps.codecs, ssrcRange), _that.RTCRtcpParameters(rtcpSsrc, '', rtcpReducecdSize, doRtcpMux));
    };
    this.getRecvParams = function (rtpCaps, ssrcRange, rtcpSsrc, rtcpReducecdSize, doRtcpMux) {
      return _that.getSendParams(rtpCaps, ssrcRange, rtcpSsrc, rtcpReducecdSize, doRtcpMux);
    };
    function codecCapsToCodecParams(codecCaps) {
      var codecPrms = [];
      codecCaps.forEach(function (codec) {
        codecPrms.push(_that.RTCRtpCodecParameters(codec.name, codec.preferredPayloadType, codec.clockRate, codec.numChannels, codec.rtcpFeedback, codec.parameters));
      });
      return codecPrms;
    }
    function hdrExtToHdrExtParams(hdrExt) {
      var hrdExtPrms = [];
      hdrExt.forEach(function (enc) {
        hrdExtPrms.push(_that.RTCRtpHeaderExtensionParameters(enc.uri, enc.preferredId, enc.preferredEncrypt));
      });
      return hrdExtPrms;
    }
    function getEncParams(codecCaps, ssrcRange) {
      var encPrms = [];
      encPrms.push(_that.RTCRtpEncodingParameters(ssrcRange, 0, 0, 0, 1));
      return encPrms;
    }
    this.RTCRtpParameters = function (inMuxId, inCodecs, inHeaderExtensions, inEncodings, inRtcp) {
      return {
        muxId: inMuxId || '',
        codecs: inCodecs,
        headerExtensions: inHeaderExtensions,
        encodings: inEncodings,
        rtcp: inRtcp
      };
    };
    this.RTCRtpCodecParameters = function (inName, inPayloadType, inClockRate, inNumChannels, inRtcpFeedback, inParameters) {
      return {
        name: inName,
        payloadType: inPayloadType,
        clockRate: inClockRate,
        numChannels: inNumChannels,
        rtcpFeedback: inRtcpFeedback,
        parameters: inParameters
      };
    };
    this.RTCRtpHeaderExtensionParameters = function (uri, id, encrypt) {
      return {
        uri: uri,
        id: id,
        encrypt: encrypt
      };
    };
    this.RTCRtcpParameters = function (inSsrc, inCname, inReducecdSize, inMux) {
      return {
        ssrc: inSsrc,
        cname: inCname,
        reducedSize: inReducecdSize,
        mux: inMux
      };
    };
    this.RTCRtpEncodingParameters = function (inSsrcRange, inCodecPayloadType, inFec, inRtx, inPriority, inMaxBitRate, inMinQuality, inFramerateBias, inResolutionScale, inFramerateScale, inQualityScale, inActive, inEncodingId, inDependencyEncodingIds) {
      return {
        ssrc: inSsrcRange.min,
        // since ssrcRange is given
        ssrcRange: inSsrcRange,
        // http://internaut.com:8080/~baboba/ortc/extensions-3-11-2015.html#dictionary-rtcrtpencodingparameters-members
        codecPayloadType: inCodecPayloadType,
        fec: inFec,
        rtx: inRtx,
        priority: inPriority || 1,
        maxBitrate: inMaxBitRate,
        minQuality: inMinQuality || 0,
        framerateBias: inFramerateBias || 0.5,
        resolutionScale: inResolutionScale || 1,
        framerateScale: inFramerateScale || 1,
        active: inActive || true,
        encodingId: inEncodingId,
        dependencyEncodingId: inDependencyEncodingIds
      };
    };
    var _that = this;
  }
  return OrtcParameters;
}(helper);
ortcMediaChannel = function (OrtcParameters, CONSTANTS, helper) {
  function OrtcMediaChannel(_logger, _settings, _type, _label, _raiseError, _ssrcRange, _callId, _channelName) {
    var _that = this;
    var _rtpSender = null;
    var _rtpReceiver = null;
    var _currMediaStreamRef = null;
    var _sdesTransport = null;
    var _localSdesParamsList = null;
    var _ortcPrm = new OrtcParameters();
    var _inactive = false;
    var _contributingSourcesPollingInterval = 1000;
    var _recvTrack = null;
    var _lastSources = [];
    var _terminated = false;
    var _remoteSsrcRange = null;
    this.type = _type;
    this.label = _label;
    this.GETSTATS_TIMEOUT = 5000;
    this.subscribedMsi = CONSTANTS.MSI.unsubscribe;
    // unsubscribed
    this.onContributingSourcesChanged = null;
    if (!_settings.disableSdes) {
      _localSdesParamsList = RTCSrtpSdesTransport.getLocalParameters().filter(_filterLocalSdesParamsList);
    }
    function _getLocalRtpCaps() {
      // Assuming receiver and sender to return same capabilities
      var rtpCaps = RTCRtpReceiver.getCapabilities(_type);
      var i;
      if (rtpCaps.codecs) {
        if (_type === CONSTANTS.MEDIA_TYPE.audio && _settings.audioCodec) {
          var keepCodecs = [
            'cn',
            'red'
          ];
          for (i = rtpCaps.codecs.length - 1; i >= 0; i--) {
            var codecName = rtpCaps.codecs[i].name.toLowerCase();
            if (codecName !== _settings.audioCodec.toLowerCase() && keepCodecs.indexOf(codecName) === -1) {
              rtpCaps.codecs.splice(i, 1);
            }
          }
        } else if (_type === CONSTANTS.MEDIA_TYPE.video && _settings.videoCodec) {
          for (i = rtpCaps.codecs.length - 1; i >= 0; i--) {
            if (rtpCaps.codecs[i].name.toLowerCase() !== _settings.videoCodec.toLowerCase()) {
              rtpCaps.codecs.splice(i, 1);
            }
          }
        }
      }
      if (_type === CONSTANTS.MEDIA_TYPE.audio) {
        // workaround for chrome && firefox issue: if we offer opus with pt. 106, neither chrome nor firefox will work.
        // They answer with opus pt. 106 also but actually fail to play back stream sent from Microsoft Edge
        for (i = rtpCaps.codecs.length - 1; i >= 0; i--) {
          if (rtpCaps.codecs[i].preferredPayloadType === 106) {
            rtpCaps.codecs[i].preferredPayloadType = 111;
            console.log('Opus payloadType fix, change payload type 106->111 for ' + rtpCaps.codecs[i].name);
          }
        }
      }
      return rtpCaps;
    }
    function _filterLocalSdesParamsList(elem) {
      return elem.cryptoSuite !== 'SCALE_AES_CM_128_HMAC_SHA1_80';  //ignoring SCALE_AES_CM_128_HMAC_SHA1_80 cryptoscale for now because issues sending stream to MP
    }
    this.getLocalParameters = function () {
      return {
        sdesParamsList: _localSdesParamsList,
        rtpCaps: _getLocalRtpCaps(),
        ssrcRange: _ssrcRange
      };
    };
    function _replaceMediaStreamIfDifferent(mediaStreamRef) {
      var tracks, currTrack, newTrack;
      if (_isAudio()) {
        currTrack = _currMediaStreamRef.getObject().getAudioTracks()[0];
        tracks = mediaStreamRef.getObject().getAudioTracks();
      } else {
        currTrack = _currMediaStreamRef.getObject().getVideoTracks()[0];
        tracks = mediaStreamRef.getObject().getVideoTracks();
      }
      newTrack = tracks.length ? tracks[0] : null;
      if (newTrack === null) {
        _logger.error('media track is not available');
        return;
      }
      var currDevId = currTrack.getSettings().deviceId;
      var newDevId = newTrack.getSettings().deviceId;
      if (currDevId !== newDevId) {
        _logger.log('replacing media track', 'currDevID:', currDevId, 'newDevID:', newDevId, 'currTrackID:', currTrack.id, 'newTrackID:', newTrack.id);
        _rtpSender.setTrack(newTrack);
        _currMediaStreamRef.dispose();
        _currMediaStreamRef = mediaStreamRef.clone();
      } else {
        _logger.log('NOT replacing media track', 'currDevID:', currDevId, 'newDevID:', newDevId, 'currTrackID:', currTrack.id, 'newTrackID:', newTrack.id);
      }
    }
    function _assureSdesTransport(iceTransport, negotiatedParams) {
      if (!_sdesTransport) {
        _logger.debug('RTCSrtpSdesTransport', 'local:', JSON.stringify(negotiatedParams.sdesParamsList[0]), 'remote:', JSON.stringify(negotiatedParams.remoteSdesParams));
        _sdesTransport = new RTCSrtpSdesTransport(iceTransport, negotiatedParams.sdesParamsList[0], negotiatedParams.remoteSdesParams);
        _sdesTransport.onerror = function (event) {
          _logger.log('RTCSrtpSdesTransport.onerror', 'event:', event);
          _raiseError({
            type: CONSTANTS.MEDIA_ERROR.internalError,
            detail: event
          });
        };
      }
    }
    function _isAudio() {
      return _type === CONSTANTS.MEDIA_TYPE.audio;
    }
    function _isVideo() {
      return _type === CONSTANTS.MEDIA_TYPE.video;
    }
    function _destroySdesTransport() {
      if (_sdesTransport) {
        _sdesTransport = null;
      }
    }
    function _updateContributingSources() {
      if (_rtpReceiver) {
        var sources;
        try {
          sources = _rtpReceiver.getContributingSources();
        } catch (error) {
          _logger.error('failed to retrieve contributing sources from receiver', 'error:', error);
          return;
        }
        if (!sources) {
          _logger.warn('could not retrieve contributing sources from receiver');
          return;
        }
        sources = sources.map(function (source) {
          return source.csrc;
        });
        var hasNotChanged = _lastSources.length === sources.length && sources.every(function (element, index) {
          return element === _lastSources[index];
        });
        if (!hasNotChanged) {
          _logger.debug('contributing sources changed', 'sources:', sources);
          if (_that.onContributingSourcesChanged) {
            _that.onContributingSourcesChanged(sources);
          }
        }
        _lastSources = sources;
        setTimeout(_updateContributingSources, _contributingSourcesPollingInterval);
      } else {
        _logger.debug('receiver is missing, stop polling for contributing sources');
      }
    }
    function _requestSendCsrc(csrc) {
      if (_rtpReceiver) {
        _logger.log('_requestSendCsrc', 'csrc:', csrc);
        try {
          _rtpReceiver.requestSendCSRC(csrc);
        } catch (error) {
          // TODO: treat this as an error and return false once requestSendCSRC API is supported in winmain
          _logger.error('failed to request send csrc', 'error:', error);
        }
        return true;
      }
      return false;
    }
    function _getMediaDiagnosticReason(iceTransport) {
      if (!iceTransport) {
        return 'CheckNotCompleted';
      }
      var state = iceTransport.state;
      if (state === 'new' || state === 'checking' || state === 'connected') {
        return 'CheckNotCompleted';
      } else if (state === 'completed') {
        return 'CheckSucceed';
      } else if (state === 'failed') {
        return 'CheckFailed';
      } else if (state === 'disconnected' || state === 'closed') {
        return 'MediaTimeout';
      } else {
        return 'Unknown DiagnosticReason';
      }
    }
    function _generateExtendedReports(iceTransport) {
      return { mediaDiagnostic: { reason: _getMediaDiagnosticReason(iceTransport) } };
    }
    function _transformReports(reports) {
      var r = {};
      if (!reports) {
        return null;
      }
      for (var key in reports) {
        if (reports.hasOwnProperty(key)) {
          var report = reports[key];
          r[report.type || report.msType] = report;
        }
      }
      return r;
    }
    function _getReportsAsync() {
      var iceTransport = _rtpReceiver ? _rtpReceiver.transport.transport : _rtpSender ? _rtpSender.transport.transport : null;
      var reportsTransformed = {};
      var timeStarted, timeEnd;
      function createGetStatsPromise(statsProvider, name, useMsGetStats) {
        var promiseName = _callId + ':' + _channelName + ':' + '_getReportsAsync ' + name + '.' + (useMsGetStats ? 'msGetStats' : 'getStats');
        if (!statsProvider) {
          _logger.log(promiseName, 'noop');
          return;
        }
        return helper.timeout(Promise.resolve().then(function () {
          timeStarted = new Date().getTime();
          _logger.log(promiseName, 'start');
          return useMsGetStats ? statsProvider.msGetStats() : statsProvider.getStats();
        }).then(function (reports) {
          reportsTransformed[name] = _transformReports(reports);
          timeEnd = new Date().getTime();  //_logger.log(promiseName, 'resolved', 'duration', timeEnd - timeStarted, 'reports', reportsTransformed[name]);
        }).catch(function (e) {
          _logger.error(promiseName, 'caught error', e);
          throw e;
        }), _that.GETSTATS_TIMEOUT, promiseName);
      }
      return new Promise(function (resolve, reject) {
        // enclose here to catch their exceptions
        Promise.all([
          createGetStatsPromise(iceTransport, 'iceTransport', false),
          createGetStatsPromise(iceTransport, 'iceTransport', true),
          createGetStatsPromise(_rtpReceiver, 'receiver', false),
          createGetStatsPromise(_rtpReceiver, 'receiver', true),
          createGetStatsPromise(_rtpSender, 'sender', false),
          createGetStatsPromise(_rtpSender, 'sender', true)
        ]).then(function () {
          reportsTransformed.extended = _generateExtendedReports(iceTransport);
          _logger.log('_getReportsAsync', 'extended', reportsTransformed.extended);
          resolve(reportsTransformed);
        }).catch(function (e) {
          _logger.error('_getReportsAsync caught error', e);
          reject();
        });
      });
    }
    function _createReceiver(mediaTransport, negotiatedMediaParams) {
      _logger.log('_rtpReceiver create');
      if (negotiatedMediaParams.enableDtls) {
        if (negotiatedMediaParams.rtcpMux) {
          _rtpReceiver = new RTCRtpReceiver(mediaTransport.dtlsTransport, _type);
        } else {
          throw new Error('rtcpMux=false not supported with dtls!');
        }
      } else {
        _assureSdesTransport(mediaTransport.iceTransport, negotiatedMediaParams);
        _rtpReceiver = new RTCRtpReceiver(_sdesTransport, _type);
      }
      _recvTrack = _rtpReceiver.track;
      _rtpReceiver.onerror = function (event) {
        _logger.error('_rtpReceiver.onerror', 'event:', event);
        _raiseError({
          type: CONSTANTS.MEDIA_ERROR.internalError,
          detail: event
        });
      };
    }
    function _createSender(mediaTransport, mediaStreamRef, negotiatedMediaParams) {
      var sendTrack;
      if (_isAudio()) {
        sendTrack = mediaStreamRef.getObject().getAudioTracks()[0];
      } else {
        sendTrack = mediaStreamRef.getObject().getVideoTracks()[0];
      }
      _logger.log('_rtpSender create trackID:', sendTrack.id);
      if (negotiatedMediaParams.enableDtls) {
        if (negotiatedMediaParams.rtcpMux) {
          _rtpSender = new RTCRtpSender(sendTrack, mediaTransport.dtlsTransport);
        } else {
          throw new Error('rtcpMux=false not supported with dtls!');
        }
      } else {
        _assureSdesTransport(mediaTransport.iceTransport, negotiatedMediaParams);
        _rtpSender = new RTCRtpSender(sendTrack, _sdesTransport);
      }
      _rtpSender.onerror = function (event) {
        _logger.error('_rtpSender.onerror', 'event:', event);
        _raiseError({
          type: CONSTANTS.MEDIA_ERROR.internalError,
          detail: event
        });
      };
      _rtpSender.onssrcconflict = function (event) {
        _logger.error('_rtpSender.onssrcconflict', 'event:', event);
      };
    }
    function _getRecvParams(negotiatedMediaParams) {
      return _ortcPrm.getRecvParams(negotiatedMediaParams.rtpCaps, negotiatedMediaParams.remoteSsrcRange, _ssrcRange.min, negotiatedMediaParams.rtcpReducedSize, negotiatedMediaParams.rtcpMux);
    }
    function _getSendParams(negotiatedMediaParams) {
      return _ortcPrm.getSendParams(negotiatedMediaParams.rtpCaps, _ssrcRange, negotiatedMediaParams.remoteSsrcRange.min, negotiatedMediaParams.rtcpReducedSize, negotiatedMediaParams.rtcpMux);
    }
    this.configureChannel = function (mediaTransport, mediaStreamRef, negotiatedMediaParams) {
      var inactive = negotiatedMediaParams.descr.enabled && (!negotiatedMediaParams.descr.send && !negotiatedMediaParams.descr.recv);
      var ssrcChanged = _remoteSsrcRange && negotiatedMediaParams.remoteSsrcRange && (_remoteSsrcRange.min !== negotiatedMediaParams.remoteSsrcRange.min || _remoteSsrcRange.max !== negotiatedMediaParams.remoteSsrcRange.max);
      _logger.log('configureChannel', 'type:', _type, 'descr:', JSON.stringify(negotiatedMediaParams.descr), 'inactive:', inactive, '_inactive:', _inactive, ' ssrcChanged:', ssrcChanged);
      var recvParams = null;
      // change receiver between active/inactive
      if ((inactive || _inactive) && _rtpReceiver) {
        recvParams = _getRecvParams(negotiatedMediaParams);
        _logger.debug('_rtpReceiver.receive:', JSON.stringify(recvParams));
        if (inactive && !_inactive) {
          recvParams.encodings[0].active = false;
          _logger.log('_rtpReceiver.receive ACTIVE -> INACTIVE');
          _rtpReceiver.receive(recvParams);
        } else if (negotiatedMediaParams.descr.recv && _inactive) {
          _logger.log('_rtpReceiver.receive INACTIVE -> ACTIVE');
          _rtpReceiver.receive(recvParams);
        }  // start receiving
      } else if (negotiatedMediaParams.descr.recv && !_rtpReceiver) {
        recvParams = _getRecvParams(negotiatedMediaParams);
        _createReceiver(mediaTransport, negotiatedMediaParams);
        console.log('_rtpReceiver.receive', 'params:', JSON.stringify(recvParams));
        _rtpReceiver.receive(recvParams);
        if (_isAudio()) {
          // contributing sources make sense for audio channels only
          _updateContributingSources();
        } else {
          if (_that.subscribedMsi !== CONSTANTS.MSI.unsubscribe) {
            // clients managed to subscribe before video channel has been configured
            _requestSendCsrc(_that.subscribedMsi);
          }
        }  // stop receiving
      } else if (!negotiatedMediaParams.descr.recv && _rtpReceiver) {
        _logger.log('_rtpReceiver stop & destroy');
        _rtpReceiver.stop();
        _rtpReceiver = null;
        _recvTrack = null;
        if (!_rtpSender) {
          _destroySdesTransport();
        }  // already receiving, check if need to reconfigure
      } else if (negotiatedMediaParams.descr.recv && _rtpReceiver) {
        // reconfigure if ssrc range changed
        if (ssrcChanged) {
          recvParams = _getRecvParams(negotiatedMediaParams);
          _rtpReceiver.stop();
          _rtpReceiver = null;
          _createReceiver(mediaTransport, negotiatedMediaParams);
          _logger.debug('_rtpReceiver.receive - ssrc changed', 'params:', JSON.stringify(recvParams));
          _rtpReceiver.receive(recvParams);
        }
      }
      var sendParams = null;
      // change sender between active/inactive
      if ((inactive || _inactive) && _rtpSender) {
        sendParams = _getSendParams(negotiatedMediaParams);
        _logger.debug('_rtpSender.send', 'params:', JSON.stringify(sendParams));
        if (inactive && !_inactive) {
          sendParams.encodings[0].active = false;
          _logger.log('_rtpSender.send ACTIVE -> INACTIVE');
          _rtpSender.send(sendParams);
        } else if (negotiatedMediaParams.descr.send && _inactive) {
          _logger.log('_rtpSender.send INACTIVE -> ACTIVE');
          _rtpSender.send(sendParams);
        }  // start sending
      } else if (negotiatedMediaParams.descr.send && !_rtpSender) {
        sendParams = _getSendParams(negotiatedMediaParams);
        _createSender(mediaTransport, mediaStreamRef, negotiatedMediaParams);
        console.log('_rtpSender.send', 'params:', JSON.stringify(sendParams));
        _rtpSender.send(sendParams);
        //assert(!_currMediaStreamRef);
        _currMediaStreamRef = mediaStreamRef.clone();  // stop sending
      } else if (!negotiatedMediaParams.descr.send && _rtpSender) {
        _logger.log('_rtpSender stop & destroy');
        _rtpSender.stop();
        _rtpSender = null;
        if (!_rtpReceiver) {
          _destroySdesTransport();
        }
        _currMediaStreamRef.dispose();
        _currMediaStreamRef = null;  // already sending, check if need to reconfigure
      } else if (negotiatedMediaParams.descr.send && _rtpSender) {
        // reconfigure if ssrc range changed
        if (ssrcChanged) {
          _rtpSender.stop();
          _rtpSender = null;
          _createSender(mediaTransport, mediaStreamRef, negotiatedMediaParams);
          sendParams = _getSendParams(negotiatedMediaParams);
          _logger.debug('_rtpSender.send - ssrc changed', 'params:', JSON.stringify(sendParams));
          _rtpSender.send(sendParams);
        }
        //assert(_currMediaStreamRef);
        // media track may have been changed
        _replaceMediaStreamIfDifferent(mediaStreamRef);
      }
      _inactive = inactive;
      _remoteSsrcRange = negotiatedMediaParams.remoteSsrcRange;  // remember ssrc to check if it has changed
    };
    this.updateLocalMediaStream = function (mediaStreamRef) {
      if (_rtpSender) {
        _replaceMediaStreamIfDifferent(mediaStreamRef);
      }
    };
    this.canSubscribe = function () {
      return _rtpReceiver && _that.subscribedMsi === CONSTANTS.MSI.unsubscribe && _isVideo();
    };
    this.subscribe = function (msi) {
      if (_that.subscribedMsi === CONSTANTS.MSI.unsubscribe && _isVideo()) {
        _that.subscribedMsi = msi;
        return _requestSendCsrc(_that.subscribedMsi);
      }
      throw new Error('invalid call for subscribe:' + _that.subscribedMsi + 'type:' + _type);
    };
    this.unsubscribe = function () {
      if (_that.subscribedMsi === CONSTANTS.MSI.unsubscribe || !_isVideo()) {
        throw new Error('invalid call for unsubscribe:' + _that.subscribedMsi + 'type:' + _type);
      }
      _that.subscribedMsi = CONSTANTS.MSI.unsubscribe;
      _requestSendCsrc(_that.subscribedMsi);
    };
    this.getReportsAsync = _getReportsAsync;
    this.getSendTrack = function () {
      if (_rtpSender && !_inactive) {
        return _rtpSender.track;
      }
      return null;
    };
    this.getRecvTrack = function () {
      if (!_inactive) {
        return _recvTrack;
      }
      return null;
    };
    this.terminate = function () {
      _rtpSender = null;
      _rtpReceiver = null;
      _recvTrack = null;
      _destroySdesTransport();
      if (_currMediaStreamRef) {
        _currMediaStreamRef.dispose();
        _currMediaStreamRef = null;
      }
      _logger.log('termiated');
      _terminated = true;
    };
  }
  return OrtcMediaChannel;
}(ortcParameters, constants, helper);
ortcSdp = function (SdpT, CONSTANTS) {
  function OrtcSdp() {
    function _compareStr(a, b) {
      return a.toLowerCase() === b.toLowerCase();
    }
    function _getHostIp(transportParams) {
      var sortedCandidates = transportParams.iceCandidates.slice(0).sort(function (a, b) {
        return b.priority - a.priority;
      });
      // sort descending by priority
      for (var j = 0; j < sortedCandidates.length; j++) {
        if (sortedCandidates[j].type === 'host') {
          return sortedCandidates[j].ip;
        }
      }
      return '0.0.0.0';  // this is error actually but we put it here to allow testing with removed host candidates (force relay)
    }
    function _getDirection(send, recv) {
      if (send && recv) {
        return 'sendrecv';
      } else if (send) {
        return 'sendonly';
      } else if (recv) {
        return 'recvonly';
      } else {
        return 'inactive';
      }
    }
    function _getTransport(protocol, tcpType) {
      var p = protocol.toUpperCase();
      if (p === 'TCP') {
        switch (tcpType.toLowerCase()) {
        case 'active':
          return 'TCP-ACT';
        case 'passive':
          return 'TCP-PASS';
        case 'so':
          return 'TCP-SO';
        }
      }
      return p;
    }
    function _addCandidate(candidate, type, candidatesOut) {
      candidatesOut.push({
        foundation: candidate.foundation,
        component: type,
        transport: _getTransport(candidate.protocol, candidate.tcpType),
        priority: candidate.priority,
        ip: candidate.ip,
        port: candidate.port,
        type: candidate.type,
        raddr: !_compareStr(candidate.type, 'host') ? candidate.relatedAddress : void 0,
        rport: !_compareStr(candidate.type, 'host') ? candidate.relatedPort : void 0
      });
    }
    function _addCandidates(candidatesIn, type, candidatesOut, candidatesIpv6Out) {
      if (candidatesIn) {
        candidatesIn.forEach(function (candidate) {
          // ipv4
          if (candidate.ip.indexOf(':') === -1) {
            _addCandidate(candidate, type, candidatesOut);  // ipv6
          } else {
            _addCandidate(candidate, type, candidatesIpv6Out);
          }
        });
      }
    }
    // rfc 5245 4.1.4 use local from this pair
    // return candidates of the same foundation indexed by component id(rtp -> 0, rtcp - >1)
    function _getDefaultCandidates(transportParams) {
      // if candidate pair chosen, use local candidate from there
      if (transportParams.iceCandidatePair) {
        return {
          0: transportParams.iceCandidatePair.local,
          1: transportParams.rtcpIceCandidatePair ? transportParams.rtcpIceCandidatePair.local : null
        };
      } else {
        // otherwise select highest priority candidate. NB: rfc 5245 says we should select relay or srflx candidate instead...
        var sortedCandidates = transportParams.iceCandidates.slice(0).sort(function (a, b) {
          return b.priority - a.priority;
        });
        // sort descending by priority
        var defaultRTPCandidate = sortedCandidates[0];
        // find matching rtcp candidate if any
        var defaultRTCPCandidate = null;
        if (transportParams.rtcpIceCandidates) {
          for (var i = 0; i < transportParams.rtcpIceCandidates.length; ++i) {
            var rtcpCandidate = transportParams.rtcpIceCandidates[i];
            if (rtcpCandidate.foundation === defaultRTPCandidate.foundation) {
              defaultRTCPCandidate = rtcpCandidate;
              break;
            }
          }
        }
        return {
          0: defaultRTPCandidate,
          1: defaultRTCPCandidate
        };
      }
    }
    function _makeMediaParams(transportParams, mediaCaps, isOffer, sessionLevelDefaultCandidate) {
      var media = {
        rtp: [],
        fmtp: [],
        rtcpFb: [],
        type: mediaCaps.descr.type,
        port: 0,
        protocol: 'RTP/SAVP',
        payloads: '',
        cryptoscale: [],
        crypto: [],
        candidates: [],
        xCandidatesIpv6: []
      };
      if (!mediaCaps.descr.enabled) {
        // need to add at least 1 dummy payload type!
        if (media.type === CONSTANTS.MEDIA_TYPE.video) {
          media.payloads = '34';  // H263 - like mediamanager does
        } else {
          media.payloads = '9';  // G722
        }
        return media;
      }
      var defaultCandidates = _getDefaultCandidates(transportParams);
      var defaultCandidateRTP = defaultCandidates[0];
      var defaultCandidateRTCP = defaultCandidates[1];
      media.port = defaultCandidateRTP.port;
      // if session level default candidate has different IP than media one, then add another c line to media level
      if (sessionLevelDefaultCandidate.ip !== defaultCandidateRTP.ip) {
        media.connection = {
          version: 4,
          ip: defaultCandidateRTP.ip
        };
      }
      media.iceUfrag = transportParams.iceParams.usernameFragment;
      media.icePwd = transportParams.iceParams.password;
      if (media.type === CONSTANTS.MEDIA_TYPE.audio) {
        media.maxptime = 200;
        media.ptime = 20;
      }
      media.direction = _getDirection(mediaCaps.descr.send, mediaCaps.descr.recv);
      media.xSsrcRange = {
        ssrcMin: mediaCaps.ssrcRange.min,
        ssrcMax: mediaCaps.ssrcRange.max
      };
      media.label = mediaCaps.descr.label;
      // only first video should have x-source line
      if (!mediaCaps.bundledWithOther) {
        media.xSource = mediaCaps.descr.label;
      }
      if (mediaCaps.rtcpReducedSize) {
        media.rtcpRsize = true;
      }
      if (isOffer && mediaCaps.justAdded) {
        if (transportParams.doRtcpMux) {
          media.rtcpMux = true;
        }
        media.rtcp = { port: defaultCandidateRTCP && defaultCandidateRTCP.port || media.port + 1 };
      } else {
        if (transportParams.doRtcpMux) {
          media.rtcpMux = true;
        } else {
          media.rtcp = { port: defaultCandidateRTCP && defaultCandidateRTCP.port || media.port + 1 };
        }
      }
      var rtcpFbXMessage = null;
      if (mediaCaps.rtpCaps && mediaCaps.rtpCaps.codecs) {
        mediaCaps.rtpCaps.codecs.forEach(function (codec) {
          media.rtp.push({
            payload: codec.preferredPayloadType,
            codec: codec.name,
            rate: codec.clockRate,
            encoding: codec.numChannels > 1 ? codec.numChannels : void 0
          });
          var fmtpConfigLine = '';
          for (var paramKey in codec.parameters) {
            if (codec.parameters.hasOwnProperty(paramKey)) {
              //events=0-16 should be without events=
              if (fmtpConfigLine !== '') {
                fmtpConfigLine += ';';
              }
              fmtpConfigLine += paramKey === 'events' ? codec.parameters[paramKey] : paramKey + '=' + codec.parameters[paramKey];
            }
          }
          if (fmtpConfigLine !== '') {
            media.fmtp.push({
              payload: codec.preferredPayloadType,
              config: fmtpConfigLine
            });
          }
          media.payloads += (media.payloads ? ' ' : '') + codec.preferredPayloadType;
          // NB: assuming all codecs share the same x-message attribute!
          if (!rtcpFbXMessage) {
            for (var i = 0; i < codec.rtcpFeedback.length; i++) {
              if (_compareStr(codec.rtcpFeedback[i].type, 'x-message')) {
                rtcpFbXMessage = codec.rtcpFeedback[i].parameter;
                break;
              }
            }
          }
        });
      }
      if (rtcpFbXMessage) {
        media.rtcpFb.push({
          payload: '*',
          type: 'x-message',
          subtype: rtcpFbXMessage
        });
      }
      function mkiConfigString(keyParam) {
        return keyParam.mkiLength !== 0 ? '|' + keyParam.mkiValue + ':' + keyParam.mkiLength : '';
      }
      if (mediaCaps.sdesParamsList) {
        for (var j = 0; j < mediaCaps.sdesParamsList.length; ++j) {
          var sdesP = mediaCaps.sdesParamsList[j];
          // TODO: review rfc4568!
          if (_compareStr(sdesP.cryptoSuite, 'AES_CM_128_HMAC_SHA1_80')) {
            media.crypto.push({
              id: sdesP.tag,
              suite: 'AES_CM_128_HMAC_SHA1_80',
              config: sdesP.keyParams[0].keyMethod + ':' + sdesP.keyParams[0].keySalt + '|' + sdesP.keyParams[0].lifetime + mkiConfigString(sdesP.keyParams[0])
            });
          } else if (_compareStr(sdesP.cryptoSuite, 'SCALE_AES_CM_128_HMAC_SHA1_80')) {
            media.cryptoscale.push({
              id: sdesP.tag,
              flavor: 'client',
              suite: 'AES_CM_128_HMAC_SHA1_80',
              config: sdesP.keyParams[0].keyMethod + ':' + sdesP.keyParams[0].keySalt + '|' + sdesP.keyParams[0].lifetime + mkiConfigString(sdesP.keyParams[0])
            });
          }
        }
      }
      // ice candidates and remoteCandidates will not be added for bundled stream (other video streams after 1st one)
      if (!mediaCaps.bundledWithOther) {
        // ICE completed - add only candidate from selected iceCandidatePair
        if (transportParams.iceCandidatePair) {
          // add only selected local candidate
          _addCandidates([transportParams.iceCandidatePair.local], 1, media.candidates, media.xCandidatesIpv6);
          // add local rtcp candidate only if rtcp mux not used
          if (transportParams.rtcpIceCandidatePair && !transportParams.doRtcpMux) {
            _addCandidates([transportParams.rtcpIceCandidatePair.local], 2, media.candidates, media.xCandidatesIpv6);
          }
          // if ice role is controlling, then also add remote-candidates attribute regardless if it is offer or answer
          //if (isOffer && iceRoleControllig) { // according to spec only put remote candidates on controlling side offer but native media agent wants to always get it !
          media.remoteCandidates = '1 ' + transportParams.iceCandidatePair.remote.ip + ' ' + transportParams.iceCandidatePair.remote.port;
          // rtcp candidate pair only goes if we have agreed to not do rtcpMux
          if (!transportParams.doRtcpMux) {
            media.remoteCandidates += ' 2 ' + transportParams.rtcpIceCandidatePair.remote.ip + ' ' + transportParams.rtcpIceCandidatePair.remote.port;  // workaround - Fake the rtcp remote candidate, otherwise MA crashes!
          } else {
            media.remoteCandidates += ' 2 ' + transportParams.iceCandidatePair.remote.ip + ' ' + transportParams.iceCandidatePair.remote.port;
          }  //}
             // ICE running - add all candidates
        } else {
          // rtp ice candidates
          _addCandidates(transportParams.iceCandidates, 1, media.candidates, media.xCandidatesIpv6);
          // rtcp candidates we add always if the media stream is first added by that offer or if negotiation didn't result with rtcp muxing
          if (isOffer && mediaCaps.justAdded || !transportParams.doRtcpMux) {
            _addCandidates(transportParams.rtcpIceCandidates, 2, media.candidates, media.xCandidatesIpv6);
          }
        }
        media.candidates.sort(function (a, b) {
          return +a.foundation - +b.foundation || a.foundation === b.foundation && a.component - b.component;
        });
        media.xCandidatesIpv6.sort(function (a, b) {
          return +a.foundation - +b.foundation || a.foundation === b.foundation && a.component - b.component;
        });
        if (transportParams.dtlsParams) {
          //{"role":"auto","fingerprints":[{"algorithm":"sha-256","value":"DE:17:AB:E7:A8:EA:96:D7:FB:D7:C8:9A:1C:D3:A3:DC:87:92:6F:F9:D9:3E:12:35:C1:AD:C0:98:57:EC:F2:1D"}]}
          media.fingerprint = {
            type: transportParams.dtlsParams.fingerprints[0].algorithm,
            hash: transportParams.dtlsParams.fingerprints[0].value
          };
          switch (transportParams.dtlsParams.role) {
          case 'auto':
            media.setup = 'actpass';
            break;
          case 'client':
            media.setup = 'active';
            break;
          case 'server':
            media.setup = 'passive';
            break;
          }
        }
      }
      return media;
    }
    this.paramsToSdp = function (params) {
      var sdp = {}, activeTransport = params.transportParams[0] ? params.transportParams[0] : params.transportParams[1], hostIp = _getHostIp(activeTransport), defaultCandidates = _getDefaultCandidates(activeTransport), defaultCandidateRTP = defaultCandidates[0];
      sdp.version = 0;
      sdp.origin = {
        username: '-',
        sessionId: 0,
        sessionVersion: params.sessionVersion,
        netType: 'IN',
        ipVer: 4,
        address: hostIp
      };
      sdp.bandwidth = [{
          type: 'CT',
          limit: 99980
        }];
      sdp.timing = {
        start: 0,
        stop: 0
      };
      sdp.name = 'session';
      sdp.connection = {
        version: 4,
        ip: defaultCandidateRTP.ip
      };
      // FIXME: hardcoded table
      sdp.xMediaBw = {
        label: CONSTANTS.MEDIA_LABEL.video,
        sendBw: 8100,
        receiveBw: 8000
      };
      sdp.media = [];
      for (var i = 0; i < params.media.length; i++) {
        var transportIdx = params.media[i].descr.label === CONSTANTS.MEDIA_LABEL.audio ? 0 : 1;
        var transportParams = params.transportParams[transportIdx];
        sdp.media.push(_makeMediaParams(transportParams, params.media[i], params.isOffer, defaultCandidateRTP));
      }
      return SdpT.write(sdp);
    };
    function _getProtocol(transport) {
      var t = transport.toLowerCase();
      switch (t) {
      case 'tcp-act':
      case 'tcp-pass':
      case 'tcp-so':
        return 'tcp';
      default:
        return t;
      }
    }
    function _getTcpType(transport) {
      switch (transport.toLowerCase()) {
      case 'tcp-act':
        return 'active';
      case 'tcp-pass':
        return 'passive';
      case 'tcp-so':
        return 'so';
      default:
        return void 0;
      }
    }
    function _getCandidate(candidateIn) {
      var cand = {
        foundation: candidateIn.foundation,
        priority: candidateIn.priority,
        ip: candidateIn.ip,
        protocol: _getProtocol(candidateIn.transport),
        port: candidateIn.port,
        type: candidateIn.type
      };
      if (!_compareStr(candidateIn.type, 'host')) {
        cand.tcpType = _getTcpType(candidateIn.transport);
        cand.relatedAddress = candidateIn.raddr;
        cand.relatedPort = candidateIn.rport;
      }
      return cand;
    }
    function _getCandidates(mediaParamsSdp, type, candidatesOut) {
      // ipv4 candidates
      if (mediaParamsSdp.candidates) {
        mediaParamsSdp.candidates.forEach(function (candidate) {
          // only take RTP or RTCP
          if (candidate.component === type) {
            candidatesOut.push(_getCandidate(candidate));
          }
        });
      }
      // ipv6 candidates
      if (mediaParamsSdp.xCandidatesIpv6) {
        mediaParamsSdp.xCandidatesIpv6.forEach(function (candidate) {
          // only take RTP or RTCP
          if (candidate.component === type) {
            candidatesOut.push(_getCandidate(candidate));
          }
        });
      }
    }
    function _getKeyParamsFromConfig(configLine) {
      var regexp = /(\w+):([a-zA-Z0-9+\/]+={0,2})(\|([0-9\^]+))?(\|([0-9]+):([0-9]+))?/;
      var match = configLine.match(regexp);
      if (!match) {
        return void 0;
      }
      var res = {
        keyMethod: match[1],
        keySalt: match[2],
        mkiValue: 0,
        mkiLength: 0
      };
      if (typeof match[4] !== 'undefined') {
        res.lifetime = match[4];
      }
      if (typeof match[7] !== 'undefined') {
        res.mkiValue = +match[6];
        res.mkiLength = +match[7];
      }
      return res;
    }
    function _getTransportParams(sdpParams, mediaSdpParams) {
      var params = {};
      params.iceParams = {
        usernameFragment: mediaSdpParams.iceUfrag,
        password: mediaSdpParams.icePwd
      };
      params.iceCandidates = [];
      // only take RTP(1) candidates
      _getCandidates(mediaSdpParams, 1, params.iceCandidates);
      params.doRtcpMux = !!mediaSdpParams.rtcpMux;
      // populate rtcpIceParams, rtcpIceCandidates, rtcpDtlsParams only if no rtcpMux given
      if (!mediaSdpParams.rtcpMux) {
        params.rtcpIceParams = {
          usernameFragment: mediaSdpParams.iceUfrag,
          password: mediaSdpParams.icePwd
        };
        params.rtcpIceCandidates = [];
        // only take RTCP(2) candidates
        _getCandidates(mediaSdpParams, 2, params.rtcpIceCandidates);
      }
      if (mediaSdpParams.remoteCandidates) {
        params.iceCandidatePair = {};  // TODO, add actual candidate values.
      }
      // ff puts fingerprint to session level, chrome/ortc puts to media level. Either way is ok
      if (sdpParams.fingerprint || mediaSdpParams.fingerprint) {
        var fingerprint = mediaSdpParams.fingerprint ? mediaSdpParams.fingerprint : sdpParams.fingerprint;
        var setup = mediaSdpParams.setup ? mediaSdpParams.setup : sdpParams.setup;
        //{"role":"auto","fingerprints":[{"algorithm":"sha-256","value":"DE:17:AB:E7:A8:EA:96:D7:FB:D7:C8:9A:1C:D3:A3:DC:87:92:6F:F9:D9:3E:12:35:C1:AD:C0:98:57:EC:F2:1D"}]}
        var role = 'auto';
        switch (setup) {
        case 'actpass':
          role = 'auto';
          break;
        case 'active':
          role = 'client';
          break;
        case 'passive':
          role = 'server';
          break;
        }
        params.dtlsParams = {
          role: role,
          fingerprints: [{
              algorithm: fingerprint.type,
              value: fingerprint.hash
            }]
        };
      }
      return params;
    }
    function _getRTPCaps(mediaSdpParams) {
      var codecs = [];
      mediaSdpParams.rtp.forEach(function (rtpDescr) {
        codecs.push({
          name: rtpDescr.codec,
          kind: mediaSdpParams.type,
          clockRate: rtpDescr.rate,
          preferredPayloadType: rtpDescr.payload,
          numChannels: rtpDescr.encoding ? rtpDescr.encoding : 1,
          rtcpFeedback: []
        });
      });
      return {
        codecs: codecs,
        headerExtensions: [],
        fecMechanisms: []
      };
    }
    function _getMediaDescriptor(mediaSdpParams) {
      if (!mediaSdpParams.direction) {
        mediaSdpParams.direction = 'sendrecv';
      }
      var direction = mediaSdpParams.direction.toLowerCase();
      var enabled = parseInt(mediaSdpParams.port, 10) !== 0;
      return {
        enabled: enabled,
        type: mediaSdpParams.type,
        label: mediaSdpParams.label,
        send: enabled ? direction === 'sendrecv' || direction === 'sendonly' : false,
        recv: enabled ? direction === 'sendrecv' || direction === 'recvonly' : false
      };
    }
    function _getMediaParams(mediaSdpParams) {
      var sdesParamsList = [];
      function addSdesParams(tag, suite, keyParams, sessionParams) {
        sdesParamsList.push({
          tag: tag,
          cryptoSuite: suite,
          keyParams: keyParams,
          sessionParams: sessionParams
        });
      }
      var descr = _getMediaDescriptor(mediaSdpParams);
      if (!descr.enabled) {
        return {
          descr: descr,
          rtpCaps: null,
          ssrcRange: null,
          rtcpReducedSize: false
        };
      } else {
        if (mediaSdpParams.cryptoscale) {
          mediaSdpParams.cryptoscale.forEach(function (elem) {
            var keyParams = _compareStr(elem.flavor, 'server') ? _getKeyParamsFromConfig(elem.config) : void 0;
            if (keyParams) {
              addSdesParams(elem.id, 'SCALE_' + elem.suite, [keyParams], []);
            }
          });
        }
        if (mediaSdpParams.crypto) {
          mediaSdpParams.crypto.forEach(function (elem) {
            var keyParams = _getKeyParamsFromConfig(elem.config);
            if (keyParams) {
              addSdesParams(elem.id, elem.suite, [keyParams], []);
            }
          });
        }
        return {
          descr: _getMediaDescriptor(mediaSdpParams),
          rtpCaps: _getRTPCaps(mediaSdpParams),
          sdesParamsList: sdesParamsList,
          ssrcRange: {
            min: mediaSdpParams.xSsrcRange ? mediaSdpParams.xSsrcRange.ssrcMin : 0,
            max: mediaSdpParams.xSsrcRange ? mediaSdpParams.xSsrcRange.ssrcMax : 0
          },
          rtcpReducedSize: mediaSdpParams.rtcpRsize ? true : false
        };
      }
    }
    this.sdpToParams = function (sdp) {
      var sdpParams = SdpT.parse(sdp);
      var params = {
        sessionVersion: sdpParams.origin.sessionVersion,
        transportParams: [],
        media: []
      };
      // assuming all media lines are always present. if not active, port will be 0
      for (var i = 0; i < sdpParams.media.length; i++) {
        var sdpMedia = sdpParams.media[i];
        var media = _getMediaParams(sdpMedia);
        params.media.push(media);
        if (media.descr.enabled) {
          var transportIdx = media.descr.label === CONSTANTS.MEDIA_LABEL.audio ? 0 : 1;
          if (typeof params.transportParams[transportIdx] === 'undefined') {
            params.transportParams[transportIdx] = _getTransportParams(sdpParams, sdpMedia);
          }
        }
      }
      return params;
    };
  }
  return OrtcSdp;
}(vendorSdpTransform, constants);
ortcSession = function (OrtcTransport, OrtcMediaChannel, OrtcParameters, OrtcSdp, CONSTANTS, helper) {
  function OrtcState() {
    var _that = this;
    this.STABLE = 'stable';
    this.NEGOTIATION_REQUESTED = 'negotiation_requested';
    this.HAVE_LOCAL_OFFER = 'have_local_offer';
    this.HAVE_REMOTE_PRANSWER = 'have_remote_pranswer';
    this.HAVE_REMOTE_ANSWER = 'have_remote_answer';
    this.HAVE_REMOTE_OFFER = 'have_remote_offer';
    this.HAVE_LOCAL_PRANSWER = 'have_local_pranswer';
    this.HAVE_LOCAL_ANSWER = 'have_local_answer';
    this.TERMINATED = 'terminated';
    this.state = _that.STABLE;
    this.changing = false;
    function _stateChangeError(newState) {
      throw new Error('Invalid state change:' + _that.state + ' ' + newState + ' changing: ' + _that.changing);
    }
    this.change = function (newState, changing) {
      if (_that.busy) {
        _stateChangeError(newState);
      }
      if (changing) {
        _that.changing = changing;
      }
      switch (newState) {
      case _that.STABLE:
        if (_that.state !== _that.HAVE_REMOTE_ANSWER && _that.state !== _that.HAVE_LOCAL_ANSWER) {
          _stateChangeError(newState);
        }
        break;
      case _that.NEGOTIATION_REQUESTED:
        if (_that.state !== _that.STABLE) {
          _stateChangeError(newState);
        }
        break;
      case _that.HAVE_LOCAL_OFFER:
        if (_that.state !== _that.STABLE && _that.state !== _that.NEGOTIATION_REQUESTED) {
          _stateChangeError(newState);
        }
        break;
      case _that.HAVE_REMOTE_PRANSWER:
      case _that.HAVE_REMOTE_ANSWER:
        if (_that.state !== _that.HAVE_LOCAL_OFFER && _that.state !== _that.HAVE_REMOTE_PRANSWER) {
          _stateChangeError(newState);
        }
        break;
      case _that.HAVE_REMOTE_OFFER:
        if (_that.state !== _that.STABLE && _that.state !== _that.NEGOTIATION_REQUESTED) {
          _stateChangeError(newState);
        }
        break;
      case _that.HAVE_LOCAL_PRANSWER:
      case _that.HAVE_LOCAL_ANSWER:
        if (_that.state !== _that.HAVE_REMOTE_OFFER && _that.state !== _that.HAVE_LOCAL_PRANSWER) {
          _stateChangeError(newState);
        }
        break;
      case _that.TERMINATED:
        break;
      default:
        _stateChangeError(newState);
      }
      _that.state = newState;
    };
    this.complete = function () {
      _that.changing = false;
    };
  }
  function ORtcSession(_context, _callId, _callback) {
    this.configureModalitiesAsync = _configureModalitiesAsync;
    this.processOfferAsync = _processOfferAsync;
    this.createAnswerAsync = _createAnswerAsync;
    this.createOfferAsync = _createOfferAsync;
    this.processAnswerAsync = _processAnswerAsync;
    this.completeNegotiationAsync = _completeNegotiationAsync;
    this.rejectNegotiationAsync = _rejectNegotiationAsync;
    this.createRemoteRenderer = _createRemoteRenderer;
    this.getStatsAsync = _getStatsAsync;
    this.terminate = _terminate;
    this._deviceSelectionChanged = _deviceSelectionChanged;
    this._onTerminated = null;
    var _settings = _context.maContext.settings;
    var _numVideoChannels = _context.config.isConference && _settings.numVideoChannelsGvc ? _settings.numVideoChannelsGvc : 1;
    var ssrcBase = Math.floor(Math.random() * 150994943 + 150994943);
    var LOCAL_AUDIO_SSRC_RANGE = {
      min: ssrcBase,
      max: ssrcBase
    };
    var LOCAL_VIDEO_SSRC_RANGE_BASE = ssrcBase + 1;
    var LOCAL_VIDEO_SSRC_RANGE_STEP = 100;
    var _logger = _context.getLogger();
    var _deviceManager = _context.getDeviceManager();
    var _that = this;
    var _enableRtcpDemux = true;
    // if not set, will not create rtcp icetrandport nor put separate rtcp candidates to the offer. For experimenting only, _enableRtcpDemux = false does not work with NAMA
    var _offeredParams = null;
    var _answeredParams = null;
    var _negotiatedParams = null;
    var _ortcPrm = new OrtcParameters();
    var _audio = null;
    //html audio element, does not have to be in dom
    var _subscriptionMap = {};
    var _ortcSdp = new OrtcSdp();
    var _state = new OrtcState();
    var _mediaChannels = [];
    // this has 1:1 mapping to media lines in SDP and to (_offered|_answered|_negotiated)Params.media[] arrays
    var _activeModalities = {};
    var _configuredModalities;
    var _negotiatingModalities;
    var _forceRenegotiation = false;
    var _transportCb = {
      triggerIceReinvite: function () {
        if (_settings.disableIceReinvite) {
          _logger.log('ICE-reinvite disabled - triggerIceReinvite skipped');
          return;
        }
        _logger.log('triggerIceReinvite');
        _triggerRenegotiation(true);
      },
      raiseError: function (error) {
        _raiseError({
          type: CONSTANTS.MEDIA_ERROR.internalError,
          detail: error
        });
      }
    };
    var _transport = new OrtcTransport(_logger, _settings, _transportCb, _context.maContext.getRelayManager(), _context.config.isRemoteClientLync, _enableRtcpDemux);
    _logger.log('create session', 'config:', _context.config);
    function _getVideoSsrcRange(idx) {
      var videoSsrcRangeBase = LOCAL_VIDEO_SSRC_RANGE_BASE + idx * LOCAL_VIDEO_SSRC_RANGE_STEP;
      return {
        min: videoSsrcRangeBase,
        max: videoSsrcRangeBase + LOCAL_VIDEO_SSRC_RANGE_STEP - 1
      };
    }
    // create new channel if missing. Never delete any channels here. _assureChannels is called in createoffer/createanswer.
    // Since channel creation is not modifying existing rtp sessions, there's no problem if negotiation gets rejected
    function _assureChannels(descrs) {
      var videoIdx = 0;
      for (var i = 0; i < descrs.length; i++) {
        if (descrs[i].label === CONSTANTS.MEDIA_LABEL.audio && typeof _mediaChannels[i] === 'undefined') {
          _mediaChannels[i] = new OrtcMediaChannel(_logger.createChild('AStrm:'), _settings, descrs[i].type, descrs[i].label, _raiseError, LOCAL_AUDIO_SSRC_RANGE, _callId, 'AStrm');
        } else if (descrs[i].label === CONSTANTS.MEDIA_LABEL.video) {
          if (typeof _mediaChannels[i] === 'undefined') {
            _mediaChannels[i] = new OrtcMediaChannel(_logger.createChild('VStrm' + videoIdx + ':'), _settings, descrs[i].type, descrs[i].label, _raiseError, _getVideoSsrcRange(videoIdx), _callId, 'VStrm');
          }
          videoIdx++;
        }
        if (_mediaChannels[i] && _mediaChannels[i].type !== descrs[i].type) {
          throw new Error('Error in media descriptors ch.type: ' + _mediaChannels[i].type + ' descr.type: ' + descrs[i].type);
        }
        if (_mediaChannels[i] && _mediaChannels[i].label !== descrs[i].label) {
          throw new Error('Error in media descriptors ch.label: ' + _mediaChannels[i].label + ' descr.label: ' + descrs[i].label);
        }
      }
    }
    function _findFirstChannelByLabel(channels, label) {
      for (var i = 0; i < channels.length; i++) {
        if (channels[i].label === label) {
          return channels[i];
        }
      }
      return null;
    }
    function _raiseError(mediaError) {
      _logger.error('Media error occurred', 'type:', mediaError.type, 'detail:', mediaError.detail);
      _callback.onSessionErrorOccurred(mediaError);
    }
    function _updateSubscribedRenderers() {
      for (var k in _subscriptionMap) {
        if (_subscriptionMap.hasOwnProperty(k)) {
          _subscriptionMap[k].update();
        }
      }
    }
    function _unsubscribeRenderers() {
      for (var k in _subscriptionMap) {
        if (_subscriptionMap.hasOwnProperty(k)) {
          _subscriptionMap[k].dispose();
        }
      }
    }
    function _startOrRestartAudio(audioTrack) {
      if (!_audio) {
        _audio = document.createElement('audio');
        document.body.appendChild(_audio);
        _audio.autoplay = true;
        _audio.addEventListener('error', function () {
          _logger.error('_audio.onerror', 'error:', _audio ? _audio.error : '<no audio element>');
        });
      } else {
        window.detachMediaStream(_audio);
      }
      var audioRecvStream = new MediaStream([audioTrack]);
      window.attachMediaStream(_audio, audioRecvStream);
    }
    function _stopAudio() {
      if (_audio) {
        document.body.removeChild(_audio);
        window.detachMediaStream(_audio);
        _audio = null;
      }
    }
    function _getStateFromDescr(descr) {
      if (descr.enabled) {
        if (descr.send && descr.recv) {
          return CONSTANTS.MEDIA_STATE.sendReceive;
        } else if (descr.send) {
          return CONSTANTS.MEDIA_STATE.send;
        } else if (descr.recv) {
          return CONSTANTS.MEDIA_STATE.receive;
        } else {
          return CONSTANTS.MEDIA_STATE.inactive;
        }
      } else {
        return null;
      }
    }
    function getTypeForLabel(label) {
      if (label === CONSTANTS.MEDIA_LABEL.audio) {
        return CONSTANTS.MEDIA_TYPE.audio;
      } else if (label === CONSTANTS.MEDIA_LABEL.video) {
        return CONSTANTS.MEDIA_TYPE.video;
      } else if (label === CONSTANTS.MEDIA_LABEL.screensharing) {
        return CONSTANTS.MEDIA_TYPE.video;
      } else {
        throw new Error('unsupported label');
      }
    }
    function _getDescrFromState(state, label) {
      return {
        enabled: !!state,
        type: getTypeForLabel(label),
        label: label,
        send: helper.hasSendDirectionality(state),
        recv: helper.hasReceiveDirectionality(state)
      };
    }
    function _findDescrFromMedia(media, label) {
      for (var i = 0; i < media.length; i++) {
        if (media[i].descr.label === label) {
          return media[i].descr;
        }
      }
      return {
        enabled: false,
        type: getTypeForLabel(label),
        label: label,
        send: false,
        recv: false
      };
    }
    function _getModalitiesFromParams(remoteParams) {
      var modalities = {};
      var audioDescr = _findDescrFromMedia(remoteParams.media, CONSTANTS.MEDIA_LABEL.audio);
      var videoDescr = _findDescrFromMedia(remoteParams.media, CONSTANTS.MEDIA_LABEL.video);
      if (audioDescr.enabled) {
        modalities.audio = _getStateFromDescr(audioDescr);
      }
      if (videoDescr.enabled) {
        modalities.video = _getStateFromDescr(videoDescr);
      }
      return modalities;
    }
    function _negotiateMediaDescriptor(localDescr, remoteDescr) {
      if (!remoteDescr) {
        remoteDescr = {
          enabled: true,
          send: true,
          recv: true
        };
      }
      var send = localDescr.send && localDescr.enabled && remoteDescr.recv && remoteDescr.enabled;
      var recv = localDescr.recv && localDescr.enabled && remoteDescr.send && remoteDescr.enabled;
      // NB: put media into inactive only if someone explicitly specified inactive (enabled true, send false, recv false)
      var enabled = localDescr.enabled && remoteDescr.enabled && (send || recv || !localDescr.send && !localDescr.recv || !remoteDescr.send && !remoteDescr.recv);
      return {
        enabled: enabled,
        type: localDescr.type,
        label: localDescr.label,
        send: send,
        recv: recv
      };
    }
    function _createMediaDescriptorsForOffer(localModalities, negotiatedParams) {
      var descrs = [];
      var descr;
      var audioAdded = false;
      var videoAddedCnt = 0;
      // first check if already negotiated sdp has slots for audio & video, if yes, reuse them. Also if it has some extra slots, make sure they are rejected
      if (negotiatedParams) {
        for (var i = 0; i < negotiatedParams.media.length; i++) {
          if (negotiatedParams.media[i].descr.label === CONSTANTS.MEDIA_LABEL.audio && !audioAdded) {
            descr = _getDescrFromState(localModalities.audio, CONSTANTS.MEDIA_LABEL.audio);
            descrs.push(descr);
            audioAdded = true;
          } else if (negotiatedParams.media[i].descr.label === CONSTANTS.MEDIA_LABEL.video && videoAddedCnt < _numVideoChannels) {
            descr = _getDescrFromState(localModalities.video, CONSTANTS.MEDIA_LABEL.video);
            // results rejected if no localModalities.audio
            //  send can be on only for first video channel
            if (videoAddedCnt > 0) {
              descr.send = false;
            }
            descrs.push(descr);
            videoAddedCnt++;  // reject slot
          } else {
            descrs.push({
              enabled: false,
              type: negotiatedParams.media[i].descr.type,
              label: negotiatedParams.media[i].descr.label
            });
          }
        }
      }
      if (!audioAdded && localModalities.audio) {
        descr = _getDescrFromState(localModalities.audio, CONSTANTS.MEDIA_LABEL.audio);
        // results rejected if no localModalities.audio
        descrs.push(descr);
      }
      for (var j = videoAddedCnt; j < _numVideoChannels && localModalities.video; j++) {
        descr = _getDescrFromState(localModalities.video, CONSTANTS.MEDIA_LABEL.video);
        //  send can be on only for first video channel
        if (j > 0) {
          descr.send = false;
        }
        descrs.push(descr);
      }
      return descrs;
    }
    function _createMediaDescriptorsForAnswer(localModalities, negotiatedParams, remoteOffer) {
      // answer can't add anything, it's possible that remote side added something however
      if (negotiatedParams && negotiatedParams.media.length > remoteOffer.media.length) {
        throw new Error('Invalid remote offer - removed media lines');
      }
      var descrs = [];
      var descr;
      var audioAdded = false;
      var videoAddedCnt = 0;
      for (var i = 0; i < remoteOffer.media.length; i++) {
        // things which are not supported
        if (negotiatedParams && negotiatedParams.media[i]) {
          if (negotiatedParams.media[i].type !== remoteOffer.media[i].type) {
            throw new Error('Changing media type not supported');  // allowed by RFC but not supported here..
          }
          if (negotiatedParams.media[i].label && remoteOffer.media[i].label && negotiatedParams.media[i].label !== remoteOffer.media[i].label) {
            throw new Error('Changing media label not supported');  // allowed by RFC but not supported here..
          }
        }
        if (remoteOffer.media[i].descr.label === CONSTANTS.MEDIA_LABEL.audio && !audioAdded) {
          descr = _negotiateMediaDescriptor(_getDescrFromState(localModalities.audio, CONSTANTS.MEDIA_LABEL.audio), remoteOffer.media[i].descr);
          descrs.push(descr);
          audioAdded = true;
        } else if (remoteOffer.media[i].descr.label === CONSTANTS.MEDIA_LABEL.video && videoAddedCnt < _numVideoChannels) {
          descr = _negotiateMediaDescriptor(_getDescrFromState(localModalities.video, CONSTANTS.MEDIA_LABEL.video), remoteOffer.media[i].descr);
          //  send can be on only for first video channel
          if (videoAddedCnt > 0) {
            descr.send = false;
          }
          descrs.push(descr);
          videoAddedCnt++;  // reject slot
        } else {
          descrs.push({
            enabled: false,
            type: remoteOffer.media[i].descr.type,
            label: negotiatedParams && negotiatedParams.media[i] ? negotiatedParams.media[i].descr.label : remoteOffer.media[i].descr.label
          });
        }
      }
      return descrs;
    }
    function _createTransportParams(localTransportParams, remoteParams) {
      var remoteTransportParams = remoteParams ? remoteParams.transportParams : [];
      for (var i = 0; i < localTransportParams.length; i++) {
        if (localTransportParams[i]) {
          // by default prefer rtcp-mux. If other side asked for demux then use demux
          localTransportParams[i].doRtcpMux = remoteTransportParams[i] && !remoteTransportParams[i].doRtcpMux ? false : true;
        }
        if (localTransportParams[i] && remoteTransportParams[i]) {
          var canUseSdes = false;
          // detect if we can use SDES - if it's not disabled locally and remote side had sdesParamsList
          for (var m = 0; !_settings.disableSdes && m < remoteParams.media.length; m++) {
            if (remoteParams.media[m].sdesParamsList && remoteParams.media[m].sdesParamsList.length) {
              canUseSdes = true;
            }
          }
          if (remoteTransportParams[i].doRtcpMux) {
            localTransportParams[i].rtcpIceParams = null;
            localTransportParams[i].rtcpIceCandidates = null;
          }
          // since ortc doesn't set dtlstransport role correctly, need to overwrite it here based on remote parameters
          // ortc always returns role 'auto' which is ok for first offer. For subsequent offers/answers need to use either 'client'
          // or 'server' based on what's negotiated for this session(https://tools.ietf.org/html/rfc5763)
          if (localTransportParams[i].dtlsParams && remoteTransportParams[i].dtlsParams) {
            localTransportParams[i].dtlsParams.role = remoteTransportParams[i].dtlsParams.role === 'client' ? 'server' : 'client';
          }
          // if sdes usage is possible, don't use dtls.
          // Also no point to use dtls parameters if remote side didn't have dtls params
          if (canUseSdes || !remoteTransportParams[i].dtlsParams) {
            localTransportParams[i].dtlsParams = null;
          }
        } else {
          // workaround for old clients which don't tolerate setup=actpass - in first offer never put setup (dtlsparams.role) attribute
          if (localTransportParams[i] && localTransportParams[i].dtlsParams) {
            localTransportParams[i].dtlsParams.role = null;
          }
        }
      }
      return localTransportParams;
    }
    function _createMediaParams(descr, channelParams, justAdded, bundledWithOther, rtcpReducedSize) {
      if (!descr.enabled) {
        return { descr: descr };
      } else {
        var params = channelParams;
        params.descr = descr;
        params.justAdded = justAdded;
        params.bundledWithOther = bundledWithOther;
        params.rtcpReducedSize = rtcpReducedSize;
        return params;
      }
    }
    function _createOffer(descrs, localTransportParams, rtcpReducedSize) {
      var offer = {
        isOffer: true,
        sessionVersion: _negotiatedParams ? _negotiatedParams.sessionVersion : 0,
        transportParams: _createTransportParams(localTransportParams, _negotiatedParams),
        media: []
      };
      var firstVideoChannelSeen = false;
      for (var i = 0; i < descrs.length; i++) {
        var mediaJustAdded = (!_negotiatedParams || !_negotiatedParams.media[i] || !_negotiatedParams.media[i].descr.enabled) && descrs[i].enabled;
        var channelParams;
        if (mediaJustAdded) {
          channelParams = _mediaChannels[i].getLocalParameters();
        } else {
          channelParams = _negotiatedParams.media[i];
        }
        var bundledWithOther = firstVideoChannelSeen && descrs[i].label === CONSTANTS.MEDIA_LABEL.video;
        // video streams except 1st one
        if (descrs[i].label === CONSTANTS.MEDIA_LABEL.video) {
          firstVideoChannelSeen = true;
        }
        offer.media.push(_createMediaParams(descrs[i], channelParams, mediaJustAdded, bundledWithOther, rtcpReducedSize));
      }
      return offer;
    }
    function _matchChannelParams(localChannelParams, remoteChannelParams, isOfferer) {
      var matchingSdes;
      if (localChannelParams.sdesParamsList && remoteChannelParams.sdesParamsList) {
        matchingSdes = _ortcPrm.findMatchingSdesParams(localChannelParams.sdesParamsList, remoteChannelParams.sdesParamsList);
      }
      var sdesParamsList = [];
      var remoteSdesParams;
      if (matchingSdes) {
        sdesParamsList.push(matchingSdes.localSdesParams);
        remoteSdesParams = matchingSdes.remoteSdesParams;
      }
      return {
        ssrcRange: localChannelParams.ssrcRange,
        remoteSsrcRange: remoteChannelParams.ssrcRange,
        sdesParamsList: sdesParamsList,
        remoteSdesParams: remoteSdesParams,
        rtpCaps: _ortcPrm.matchRtpCaps(localChannelParams.rtpCaps, remoteChannelParams.rtpCaps, isOfferer)
      };
    }
    function _verifyTransportAndMediaParams(descr, transportParams, channelParams) {
      if (descr.enabled) {
        // no sdes params
        if (!channelParams.sdesParamsList.length || !channelParams.remoteSdesParams) {
          // also dtls not enabled or no dtls params
          if (!transportParams.dtlsParams) {
            _logger.warn('no sdes nor dtls params:', channelParams.sdesParamsList, channelParams.remoteSdesParams, transportParams.dtlsParams);
            return false;
          }
        }
        if (!channelParams.rtpCaps.codecs.length) {
          _logger.warn('no common codecs!', channelParams.rtpCaps);
          return false;
        }
      }
      return true;
    }
    function _createAnswer(descrs, offerParams, localTransportParams) {
      var answer = {
        isOffer: false,
        sessionVersion: offerParams.sessionVersion,
        transportParams: _createTransportParams(localTransportParams, offerParams),
        media: []
      };
      var firstVideoChannelSeen = false;
      for (var i = 0; i < descrs.length; i++) {
        var bundledWithOther = firstVideoChannelSeen && descrs[i].label === CONSTANTS.MEDIA_LABEL.video;
        // video streams except 1st one
        if (descrs[i].label === CONSTANTS.MEDIA_LABEL.video) {
          firstVideoChannelSeen = true;
        }
        var channelParams;
        var descr = helper.shallowClone(descrs[i]);
        if (descr.enabled) {
          channelParams = _matchChannelParams(_mediaChannels[i].getLocalParameters(), offerParams.media[i], false);
          var transportIdx = descr.label === CONSTANTS.MEDIA_LABEL.audio ? 0 : 1;
          var transportParams = answer.transportParams[transportIdx];
          if (!_verifyTransportAndMediaParams(descr, transportParams, channelParams)) {
            descr.enabled = false;
            _logger.warn('Rejecting media since unable to match parameters');
          }
          if (channelParams.sdesParamsList.length && channelParams.remoteSdesParams) {
            channelParams.sdesParamsList[0].tag = channelParams.remoteSdesParams.tag;  // answer needs to contain selected tag from offer
          }
        }
        answer.media.push(_createMediaParams(descr, channelParams, false, bundledWithOther, offerParams.media[i].rtcpReducedSize));
      }
      return answer;
    }
    function _getNegotiatedTransportParams(localTransportP, remoteTransportP) {
      var transportP = [];
      for (var i = 0; i < Math.max(localTransportP.length, remoteTransportP.length); i++) {
        var negotiatedP = null;
        if (localTransportP[i] && remoteTransportP[i]) {
          negotiatedP = helper.shallowClone(remoteTransportP[i]);
          negotiatedP.doRtcpMux = localTransportP[i].doRtcpMux && remoteTransportP[i].doRtcpMux;
          negotiatedP.enableDtls = localTransportP[i].dtlsParams && remoteTransportP[i].dtlsParams;
        }
        transportP.push(negotiatedP);
      }
      return transportP;
    }
    function _getNegotiatedMediaParams(localMediaP, remoteMediaP, negotiatedTransportP, isOfferer) {
      var descr = _negotiateMediaDescriptor(localMediaP.descr, remoteMediaP.descr);
      var mediaParams = { descr: descr };
      if (descr.enabled) {
        var transportIdx = descr.label === CONSTANTS.MEDIA_LABEL.audio ? 0 : 1;
        var transportParams = negotiatedTransportP[transportIdx];
        mediaParams = _matchChannelParams(localMediaP, remoteMediaP, isOfferer);
        if (!_verifyTransportAndMediaParams(descr, transportParams, mediaParams)) {
          throw new Error('Failed to verify negotiated parameters!');
        }
        mediaParams.descr = descr;
        mediaParams.rtcpMux = transportParams.doRtcpMux;
        mediaParams.rtcpReducedSize = localMediaP.rtcpReducedSize && remoteMediaP.rtcpReducedSize;
        mediaParams.enableDtls = transportParams.enableDtls;
      }
      return mediaParams;
    }
    function _getNegotiatedParams(isOfferer, offerParams, answerParams) {
      if (offerParams.media.length !== answerParams.media.length) {
        throw new Error('Number of media lines doesn\'t match in offer & answer' + offerParams.media.length + ' a: ' + answerParams.media.length);
      }
      var localParams, remoteParams;
      if (isOfferer) {
        localParams = offerParams;
        remoteParams = answerParams;
      } else {
        localParams = answerParams;
        remoteParams = offerParams;
      }
      var negotiatedParams = {
        sessionVersion: offerParams.sessionVersion,
        transportParams: _getNegotiatedTransportParams(localParams.transportParams, remoteParams.transportParams),
        media: []
      };
      for (var i = 0; i < offerParams.media.length; i++) {
        negotiatedParams.media.push(_getNegotiatedMediaParams(localParams.media[i], remoteParams.media[i], negotiatedParams.transportParams, isOfferer));
      }
      return negotiatedParams;
    }
    function _triggerRenegotiation(forceRenegotiation) {
      if (_state.state === _state.STABLE && !_state.changing) {
        _state.change(_state.NEGOTIATION_REQUESTED);
        _logger.log('triggerNegotiation', 'mods:', JSON.stringify(_configuredModalities), 'force:', forceRenegotiation);
        _forceRenegotiation = false;
        _callback.onNegotiationRequired();  // if we have remote offer or have sent provisional answer, just apply the modality change in the answer.
      } else {
        if (forceRenegotiation) {
          _forceRenegotiation = true;
        }
      }
    }
    function _configureModalitiesAsync(modalities) {
      return new Promise(function (resolve) {
        if (!modalities || !modalities.audio && !modalities.video) {
          throw new Error('Invalid parameters!' + JSON.stringify(modalities));
        }
        _configuredModalities = modalities;
        //assign always as if negotiated already confirms to desired but current configured is different (other side did not want to receive)
        var needNewRenegotiation = !helper.areNegotiatedDirectionsFulfilled(modalities, _activeModalities);
        if (needNewRenegotiation) {
          _triggerRenegotiation();  //NB! if we want to _triggerRenegotiation also from onnegotiationneeded then in here we could check for stable peer connection state also
        }
        resolve();
      });
    }
    function _processOfferAsync(offer) {
      return new Promise(function (resolve) {
        _logger.debug('PROCESS OFFER', 'sdp:', offer);
        _state.change(_state.HAVE_REMOTE_OFFER);
        if (!_ortcSdp) {
          _offeredParams = offer;
        } else {
          _offeredParams = _ortcSdp.sdpToParams(offer);
          _logger.debug('PROCESS OFFER', 'params:', JSON.stringify(_offeredParams));
        }
        resolve(helper.invertModalities(_getModalitiesFromParams(_offeredParams)));
      });
    }
    function _createAnswerAsync(provisional) {
      return new Promise(function (resolve) {
        if (provisional) {
          _state.change(_state.HAVE_LOCAL_PRANSWER, true);
          _negotiatingModalities = {
            audio: 'sendrecv',
            video: 'sendrecv'
          };  // sendrecv for provisional
        } else {
          _state.change(_state.HAVE_LOCAL_ANSWER, true);
          if (!_configuredModalities) {
            throw new Error('Modalities not configured for answer');
          }
          _negotiatingModalities = _configuredModalities;  // take snapshot
        }
        var descrs = _createMediaDescriptorsForAnswer(_negotiatingModalities, _negotiatedParams, _offeredParams);
        function isModalityEnabled(label, descr) {
          return descr.label === label && descr.enabled;
        }
        var hasAudio = descrs.some(isModalityEnabled.bind(null, CONSTANTS.MEDIA_LABEL.audio));
        var hasVideo = descrs.some(isModalityEnabled.bind(null, CONSTANTS.MEDIA_LABEL.video));
        // New IceTransports will be created now internally if needed.
        // If created in the _createAnswerAsync, they will have the iceRole 'controlled'
        var ret = _transport.assureInitAsync('controlled', [
          hasAudio,
          hasVideo
        ]).then(function () {
          // depending on ice reinvite state we may need to wait ICE completed on answerer before sending answer
          return _transport.waitIceCompletionIfNeededAsync(_offeredParams.transportParams).then(function () {
            return _transport.getLocalParamsAsync().then(function (localTransportParams) {
              _assureChannels(descrs);
              _answeredParams = _createAnswer(descrs, _offeredParams, localTransportParams);
              _logger.debug(provisional ? 'CREATE PRANSWER' : 'CREATE ANSWER', 'params:', JSON.stringify(_answeredParams));
              _state.complete();
              if (!_ortcSdp) {
                return _answeredParams;
              } else {
                var answer = _ortcSdp.paramsToSdp(_answeredParams);
                _logger.debug(provisional ? 'CREATE PRANSWER' : 'CREATE ANSWER', 'sdp:', answer);
                return answer;
              }
            });
          });
        });
        resolve(ret);
      });
    }
    function _createOfferAsync() {
      return new Promise(function (resolve) {
        _state.change(_state.HAVE_LOCAL_OFFER, true);
        _negotiatingModalities = _configuredModalities;
        // take snapshot
        var descrs = _createMediaDescriptorsForOffer(_negotiatingModalities, _negotiatedParams);
        // New IceTransports will be created now internally if needed.
        // If created in the _createOfferAsync, they will have the iceRole 'controlling'
        var ret = _transport.assureInitAsync('controlling', [
          !!_negotiatingModalities.audio,
          !!_negotiatingModalities.video
        ]).then(function () {
          return _transport.getLocalParamsAsync().then(function (localTransportParams) {
            _assureChannels(descrs);
            _offeredParams = _createOffer(descrs, localTransportParams, true);
            _logger.debug('CREATE OFFER', 'params:', JSON.stringify(_offeredParams));
            _state.complete();
            if (!_ortcSdp) {
              return _offeredParams;
            } else {
              var offer = _ortcSdp.paramsToSdp(_offeredParams);
              _logger.debug('CREATE OFFER', 'sdp:', offer);
              return offer;
            }
          });
        });
        resolve(ret);
      });
    }
    function _processAnswerAsync(answer, provisional) {
      return new Promise(function (resolve) {
        _logger.debug(provisional ? 'PROCESS PRANSWER' : 'PROCESS ANSWER', 'sdp:', answer);
        if (provisional) {
          _state.change(_state.HAVE_REMOTE_PRANSWER);
          _logger.log('ignoring provisional answer');
          resolve();
        } else {
          _state.change(_state.HAVE_REMOTE_ANSWER);
          if (!_ortcSdp) {
            _answeredParams = answer;
          } else {
            _answeredParams = _ortcSdp.sdpToParams(answer);
            _logger.debug('PROCESS ANSWER', 'params:', JSON.stringify(_answeredParams));
          }
          resolve(helper.invertModalities(_getModalitiesFromParams(_answeredParams)));
        }
      });
    }
    function _getMediaIfNeededAsync(audio, video) {
      if (audio || video) {
        return _deviceManager.getMediaStreamRefAsync({
          audio: audio,
          video: video
        });
      } else {
        return Promise.resolve();
      }
    }
    function _completeNegotiationAsync() {
      return new Promise(function (resolve) {
        var negotiatedParams = _getNegotiatedParams(_state.state === _state.HAVE_REMOTE_ANSWER, _offeredParams, _answeredParams);
        _state.change(_state.STABLE, true);
        _logger.debug('NEGOTIATED', 'params:', JSON.stringify(negotiatedParams));
        var audioDescr = _findDescrFromMedia(negotiatedParams.media, CONSTANTS.MEDIA_LABEL.audio);
        var videoDescr = _findDescrFromMedia(negotiatedParams.media, CONSTANTS.MEDIA_LABEL.video);
        resolve(Promise.all([
          _transport.configureTransportAsync(negotiatedParams.transportParams, [
            audioDescr.enabled,
            videoDescr.enabled
          ]),
          _getMediaIfNeededAsync(audioDescr.send, videoDescr.send)
        ]).then(function (results) {
          var localMediaStreamRef = results[1];
          // build list of MSIs user can subscribe
          try {
            for (var i = 0; i < negotiatedParams.media.length; i++) {
              if (negotiatedParams.media[i].descr.label === CONSTANTS.MEDIA_LABEL.audio) {
                var oldRecvTrack = _mediaChannels[i].getRecvTrack();
                _mediaChannels[i].configureChannel(_transport.audioTransport, localMediaStreamRef, negotiatedParams.media[i]);
                // if audio receiver started
                if (_mediaChannels[i].getRecvTrack() && _mediaChannels[i].getRecvTrack() !== oldRecvTrack) {
                  _startOrRestartAudio(_mediaChannels[i].getRecvTrack());
                  _mediaChannels[i].onContributingSourcesChanged = _callback.onContributingSourcesChanged;  // if audio receiver stopped
                } else if (!_mediaChannels[i].getRecvTrack() && oldRecvTrack) {
                  _stopAudio();
                  _mediaChannels[i].onContributingSourcesChanged = null;
                }
              } else if (negotiatedParams.media[i].descr.label === CONSTANTS.MEDIA_LABEL.video) {
                _mediaChannels[i].configureChannel(_transport.videoTransport, localMediaStreamRef, negotiatedParams.media[i]);
              } else {
                throw new Error('Invalid descriptor:', negotiatedParams.media[i].descr);
              }
            }
          } finally {
            // release the ref here, _mediaChannels performed localMediaStreamRef.clone() if they needed it
            if (localMediaStreamRef) {
              localMediaStreamRef.dispose();
            }
          }
          _updateSubscribedRenderers();
          _negotiatedParams = negotiatedParams;
          _negotiatedParams.sessionVersion++;
          _state.complete();
          _activeModalities = _getModalitiesFromParams(_negotiatedParams);
          var needNewRenegotiation = _forceRenegotiation || !helper.areNegotiatedDirectionsAcceptable(_configuredModalities, _negotiatingModalities, _activeModalities);
          if (needNewRenegotiation) {
            _triggerRenegotiation();
          }
          _logger.log('_completeNegotiationAsync: configured:', JSON.stringify(_configuredModalities), '_negotiatingModalities:', JSON.stringify(_negotiatingModalities), 'activeModalities:', JSON.stringify(_activeModalities));
          return {
            isComplete: !needNewRenegotiation,
            activeModalities: _activeModalities,
            configuredModalities: _configuredModalities
          };
        }));
      });
    }
    function _rejectNegotiationAsync(error) {
      return new Promise(function (resolve) {
        var isComplete = error === CONSTANTS.RENEGOTIATION_ERROR.local;
        _state.state = _state.STABLE;
        _logger.error('negotiation failed', 'error:', error);
        if (error === CONSTANTS.RENEGOTIATION_ERROR.signaling || error === CONSTANTS.RENEGOTIATION_ERROR.media) {
          _logger.log('retrying failed negotiation');
          _triggerRenegotiation();
        }
        //note on glare case we dont trigger new negotiation because we will receive soon new offer
        resolve({
          isComplete: isComplete,
          activeModalities: _activeModalities,
          configuredModalities: _configuredModalities
        });
      });
    }
    function _createRemoteRenderer(element, cb) {
      var RemoteRenderer = function (_element, _cb) {
        _deviceManager.Renderer.call(this, _element, _cb);
        var _that = this, _baseDispose = this.dispose, _isDisposed = false, _deferred = helper.defer(), _subscription;
        this._unsubscribeIfSubscribed = function () {
          if (_subscription) {
            _subscription.remove(_that);
            _subscription = void 0;
          }
        };
        this._updateRecvTrack = function (msi, track) {
          _logger.log('renderer._updateRecvTrack - attachMediaStream', 'msi:', msi, 'track:', track);
          _that._attachMediaStream(track ? new MediaStream([track]) : null);  //okay it replace with new stream
        };
        this.subscribeVideoAsync = function (msi) {
          _logger.info('subscribeVideoAsync', 'msi:', msi);
          //assert(!disposed);
          return new Promise(function (resolve) {
            // if not given, subscribe to any (-2)
            if (typeof msi === 'undefined') {
              msi = CONSTANTS.MSI.subscribeAny;
            }
            if (!_isDisposed) {
              //not optimizing user to subscribe for same msi several times in a row ...
              _that._unsubscribeIfSubscribed();
              // if msi unsubscribe given, then we are done here
              if (msi === CONSTANTS.MSI.unsubscribe) {
                return;
              }
              if (_deferred.isPending()) {
                _deferred.resolve();
                //resubscribed succeed previous operation, or fail???
                _deferred = helper.defer();
              }
              //create new "array" of subscribers, i.e. many video elements can render same video...
              if (!_subscriptionMap.hasOwnProperty(msi)) {
                //basically create new class...
                var deferredMediaChannelSubscribed = helper.defer(), renderers = [], subscribedMediaChannel, isDisposed = false, track = null, dispose = function () {
                    if (!isDisposed) {
                      renderers = [];
                      //clean up renderers used when we get disposed before renderers themselves
                      if (deferredMediaChannelSubscribed.isPending()) {
                        deferredMediaChannelSubscribed.reject();
                      }
                      if (subscribedMediaChannel) {
                        subscribedMediaChannel.unsubscribe();  //last one unsubscribes
                      }
                      delete _subscriptionMap[msi];
                      isDisposed = true;
                    }
                  }, update = function () {
                    if (deferredMediaChannelSubscribed.isPending()) {
                      //get first channel which is not subscribed yet and subscribe to it
                      for (var i = 0; i < _mediaChannels.length; i++) {
                        var mediaChannel = _mediaChannels[i];
                        if (mediaChannel && mediaChannel.canSubscribe() && mediaChannel.subscribe(msi)) {
                          subscribedMediaChannel = mediaChannel;
                          deferredMediaChannelSubscribed.resolve();
                          break;
                        }
                      }
                    }
                    if (subscribedMediaChannel) {
                      var newTrack = subscribedMediaChannel.getRecvTrack();
                      if (newTrack !== track) {
                        track = newTrack;
                        renderers.forEach(function (renderer) {
                          renderer._updateRecvTrack(msi, track);
                        });
                      }
                    }
                  };
                _subscriptionMap[msi] = {
                  add: function (renderer, deferred) {
                    //NB! works with q promises. i.e. if deferred is rejected outside, there is no error to reject or resolve it later again it will be noop
                    deferredMediaChannelSubscribed.promise.then(deferred.resolve, deferred.reject);
                    renderers.push(renderer);
                    update();
                  },
                  remove: function (renderer) {
                    var index = renderers.indexOf(renderer);
                    if (index !== -1) {
                      renderers.splice(index, 1);
                      if (renderers.length === 0) {
                        dispose();
                      }
                    }
                  },
                  update: update,
                  dispose: dispose
                };
              }
              _subscription = _subscriptionMap[msi];
              _subscription.add(_that, _deferred);
            }
            resolve(_deferred.promise);
          });
        };
        this.dispose = function () {
          _logger.debug('disposing remote renderer');
          _that._unsubscribeIfSubscribed();
          if (_deferred.isPending()) {
            _deferred.reject(new Error('disposing'));
          }
          _isDisposed = true;
          _baseDispose();
        };
      };
      return new RemoteRenderer(element, cb);
    }
    function _deviceSelectionChanged() {
      _logger.log('_deviceSelectionChanged');
      if (_state.state !== _state.TERMINATED && _negotiatedParams) {
        var audioDescr = _findDescrFromMedia(_negotiatedParams.media, CONSTANTS.MEDIA_LABEL.audio);
        var videoDescr = _findDescrFromMedia(_negotiatedParams.media, CONSTANTS.MEDIA_LABEL.video);
        if (audioDescr.send || videoDescr.send) {
          _deviceManager.getMediaStreamRefAsync({
            audio: audioDescr.send,
            video: videoDescr.send
          }).then(function (mediaStreamRef) {
            var channel;
            if (audioDescr.send) {
              channel = _findFirstChannelByLabel(_mediaChannels, CONSTANTS.MEDIA_LABEL.audio);
              channel.updateLocalMediaStream(mediaStreamRef);
            }
            if (videoDescr.send) {
              channel = _findFirstChannelByLabel(_mediaChannels, CONSTANTS.MEDIA_LABEL.video);
              channel.updateLocalMediaStream(mediaStreamRef);
            }
            // _mediaChannels performed mediaStreamRef.clone() if they use the track
            mediaStreamRef.dispose();
          }).catch(function (error) {
            _raiseError({
              type: CONSTANTS.MEDIA_ERROR.internalError,
              detail: error
            });
          });
        }
      }
    }
    function _getStatsAsync() {
      return new Promise(function (resolve, reject) {
        var stats = {
          localStreams: [{ tracks: [] }],
          remoteStreams: [{ tracks: [] }]
        };
        var audioChannel = _findFirstChannelByLabel(_mediaChannels, CONSTANTS.MEDIA_LABEL.audio);
        var videoChannel = _findFirstChannelByLabel(_mediaChannels, CONSTANTS.MEDIA_LABEL.video);
        if (audioChannel && audioChannel.getSendTrack()) {
          stats.localStreams[0].tracks.push({
            stream: null,
            track: audioChannel.getSendTrack()
          });
        }
        if (videoChannel && videoChannel.getSendTrack()) {
          stats.localStreams[0].tracks.push({
            stream: null,
            track: videoChannel.getSendTrack()
          });
        }
        if (audioChannel && audioChannel.getRecvTrack()) {
          stats.remoteStreams[0].tracks.push({
            stream: null,
            track: audioChannel.getRecvTrack()
          });
        }
        if (videoChannel && videoChannel.getRecvTrack()) {
          stats.remoteStreams[0].tracks.push({
            stream: null,
            track: videoChannel.getRecvTrack()
          });
        }
        Promise.all([
          audioChannel ? audioChannel.getReportsAsync() : null,
          videoChannel ? videoChannel.getReportsAsync() : null
        ]).then(function (reports) {
          stats.ortcReports = {
            mainAudio: reports[0],
            mainVideo: reports[1]  // NOTE: add support for other modalities here
          };
          resolve(stats);
        }).catch(function (error) {
          reject(error);
        });
      });
    }
    function _terminate() {
      _logger.log('terminate');
      _state.change(_state.TERMINATED);
      _transport.stop();
      _stopAudio();
      // this will reject pending async subscriptions too
      _unsubscribeRenderers();
      _mediaChannels.forEach(function (channel) {
        if (channel) {
          channel.terminate();
        }
      });
      if (_that._onTerminated) {
        _that._onTerminated(_that);
      }
    }
  }
  return ORtcSession;
}(ortcTransport, ortcMediaChannel, ortcParameters, ortcSdp, constants, helper);
session = function (WebRtcSession, OrtcSession) {
  if (typeof RTCIceGatherer === 'undefined') {
    return WebRtcSession;
  }
  return OrtcSession;
}(webRtcSession, ortcSession);
deviceManager = function (CONSTANTS) {
  var DM_CONSTANTS = {
    DEVICE_MANAGER: {
      microphone: {
        DEFAULT: {
          DEVICE_ID: 'default_audio_device',
          DEVICE_LABEL: 'Default audio device'
        }
      },
      camera: {
        DEFAULT: {
          DEVICE_ID: 'default_video_device',
          DEVICE_LABEL: 'Default video device'
        }
      }
    }
  };
  var DeviceManager = function (_context, _callback) {
    //this._deviceSelectionChanged
    this.enumerateDevicesAsync = _enumerateDevicesAsync;
    this.selectDevices = _selectDevices;
    this.getSelectedDevices = _getSelectDevices;
    this.muteInputAsync = _muteInputAsync;
    this.unmuteInputAsync = _unmuteInputAsync;
    this.createPreviewRenderer = _createPreviewRenderer;
    //used internally by session
    this.getMediaStreamRefAsync = _getMediaStreamRefAsync;
    var _that = this;
    var _logger = _context.getLogger();
    var _devices = {};
    //assuming deviceId's are unique i.e. no camera can share same device id with microphone
    var _selectedDevices = {
      microphone: DM_CONSTANTS.DEVICE_MANAGER.microphone.DEFAULT.DEVICE_ID,
      camera: DM_CONSTANTS.DEVICE_MANAGER.camera.DEFAULT.DEVICE_ID
    };
    var _cachedStreams = [];
    var _cachedStreamGeneration = 0;
    var _activeRenderers = [];
    var _globalAudioEnable;
    //defaults to not set
    var _getDevicesPromise;
    //serialize device enumeration via this sequence
    var _pollDeviceListChangesTimer;
    function _updateRenderersAsync() {
      if (_activeRenderers.length) {
        return _getMediaStreamAsync({
          audio: true,
          video: true
        }).then(function (sharedMediaStream) {
          _activeRenderers.forEach(function (renderer) {
            renderer._attachMediaStreamRef(sharedMediaStream);
          });
        });
      }
      return Promise.resolve();
    }
    var AudioVideoRenderer = function (element, cb) {
      var _video = document.createElement('video'), _lastNotifiedVideoWidth = 0, _lastNotifiedVideoHeight = 0, _stream = null, _onVideoDataUpdated = function () {
          if (cb && cb.onVideoSizeChanged) {
            var width = _video.videoWidth, height = _video.videoHeight;
            if (width < 32 || height < 32) {
              //temp: workaround for Microsoft Edge where all video events that should report video size are fired before actual video size is known
              width = height = 0;
            }
            if (_lastNotifiedVideoWidth !== width || _lastNotifiedVideoHeight !== height) {
              _lastNotifiedVideoWidth = width;
              _lastNotifiedVideoHeight = height;
              cb.onVideoSizeChanged(width, height);
            }
          }
        }, _onVideoError = function () {
          _logger.error('_video.onerror', 'error:', _video.error);
        };
      _video.autoplay = true;
      _video.addEventListener('loadedmetadata', _onVideoDataUpdated);
      _video.addEventListener('timeupdate', _onVideoDataUpdated);
      _video.addEventListener('error', _onVideoError);
      this.getVideoElement = function () {
        return _video;
      };
      this.dispose = function () {
        _video.removeEventListener('loadedmetadata', _onVideoDataUpdated);
        _video.removeEventListener('timeupdate', _onVideoDataUpdated);
        _video.removeEventListener('error', _onVideoError);
        _attachMediaStream(null);
        _video = null;
      };
      function _attachMediaStream(mediaStream) {
        if (_stream) {
          //note not stopping the stream here
          if (!mediaStream) {
            element.removeChild(_video);
          }
          window.detachMediaStream(_video);
        }
        if (mediaStream) {
          _video.hidden = mediaStream.getVideoTracks().length === 0;
          window.attachMediaStream(_video, mediaStream);
          //NB! not detaching when stream changed
          if (!_stream) {
            element.appendChild(_video);
          }
        }
        _stream = mediaStream;
      }
      this._attachMediaStream = _attachMediaStream;
    };
    this.Renderer = AudioVideoRenderer;
    var LocalVideoRenderer = function (element, cb) {
      AudioVideoRenderer.call(this, element, cb);
      var _that = this, _baseDispose = this.dispose, _streamRef = null, _isDisposed = false;
      _that.getVideoElement().style.width = '100%';
      _that.getVideoElement().style.height = '100%';
      _that.getVideoElement().muted = true;
      this._attachMediaStreamRef = function (newStreamRef) {
        try {
          if (_streamRef) {
            _streamRef.dispose();
            _streamRef = null;
          }
          this._attachMediaStream(newStreamRef.getObject());
          _streamRef = newStreamRef;
        } catch (error) {
          newStreamRef.dispose();
          throw error;
        }
      };
      this.dispose = function () {
        _isDisposed = true;
        var index = _activeRenderers.indexOf(_that);
        if (index !== -1) {
          _activeRenderers.splice(index, 1);
        }
        _baseDispose();
        if (_streamRef) {
          _streamRef.dispose();
          _streamRef = null;
        }
      };
      this.startVideoAsync = function () {
        return _getMediaStreamAsync({
          audio: true,
          video: true
        }).then(function (sharedMediaStream) {
          if (_isDisposed) {
            sharedMediaStream.dispose();
            //important or ref counting fails
            throw new Error('disposed');
          }
          _that._attachMediaStreamRef(sharedMediaStream);
          _activeRenderers.push(_that);
        });
      };
    };
    //LocalVideoRenderer.prototype = new AudioVideoRenderer();
    //LocalVideoRenderer.prototype.constructor = LocalVideoRenderer;
    function _getUserMediaAsync(constraints) {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      }
      return new Promise(function (resolve, reject) {
        navigator.getUserMedia(constraints, resolve, reject);
      });
    }
    function _weakCompareObject(a, b) {
      // fast but limited/weak way of comparing list. x will not equal to y:
      //  x = {a: 1, b: 2};
      //  y = {b: 2, a: 1};
      // in our use case, this limitation should be tolerable, since assumption is that
      // device list should be stable for us.
      return JSON.stringify(a) === JSON.stringify(b);
    }
    function _handleDevicesChanged(oldDevices, newDevices) {
      var hasRemoved = false, removedDevices = {}, hasAdded = false, addedDevices = {}, key;
      for (key in oldDevices) {
        if (oldDevices.hasOwnProperty(key) && !newDevices.hasOwnProperty(key)) {
          removedDevices[key] = oldDevices[key];
          hasRemoved = true;
          _logger.log('media device removed', 'kind:', removedDevices[key].kind, 'id:', removedDevices[key].id, 'label:', removedDevices[key].label);
        }
      }
      for (key in newDevices) {
        if (newDevices.hasOwnProperty(key) && !oldDevices.hasOwnProperty(key)) {
          addedDevices[key] = newDevices[key];
          hasAdded = true;
          _logger.log('media device added', 'kind:', addedDevices[key].kind, 'id:', addedDevices[key].id, 'label:', addedDevices[key].label);
        }
      }
      if (hasRemoved) {
        _cachedStreams.forEach(function (cachedStream) {
          cachedStream.outdateIfAnyDeviceRemoved(removedDevices);
        });
      }
      if (hasRemoved || hasAdded) {
        //NB! not triggering callback when only labels changed, we can change this if needed...
        if (_callback.onDevicesChanged) {
          _callback.onDevicesChanged(newDevices);
        }
      }
    }
    function _enumerateDevicesAsync() {
      return _getDevicesAsync(false);
    }
    function _enumerateMediaDevicesAsync() {
      return new Promise(function (resolve, reject) {
        function gotSources(mediaSources) {
          var devices = {};
          mediaSources.forEach(function (mediaSource) {
            if (mediaSource) {
              //NB! last device with same id will overwrite the label and kind!
              //side effect: all duplicates removed (replaced by last)
              devices[mediaSource.id] = {
                id: mediaSource.id,
                label: mediaSource.label,
                kind: mediaSource.kind
              };
            }
          });
          resolve(devices);
        }
        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
          navigator.mediaDevices.enumerateDevices().then(function (devices) {
            var skipFirstAudioDevice = !!navigator.webkitGetUserMedia;
            // for chrome & ff, skip first audio device (on ff first and some subsequent device have same id, but not on Chrome)
            // reason for skipping default one should be revisited, as it was related to the removal of default device during a call... todo put better reason here
            gotSources(devices.map(function (device) {
              switch (device.kind) {
              case 'audioinput':
                if (skipFirstAudioDevice) {
                  skipFirstAudioDevice = false;
                  return null;
                }
                return {
                  id: device.deviceId,
                  label: device.label,
                  kind: CONSTANTS.MEDIA_DEVICE.microphone
                };
              case 'videoinput':
                return {
                  id: device.deviceId,
                  label: device.label,
                  kind: CONSTANTS.MEDIA_DEVICE.camera
                };
              default:
                return null;
              }
            }));
          }).catch(reject);
        } else if (typeof MediaStreamTrack.getSources !== 'undefined') {
          //older Chrome
          MediaStreamTrack.getSources(function (devices) {
            var skipFirstAudioDevice = true;
            gotSources(devices.map(function (device) {
              switch (device.kind) {
              case 'audio':
                if (skipFirstAudioDevice) {
                  skipFirstAudioDevice = false;
                  return null;
                }
                return {
                  id: device.id,
                  label: device.label,
                  kind: CONSTANTS.MEDIA_DEVICE.microphone
                };
              case 'video':
                return {
                  id: device.id,
                  label: device.label,
                  kind: CONSTANTS.MEDIA_DEVICE.camera
                };
              default:
                return null;
              }
            }));
          });
        } else {
          gotSources([
            {
              id: DM_CONSTANTS.DEVICE_MANAGER.microphone.DEFAULT.DEVICE_ID,
              label: DM_CONSTANTS.DEVICE_MANAGER.microphone.DEFAULT.DEVICE_LABEL,
              kind: CONSTANTS.MEDIA_DEVICE.microphone
            },
            {
              id: DM_CONSTANTS.DEVICE_MANAGER.camera.DEFAULT.DEVICE_ID,
              label: DM_CONSTANTS.DEVICE_MANAGER.camera.DEFAULT.DEVICE_LABEL,
              kind: CONSTANTS.MEDIA_DEVICE.camera
            }
          ]);
        }
      });
    }
    function _selectDevices(devices) {
      // devices = {microphone: devId, camera:devId};
      var newSelectedDevices = {};
      for (var kind in devices) {
        if (devices.hasOwnProperty(kind)) {
          var deviceId = devices[kind];
          //NB! using device.id as key to index _devices! (this assumes that device id and key in devices are the same)
          if (_devices.hasOwnProperty(deviceId)) {
            // paranoia(_devices[deviceId].kind === kind)
            newSelectedDevices[kind] = deviceId;
          } else {
            _logger.warn('device selection is invalid', 'kind:', kind, 'id:', deviceId);
          }
        }
      }
      if (!_weakCompareObject(_selectedDevices, newSelectedDevices)) {
        var configureModalitiesNeeded = 'camera' in _selectedDevices ^ 'camera' in newSelectedDevices || 'microphone' in _selectedDevices ^ 'microphone' in newSelectedDevices;
        _selectedDevices = newSelectedDevices;
        //note: device change will notify all device (media stream) users such as session and local previews and then those iff they are using media stream ask for the stream again
        if (_that._deviceSelectionChanged) {
          // if configureModalitiesNeeded, we rely on user to trigger configureModalities
          if (!configureModalitiesNeeded) {
            _that._deviceSelectionChanged();
          }
        }
        _updateRenderersAsync();  //will throw error out to the user
      }
    }
    function _getSelectDevices() {
      return _selectedDevices;
    }
    function _createPreviewRenderer(element, cb) {
      return new LocalVideoRenderer(element, cb);
    }
    function _getMediaStreamRefAsync(modalities) {
      return _getMediaStreamAsync(modalities).then(function (sharedMediaStream) {
        return sharedMediaStream;
      });
    }
    function _createCachedStreamPromise(audio, video, microphone, camera, userMediaPromise) {
      var _mediaStream = null, _refCount = 1, _outDated = false, _cachedStream = {
          getPromise: function () {
            _refCount += 1;
            //if promise fails then we don't need to dispose media stream and counter only increments...
            return _promise;
          },
          isSuitable: function (modalities, devIds) {
            return !_outDated && (modalities.audio === audio && modalities.video === video && (!modalities.audio || microphone === devIds.microphone) && (!modalities.video || camera === devIds.camera));
          },
          outdateIfAnyDeviceRemoved: function (removedDevices) {
            if (_outDated) {
              return;
            }
            for (var key in removedDevices) {
              if (removedDevices.hasOwnProperty(key)) {
                var device = removedDevices[key];
                if (microphone === device.id || camera === device.id) {
                  //paranoia(device.kind === CONSTANTS.MEDIA_DEVICE.camera)
                  _outDated = true;
                }
              }
            }
          }
        }, _promise = userMediaPromise.then(function (mediaStream) {
          var streamGeneration = _cachedStreamGeneration++;
          if (typeof _globalAudioEnable !== 'undefined') {
            _setAudioTracksEnable(mediaStream.getAudioTracks(), _globalAudioEnable);
          }
          _mediaStream = mediaStream;
          _logger.log('create media stream', 'generation:', streamGeneration, 'cached:', _cachedStreams.length, 'audio:', audio, 'video;', video);
          //important, user of this pormise MUST call mediaStream.dispose() after it no longer needs the media stream
          return {
            getObject: function () {
              return _mediaStream;
            },
            clone: function () {
              _refCount += 1;
              return this;
            },
            dispose: function () {
              _refCount -= 1;
              if (_refCount === 0) {
                try {
                  _logger.log('release media stream', 'generation:', streamGeneration, 'cached:', _cachedStreams.length, 'audio:', audio, 'video:', video);
                  window.stopMediaStream(_mediaStream);
                } catch (error) {
                  _logger.warn('exception', 'error:', error);
                }
                _cachedStreams.splice(_cachedStreams.indexOf(_cachedStream), 1);
              }
            }
          };
        }).catch(function (error) {
          _cachedStreams.splice(_cachedStreams.indexOf(_cachedStream), 1);
          throw error;
        });
      _cachedStreams.push(_cachedStream);
      return _promise;
    }
    function _getCachedStreamPromise(modalities) {
      // check cached streams if anything is suitable
      for (var i = 0; i < _cachedStreams.length; i++) {
        if (_cachedStreams[i].isSuitable(modalities, _selectedDevices)) {
          return _cachedStreams[i].getPromise();
        }
      }
      return null;
    }
    function _getMediaStreamAsync(modalities) {
      return new Promise(function (resolve, reject) {
        if (!modalities.audio && !modalities.video) {
          throw new Error('requesting nothing');
        }
        var cachedStreamPromise = _getCachedStreamPromise(modalities);
        if (!cachedStreamPromise) {
          var constraints = {};
          if (modalities.audio && _selectedDevices.microphone) {
            constraints.audio = {};
            if (_selectedDevices.microphone !== DM_CONSTANTS.DEVICE_MANAGER.microphone.DEFAULT.DEVICE_ID) {
              constraints.audio.deviceId = { exact: _selectedDevices.microphone };
            }
          }
          if (modalities.video && _selectedDevices.camera) {
            constraints.video = {};
            if (_selectedDevices.camera !== DM_CONSTANTS.DEVICE_MANAGER.camera.DEFAULT.DEVICE_ID) {
              constraints.video.deviceId = { exact: _selectedDevices.camera };
            }
          }
          cachedStreamPromise = _createCachedStreamPromise(!!constraints.audio, !!constraints.video, _selectedDevices.microphone, _selectedDevices.camera, _getUserMediaAsync(constraints));
        }
        cachedStreamPromise.then(resolve, reject);
      });
    }
    function _setAudioTracksEnable(audioTracks, enable) {
      audioTracks.forEach(function (track) {
        if (typeof track.enabled !== 'undefined') {
          track.enabled = enable;
          _logger.log('control audio', 'enabled:', track.enabled, 'muted:', track.muted);
        }
      });
    }
    function _controlAudioAsync(enable) {
      _globalAudioEnable = enable;
      return _cachedStreams.reduce(function (soFar, cachedStream) {
        return soFar.then(function () {
          return cachedStream.getPromise().then(function (sharedMediaStream) {
            _setAudioTracksEnable(sharedMediaStream.getObject().getAudioTracks(), enable);
            sharedMediaStream.dispose();
          });
        });
      }, Promise.resolve());
    }
    function _muteInputAsync() {
      return _controlAudioAsync(false);
    }
    function _unmuteInputAsync() {
      return _controlAudioAsync(true);
    }
    function _getDevicesAsync(doForceUpdate) {
      if (!_getDevicesPromise || doForceUpdate) {
        var promise = _enumerateMediaDevicesAsync().then(function (devices) {
          _handleDevicesChanged(_devices, devices);
          _devices = devices;
          return devices;
        });
        if (!_getDevicesPromise) {
          //first time devices are queried will trigger the timer, timer will be canceled if UA supports ondevicechange
          _pollDeviceListChangesTimer = setTimeout(_pollDeviceListChanges, 1000);
        }
        _getDevicesPromise = _getDevicesPromise ? _getDevicesPromise.then(promise) : promise;
      }
      return _getDevicesPromise;
    }
    // FIXME do not poll if ondevicechange is supported
    function _pollDeviceListChanges() {
      _getDevicesAsync(true).then(function () {
        _pollDeviceListChangesTimer = setTimeout(_pollDeviceListChanges, 1000);
      });
    }
    // media devices change callback
    if (navigator.mediaDevices) {
      navigator.mediaDevices.ondevicechange = function () {
        if (_getDevicesPromise) {
          if (_pollDeviceListChangesTimer) {
            //disable timer when we do get event
            clearTimeout(_pollDeviceListChangesTimer);
            _pollDeviceListChangesTimer = void 0;
          }
          _getDevicesAsync(true);
        }
      };
    }
  };
  return DeviceManager;
}(constants);
mediaAgent = function (Session, DeviceManager) {
  var MediaAgent = function (context, deviceManagerCallback) {
    var _logger = context.getLogger().createChild('MA', context.settings.debug), deviceManagerCtx = {
        getLogger: function () {
          return _logger.createChild('DeviceManager');
        }
      }, _deviceManager = new DeviceManager(deviceManagerCtx, deviceManagerCallback), _activeSessions = [];
    _deviceManager._deviceSelectionChanged = function () {
      _activeSessions.forEach(function (session) {
        session._deviceSelectionChanged();
      });
    };
    function _getDeviceManager() {
      return _deviceManager;
    }
    this.createSession = function (callback, callId, sessionConfig) {
      var sessionLogger = _logger.createChild('Session').createChild(callId), sessionCtx = {
          getDeviceManager: _getDeviceManager,
          getLogger: function () {
            return sessionLogger;
          },
          maContext: context,
          config: sessionConfig ? sessionConfig : {}
        }, session = new Session(sessionCtx, callId, callback);
      session._onTerminated = function (session) {
        var index = _activeSessions.indexOf(session);
        if (index !== -1) {
          _activeSessions.splice(index, 1);
        }
      };
      _activeSessions.push(session);
      return session;
    };
    this.getDeviceManager = _getDeviceManager;
  };
  return {
    build: function (context, deviceManagerCallback) {
      return new MediaAgent(context, deviceManagerCallback);
    },
    isPlatformSupported: function () {
      return navigator.getUserMedia && (typeof RTCPeerConnection !== 'undefined' || typeof RTCIceGatherer !== 'undefined');
    }
  };
}(session, deviceManager);
Media.Constants = constants;
Media.MediaAgent = mediaAgent;
Media.Helper = helper;
})(Media = Web.Media || (Web.Media = {}));
})(Web = Skype.Web || (Skype.Web = {}));
})(Skype || (Skype = {}));
}(Skype = window.Skype || {});
//# sourceMappingURL=skypeweb.js.map